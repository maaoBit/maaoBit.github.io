<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="maao"><meta name="keywords" content=""><title>[笔记]BPF and XDP Reference Guide(cilium) - MAAO的博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>maao's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"> <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"> <span class="h2" id="subtitle">[笔记]BPF and XDP Reference Guide(cilium)</span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-01 09:50" pubdate>2021年3月1日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 21.8k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 300 分钟</span><span id="leancloud-post-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i><span id="leancloud-post-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">[笔记]BPF and XDP Reference Guide(cilium)</h1><div class="markdown-body" id="post-body"><p>本文是Cilium中<a target="_blank" rel="noopener" href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a>的笔记。本文半翻译、半笔记，有些地方直接概况叙述。</p><p>学习BPF的过程：</p><ul><li>阅读相关文献，记录两篇的笔记。另一篇的链接<a href="https://maao.cloud/2021/02/24/%E7%AC%94%E8%AE%B0-Linux-Socket-Filtering-aka-Berkeley-Packet-Filter-BPF/">[笔记]Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a></li></ul><a id="more"></a><p>BPF类似于虚机指令集，允许在许多内核hook执行代码，主要用于网络、内核追踪以及安全（比如sandboxing）。</p><p>BPF的发展进过了cBPF与eBPF，tcpdump就是使用cBPF，但目前内核中只允许eBPF，兼容cBPF，cBPF的指令在内核中会自动替换为eBPF。</p><h2 id="BPF结构"><a href="#BPF结构" class="headerlink" title="BPF结构"></a>BPF结构</h2><p>BPF除了指令集，还有bpf map、辅助函数（helper functions）、尾调机制（tail calls）、安全强化原语（security hardening primitives）、用于pinning对象（BPF map或是BPF program）的伪文件系统，另外还支持网卡offload的指令。</p><p>编译：C -&gt; Clang -&gt; LLVM backend -&gt; BPF指令</p><p>BPF的两个主要子系统<code>tc</code>和<code>XDP</code>。</p><ul><li><code>XDP</code>在最早的网络驱动程序阶段，高性能 ，但数据包还未进行元数据的解析。</li><li><code>tc</code>位置在内核栈中，可以访问更多的数据包元数据以及内核函数。</li><li>其他的子系统还包括：<code>kprobes</code>、<code>uprobes</code>、<code>tracepoints</code>等。</li></ul><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>BPF是RISC指令集：</p><ul><li><p>BPF指令-&gt; JIT -&gt; 机器码</p></li><li><p>BPF指令直接在内核中操作，无需进行内核/用户空间的切换。</p></li><li><p>灵活的可编程数据路径（data path），通过减少场景无需的特性，提升程序性能。</p></li><li><p>无缝的BPF程序更新，无需重启内核 ，也不会中断网络。</p></li><li><p>稳定的用户空间ABI，可跨不同体系的移植。</p></li></ul><p>BPF是事件驱动的：例如数据包的接收触发ingress path上的BPF程序，内核代码的执行触发相应的kprobe BPF。</p><p>BPF包括11个64位的寄存器（包含32位的子寄存器）、程序计数器、512字节的栈。<br>寄存器分别是<code>r0</code>到<code>r10</code>，除了部分特殊的逻辑运算指令（ALU）外会使用其32位的子寄存器外，其他都是使用64位寄存器。32位到64位的扩展为高位补零。</p><ul><li><code>r0</code> 存放bpf helper函数的返回值。另外，整个BPF的返回值会以32位的形式存放在<code>r0</code>中。</li><li><code>r1-r5</code>存放调用bpf helper函数的实参，bpf helper函数之后，应作为未初始寄存器对待。因此在调用bpf helper函数之前，需要将<code>r1-r5</code>转存到<code>r6-r9</code>或是bpf的堆栈。</li><li><code>r1</code>在bpf执行开始，会存储上下文变量（ctx），一般根据BPF程序的不同，ctx不同，比如tc/bpf中，ctx是<code>sk_buff</code>的指针。</li><li><code>r6-r9</code>在bpf helper执行前后数据不变，可用于存放需要保持的数据</li><li><code>r10</code>唯一只读的寄存器，存储着bpf的堆栈地址。</li></ul><p>BPF helper最多支持5个参数，在内核中BPF通过<code>BPF_CALL_0()</code>到<code>BPF_CALL_5()</code>进行声明。（注：后面数字表示参数数量，<code>include/uapi/linux/bpf.h</code>中有各个helper函数的注解）</p><p>BPF程序的指令数量最大限制在4096条，5.1版本的内核后，限制扩到100万个，但仍不允许存在循环，但可以前后跳转的指令，比如尾调<code>tail call</code>，尾调的上限为32层。</p><p>指令64位，目前有87条，格式（eBPF）如下，编码定义在<code>linux/bpf.h</code>下。</p><div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">op</span>:<span class="hljs-number">8</span>, dst_reg:<span class="hljs-number">4</span>, src_reg:<span class="hljs-number">4</span>, <span class="hljs-literal">off</span>:<span class="hljs-number">16</span>, imm:<span class="hljs-number">32</span></code></pre></div><p><code>op</code>字段表明了操作是基于寄存器还是立即数，基于立即数的<code>op</code>，其目的操作数始终为寄存器。<code>off</code>为偏移量，<code>imm</code>为立即数，两者都是有符号类型。</p><p><code>OP</code>的结构为<code>code:4,source:1,class:3</code>， <code>source</code>值：</p><ul><li><code>BPF_X</code>：基于寄存器的操作</li><li><code>BPF_K</code>：基于立即数的操作</li></ul><p><code>class</code>包括：</p><ul><li><code>BPF_LD</code>、<code>BPF_LDX</code>：<code>BPF_LD</code>是个特殊指令，用于double word的立即数加载，受限<code>imm:32</code>，会跨两个指令；<code>BPF_LD</code>也可以用于数据包的读取（注：会有一些使用约定，比如<code>r6</code>保存<code>sk_buff</code>的指针）。<code>BPF_LDX</code>从内存读取数据 ，内存可以是栈、map、数据包等。</li><li><code>BPF_ST</code>、<code>BPF_STX</code>：<code>BPF_STX</code>将寄存器中的数据存储到内存或者是bpf堆栈、bpf map等，<code>BPF_STX</code> 还可以做word和double-word的原子累加操作。<code>BPF_ST</code>与<code>BPF_STX</code>类似，但原数据只能是立即数。</li><li><code>BPF_ALU</code>、<code>BPF_ALU64</code>：<code>BPF_ALU</code>是32位操作，<code>BPF_ALU64</code>是64位操作，都支持 <code>+ - &amp; | &lt;&lt; &gt;&gt; ^ * / % ~</code>。两者还包含特殊的ALU操作：mov（<code>&lt;X&gt;:=&lt;Y&gt;</code>），<code>BPF_ALU64</code>还包含一组有符号的右移操作，<code>BPF_ALU</code>包含字节顺序转换的指令。</li><li><code>BPF_JMP</code>：包括无条件与有条件跳转。跳转的下一指令为<code>off+1</code>，因为<code>off</code>为有符号类型，可以完成前跳，但不能产生循环或跳出程序范围。不同于cBPF（存在true或false两个偏移量），条件跳转机制为fall-through，更符合CPU的分支预测逻辑。另外包含三个特殊的跳转操作：退出指令<code>exit instruction</code>；用于调用helper方法的调用指令<code>call instruction</code>；用于调用其他BPF程序的尾调指令<code>tail call instruction</code>。</li></ul><p>目前下列架构都内置了内核 eBPF JIT 编译器：<code>x86_64</code>、<code>arm64</code>、<code>ppc64</code>、<code>s390x</code> 、<code>mips64</code>、<code>sparc64</code> 和 <code>arm</code>。</p><p>通过系统调用<code>bpf()</code>可以进行：</p><ul><li>创建、加载、卸载BPF程序</li><li>创建、操作BPF map</li><li>pinning BPF map和BPF程序到BPF文件系统中（做持久化）</li></ul><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p><strong>不同类型的BPF 程序能够使用的辅助函数不完全相同</strong>。</p><div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">u64</span> fn(u<span class="hljs-number">64</span> r<span class="hljs-number">1</span>, u<span class="hljs-number">64</span> r<span class="hljs-number">2</span>, u<span class="hljs-number">64</span> r<span class="hljs-number">3</span>, u<span class="hljs-number">64</span> r<span class="hljs-number">4</span>, u<span class="hljs-number">64</span> r<span class="hljs-number">5</span>)</code></pre></div><p><strong>内核将辅助函数抽象为<code>BPF_CALL_0()</code>到<code>BPF_CALL_5()</code>几个宏</strong>，例如map update的调用（注：<code>BPF_CALL_4</code>表示4个参数，后面依次是参数类型，参数；<code>bpf_func_proto</code>给verifier进行调用的参数类型验证，另外<code>map-&gt;ops-&gt;map_update_elem</code>不同bpf map类型有不同的实现，在<code>kernel\bpf</code>下）：</p><div class="hljs"><pre><code class="hljs c">BPF_CALL_4(bpf_map_update_elem, struct bpf_map *, <span class="hljs-built_in">map</span>, <span class="hljs-keyword">void</span> *, key,
           <span class="hljs-keyword">void</span> *, value, u64, flags)
&#123;
    WARN_ON_ONCE(!rcu_read_lock_held());
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="hljs-built_in">map</span>, key, value, flags);
&#125;

<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_func_proto</span> <span class="hljs-title">bpf_map_update_elem_proto</span> = &#123;</span>
    .func           = bpf_map_update_elem,
    .gpl_only       = <span class="hljs-literal">false</span>,
    .ret_type       = RET_INTEGER,
    .arg1_type      = ARG_CONST_MAP_PTR,
    .arg2_type      = ARG_PTR_TO_MAP_KEY,
    .arg3_type      = ARG_PTR_TO_MAP_VALUE,
    .arg4_type      = ARG_ANYTHING,
&#125;;</code></pre></div><ul><li>根据之前的约定（<code>r1-r5</code>传递参数），JIT只需要进行跳转，不需要进行寄存器的操作。</li><li>参数可以是任意类型，也可以是堆栈的指针。</li><li>内核<code>struct bpf_verifier_ops</code>包含回调函数<code>get_func_proto</code>，能根据BPF程序类型（<code>enum bpf_func_id</code>）来映射可用的BPF helper函数。</li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p><img src="/img/bpf-2021030101.png" srcset="/img/loading.gif"></p><p>map驻留在内存中，可以通过用户空间的<strong>文件描述符</strong>访问，可以在任意BPF程序以及用户空间应用之间共享。共享map的BPF程序不需要是相同的程序类型，单个BPF程序最多可以访问64个map。</p><p>map有<code>per-CPU</code>以及<code>non-per-CPU</code>的通用map，另外还有提供给特定辅助函数的非通用map。通用map包括 <code>BPF_MAP_TYPE_HASH</code>, <code>BPF_MAP_TYPE_ARRAY</code>, <code>BPF_MAP_TYPE_PERCPU_HASH</code>, <code>BPF_MAP_TYPE_PERCPU_ARRAY</code>, <code>BPF_MAP_TYPE_LRU_HASH</code>, <code>BPF_MAP_TYPE_LRU_PERCPU_HASH</code> 和 <code>BPF_MAP_TYPE_LPM_TRIE</code>，他们都使用相同的一组BPF辅助函数来执行查找、更新或删除等。</p><p>非通用map包括 <code>BPF_MAP_TYPE_PROG_ARRAY</code>, <code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>, <code>BPF_MAP_TYPE_CGROUP_ARRAY</code>, <code>BPF_MAP_TYPE_STACK_TRACE</code>, <code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>, <code>BPF_MAP_TYPE_HASH_OF_MAPS</code>。例如 <code>BPF_MAP_TYPE_PROG_ARRAY</code>用于存储其他BPF程序，<code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>用于存储其他map的指针。这些map都是为了与bpf help一起完成特定功能。</p><h3 id="Object-Pinning"><a href="#Object-Pinning" class="headerlink" title="Object Pinning"></a>Object Pinning</h3><p><img src="/img/bpf-2021030102.png" srcset="/img/loading.gif"></p><p>BPF maps和BPF程序只能通过文件描述符访问，后端是匿名inode。用户空间的程序可以利用大多数文件描述符的APIs进行操作。但同时，文件描述符被限制在程序的生命周期内，使得map共享之类操作难以实现（比如tc的ingress和egress BPF程序希望共享一个bpf map，或是在BPF运行期间监视和更新BPF map）。</p><p>为克服此限制，实现了一个最小的内核空间的BPF文件系统，BPF map和BPF程序可以被Pin到此文件系统中。两个BPF系统调用<code>BPF_OBJ_PIN</code>和<code>BPF_OBJ_GET</code>分别用于pin操作和获取被pin的对象。</p><p>利用BPF文件系统，tc可以实现ingress和egress的map共享，BPF文件系统不是单例模式，支撑多挂载实例、硬链接、软链接等。</p><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p><img src="/img/bpf-2021030103.png" srcset="/img/loading.gif"></p><p>尾调（tail calls）允许BPF程序调用其他BPF程序，但不再返回父程序。相比于通常的调用，尾调开销小，实现了远跳转（long jump），复用原来的栈帧（stack frame）（因为不用返回 ？）。</p><p>由于BPF程序是单独验证的，因此状态的传递要么是使用<code>per-cpu</code> map，或是对于tc程序 ，使用<code>skb</code>中的字段，例如<code>cb[]</code>（Controller buff）。</p><p>尾调只能在相同类型的BPF程序之间，尾调的程序要么都是通过JIT编译的，要么都是通过解释器执行的，不能混合。</p><p>尾调涉及两个组件：一个是程序map <code>BPF_MAP_TYPE_PROG_ARRAY</code>，可以由用户空间进行填充，其值为尾调的BPF程序的文件描述符；另一个是辅助函数<code>bpf_tail_call()</code>，传入的参数包括一个程序map的引用以及需要查询的key。然后内核将这个辅助函数内联（inlines）到专门的BPF指令中。目前，程序数组在用户空间只写。</p><p>内核根据传入的文件描述符查找相关的 BPF 程序，然后自动替换。如果没有map对应的value，内核会fall through ，继续执行 <code>bpf_tail_call()</code> 后面的指令。尾调可用来解析报文头。另外，在运行时，尾调函数可自动添加替换，从而实现BPF程序行为的改变。</p><h3 id="BPF到BPF的调用"><a href="#BPF到BPF的调用" class="headerlink" title="BPF到BPF的调用"></a>BPF到BPF的调用</h3><p><img src="/img/bpf-2021030104.png" srcset="/img/loading.gif"></p><p>除了BPF辅助函数、BPF尾调函数外，还有一个特性：BPF to BFP calls。在引入此特性之前，BPF C程序使用<code>always_inline</code>声明方法，每次调用都进行内联，会增加代码的大小</p><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __inline</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __inline                         \</span>
   <span class="hljs-keyword">inline</span> __attribute__((always_inline))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-function"><span class="hljs-keyword">static</span> __inline <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> XDP_DROP;
&#125;

__section(<span class="hljs-string">&quot;prog&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> foo();
&#125;

<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre></div><p>从内核4.16和LLVM6.0开始，不再需要使用<code>always_inline</code>：</p><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> XDP_DROP;
&#125;

__section(<span class="hljs-string">&quot;prog&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> foo();
&#125;

<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;
</code></pre></div><p>主流的BPF JIT都支持，例如<code>x86_64</code>和<code>arm64</code>。调用方式与BPF辅助函数类似，允许的最大嵌套调用为8。调用者可以将指针（比如指向堆栈的）向下传递给被调用者，但绝不能相反。</p><p>在内核5.9版本之前，BPF的尾调与子程序（BPF2BFP）是不兼容的，利用尾调的BPF程序无法减小应用image，无法加快加载。在内核5.10后，不再有此限制。但混合两个功能一起使用可能会导致内核栈溢出，下面是混合了BPF2BPF和尾调的情况：</p><p><img src="/img/bpf-2021030105.png" srcset="/img/loading.gif"></p><p>尾调在跳到目标程序之前，只会回溯（unwind）它当前的栈。如上图所示，如果子函数（sub-function，图中subfunc1）中有尾调方法，那么在执行func2时（从subfunc1尾调过去），父函数func1的栈会保留在func2的栈中。一旦func3终止，之前所有的栈都会被回溯（unwind）。</p><p>内核引入如下机制：调用链中的每个子程序的栈大小不可超过256字节，当存在BPF2BPF时，主函数（调用BPF2BPF的函数）可被认为是子程序。根据这个限制，BPF程序最后的栈大小被限制在8KB（256*尾调上限32）。</p><p>当前，BPF尾调与BPF2BPF组合调用功能只在<code>x86_64</code>上支持。</p><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p><img src="/img/bpf-2021030106.png" srcset="/img/loading.gif"></p><p>提供内核eBPF JIT编译器的架构包括：<code>x84_64</code>、<code>arm64</code>、<code>ppc64</code>、<code>s390x</code>、<code>mips64</code>、<code>sparc64</code>、32位的<code>arm</code>、<code>x86_32</code>。3开启JIT：</p><div class="hljs"><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_enable</code></pre></div><p>32位的<code>mips</code>,<code>ppc</code>和<code>sparc</code>只支持cBPF JIT，其他的架构不支持BPF JIT，需要使用内核的解释器。内核源代码中，通过grep <code>HAVE_EBPF_JIT</code>可以查询相应的支持。</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> git grep HAVE_EBPF_JIT arch/</span>
arch/arm/Kconfig:       select HAVE_EBPF_JIT   if !CPU_ENDIAN_BE32
arch/arm64/Kconfig:     select HAVE_EBPF_JIT
arch/powerpc/Kconfig:   select HAVE_EBPF_JIT   if PPC64
arch/mips/Kconfig:      select HAVE_EBPF_JIT   if (64BIT &amp;&amp; !CPU_MICROMIPS)
arch/s390/Kconfig:      select HAVE_EBPF_JIT   if PACK_STACK &amp;&amp; HAVE_MARCH_Z196_FEATURES
arch/sparc/Kconfig:     select HAVE_EBPF_JIT   if SPARC64
arch/x86/Kconfig:       select HAVE_EBPF_JIT   if X86_64</code></pre></div><p>JIT编译器加快了BPF程序的执行速度，因为与解释器（interpreter）比起来，JIT降低了每条指令的执行成本。通常，指令可以与基础架构的原生指令有一对一的映射，这也减少了最终可执行映像（executable image）的大小，因此对CPU更加友好。</p><h3 id="加固（Hardening）"><a href="#加固（Hardening）" class="headerlink" title="加固（Hardening）"></a>加固（Hardening）</h3><p>为了避免代码被损坏，BPF的解释器image（<code>struct bpf_prog</code>）以及JIT编译器image（<code>struct bpf_binary_header</code>）在内核中是只读。支持设置只读的架构：</p><div class="hljs"><pre><code class="hljs gradle">$ git <span class="hljs-keyword">grep</span> ARCH_HAS_SET_MEMORY | <span class="hljs-keyword">grep</span> select
arch<span class="hljs-regexp">/arm/</span>Kconfig:    select ARCH_HAS_SET_MEMORY
arch<span class="hljs-regexp">/arm64/</span>Kconfig:  select ARCH_HAS_SET_MEMORY
arch<span class="hljs-regexp">/s390/</span>Kconfig:   select ARCH_HAS_SET_MEMORY
arch<span class="hljs-regexp">/x86/</span>Kconfig:    select ARCH_HAS_SET_MEMORY</code></pre></div><p>其中<code>CONFIG_ARCH_HAS_SET_MEMORY</code>是不可配置的，总是开启的。<br>在<code>x86_64</code>中，开启<code>CONFIG_RETPOLINE</code>后，BGP的尾调通过<code>retpoline</code>实现间接跳转（retpoline是Google开发的针对Spectre变种2漏洞缓解利用技术），<code>CONFIG_RETPOLINE</code>默认是开启的。<br>当时设置<code>/proc/sys/net/core/bpf_jit_harden</code>为1时，对非特权用户的JIT编译会进行额外的加固过程，对性能有一定的影响，但仍比解释器要高。<br><strong>盲化</strong>：开启加固可以对BPF的32位和64位常量盲化（blind），防止JIT喷射攻击。</p><blockquote><p>JIT喷射攻击：攻击者利用包含立即数的脚本指令, 通过控制源程序将“常量” 作为立即数注入即时编译器的生成代码中(如指令 “XOR EAX 0x3c909090”), 然后通过一个控制流劫持漏洞跳转到“常量”的地址加一个偏移值, 此时“常量”就变成了可以被识别执行的代码片段。通过连续输入大量的常量就可以在代码缓存中生成攻击者需要的Shellcode。</p></blockquote><p>盲化的方式是通过两步将基于立即数的指令转化成基于寄存器的指令，比如load指令的盲化：1）将盲化后的<code>rnd^imm</code>立即数加载到寄存器；2）异或寄存器与<code>rnd</code>。<br>盲化关闭的程序：</p><div class="hljs"><pre><code class="hljs angelscript"># echo <span class="hljs-number">0</span> &gt; /proc/sys/net/core/bpf_jit_harden

  ffffffffa034f5e9 + &lt;x&gt;:
  [...]
  <span class="hljs-number">39</span>:   mov    $<span class="hljs-number">0xa8909090</span>,%eax
  <span class="hljs-number">3</span>e:   mov    $<span class="hljs-number">0xa8909090</span>,%eax
  <span class="hljs-number">43</span>:   mov    $<span class="hljs-number">0xa8ff3148</span>,%eax
  <span class="hljs-number">48</span>:   mov    $<span class="hljs-number">0xa89081b4</span>,%eax
  <span class="hljs-number">4</span>d:   mov    $<span class="hljs-number">0xa8900bb0</span>,%eax
  <span class="hljs-number">52</span>:   mov    $<span class="hljs-number">0xa810e0c1</span>,%eax
  <span class="hljs-number">57</span>:   mov    $<span class="hljs-number">0xa8908eb4</span>,%eax
  <span class="hljs-number">5</span>c:   mov    $<span class="hljs-number">0xa89020b0</span>,%eax
  [...]</code></pre></div><p>在开启盲化后：</p><div class="hljs"><pre><code class="hljs perl"><span class="hljs-comment"># echo 1 &gt; /proc/sys/net/core/bpf_jit_harden</span>

  ffffffffa034f1e5 + &lt;<span class="hljs-keyword">x</span>&gt;:
  [...]
  <span class="hljs-number">39</span>:   mov    $0xe1192563,%r10d
  <span class="hljs-number">3</span>f:   <span class="hljs-keyword">xor</span>    $0x4989b5f3,%r10d
  <span class="hljs-number">46</span>:   mov    %r10d,%eax
  <span class="hljs-number">49</span>:   mov    $0xb8296d93,%r10d
  <span class="hljs-number">4</span>f:   <span class="hljs-keyword">xor</span>    $0x10b9fd03,%r10d
  <span class="hljs-number">56</span>:   mov    %r10d,%eax
  <span class="hljs-number">59</span>:   mov    $0x8c381146,%r10d
  <span class="hljs-number">5</span>f:   <span class="hljs-keyword">xor</span>    $0x24c7200e,%r10d
  <span class="hljs-number">66</span>:   mov    %r10d,%eax
  <span class="hljs-number">69</span>:   mov    $0xeb2a830e,%r10d
  <span class="hljs-number">6</span>f:   <span class="hljs-keyword">xor</span>    $0x43ba02ba,%r10d
  <span class="hljs-number">76</span>:   mov    %r10d,%eax
  <span class="hljs-number">79</span>:   mov    $0xd9730af,%r10d
  <span class="hljs-number">7</span>f:   <span class="hljs-keyword">xor</span>    $0xa5073b1f,%r10d
  <span class="hljs-number">86</span>:   mov    %r10d,%eax
  <span class="hljs-number">89</span>:   mov    $0x9a45662b,%r10d
  <span class="hljs-number">8</span>f:   <span class="hljs-keyword">xor</span>    $0x325586ea,%r10d
  <span class="hljs-number">96</span>:   mov    %r10d,%eax
  [...]</code></pre></div><p>两个程序是一样的，只是第二个不再有立即数的操作（注：通过寄存器操作与异或代替）。</p><p><strong>JIT kallsyms</strong>：除盲化外，开启加固后还会关闭JIT kallsyms，从而JIT image的地址不再会暴露在<code>/proc/kallsyms</code>中。</p><p><code>CONFIG_BPF_JIT_ALWAYS_ON</code>会总是开启JIT编译器，删除BPF解释器，也可用于Spectre变种2漏洞的缓解。在虚机的场景下，虚机内核不再复用主机内核的BPF解释器，以避免被攻击。在容器场景下，去除解释器可降低内核复杂度。因此这个属性通常建议开启。</p><p>最后<code>/proc/sys/kernel/unprivileged_bpf_disabled</code>可以禁止非特权用户进行<code>bpf()</code>系统调用，但此参数一旦设置，无法在更改，除非重启内核。开启后（设置为<code>1</code>），在初始命名空间外，只有<code>CAP_SYS_ADMIN</code>的特权进程才能调用。Cilium启动的时候会开启。</p><div class="hljs"><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/u</span>nprivileged_bpf_disabled</code></pre></div><h3 id="Offloads"><a href="#Offloads" class="headerlink" title="Offloads"></a>Offloads</h3><p><img src="/img/bpf_offload-2021032201.png" srcset="/img/loading.gif"><br>BPF网络程序（tc、XDP）可以将程序offload到NIC上，通过NIC直接执行BPF程序。<br>Netronome的nfp驱动支持通过JIT编译器offload，即JIT会将BPF指令编译为NIC的指令（包括BPF map映射到NIC）。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>一般发行版会自带<code>iproute2</code>，除非需要测试或使用最新版本的BPF特性，则需要进行<code>iproute2</code>和内核的编译。</p><h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><p>BPF新开发的特性在<code>net-next</code>分支，而BPF最新的修正在<code>net</code>分支。克隆<code>net-next</code>分支：</p><div class="hljs"><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/</span>netdev/net-<span class="hljs-keyword">next</span>.git</code></pre></div><p>克隆<code>net</code>分支：</p><div class="hljs"><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/</span>netdev/net.git</code></pre></div><p><code>.config</code>的配置：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CGROUP_BPF</span>=y
<span class="hljs-attr">CONFIG_BPF</span>=y
<span class="hljs-attr">CONFIG_BPF_SYSCALL</span>=y
<span class="hljs-attr">CONFIG_NET_SCH_INGRESS</span>=m
<span class="hljs-attr">CONFIG_NET_CLS_BPF</span>=m
<span class="hljs-attr">CONFIG_NET_CLS_ACT</span>=y
<span class="hljs-attr">CONFIG_BPF_JIT</span>=y
<span class="hljs-attr">CONFIG_LWTUNNEL_BPF</span>=y
<span class="hljs-attr">CONFIG_HAVE_EBPF_JIT</span>=y
<span class="hljs-attr">CONFIG_BPF_EVENTS</span>=y
<span class="hljs-attr">CONFIG_TEST_BPF</span>=m</code></pre></div><p>有些条目无法通过<code>make menuconfig</code>选择，比如<code>CONFIG_HAVE_EBPF_JIT</code>（建议开启）在带有eBPF JIT的架构体系中自动选择。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证新内核的BPF功能：</p><div class="hljs"><pre><code class="hljs awk">$ cd tools<span class="hljs-regexp">/testing/</span>selftests<span class="hljs-regexp">/bpf/</span>
$ make
$ sudo ./test_verifier
Summary: <span class="hljs-number">847</span> PASSED, <span class="hljs-number">0</span> SKIPPED, <span class="hljs-number">0</span> FAILED</code></pre></div><blockquote><p>对于4.16+以上的内核，BPF部分测试用例依赖LLVM 6.0+，提供无需inline的BPF2BPF功能，如果发行版无LLVM 6.0+，需要按照下面LLVM节中所述，编译LLVM。</p></blockquote><p>运行所有的BPF自检测试：</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo make run_tests</span></code></pre></div><h4 id="编译iproute2"><a href="#编译iproute2" class="headerlink" title="编译iproute2"></a>编译iproute2</h4><p>与<code>net</code>和<code>net-next</code>类似，iproute2也分为<code>master</code>和<code>net-next</code>，并与内核的<code>net</code>和<code>net-next</code>相互对应。克隆<code>master</code>：</p><div class="hljs"><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/i</span>proute2/iproute2.git</code></pre></div><p>克隆<code>net-next</code>：</p><div class="hljs"><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/i</span>proute2/iproute2.git</code></pre></div><p>编译与安装：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">cd</span> <span class="hljs-string">iproute2/</span>
<span class="hljs-string">$</span> <span class="hljs-string">./configure</span> <span class="hljs-string">--prefix=/usr</span>
<span class="hljs-string">TC</span> <span class="hljs-string">schedulers</span>
 <span class="hljs-string">ATM</span>    <span class="hljs-literal">no</span>

<span class="hljs-attr">libc has setns:</span> <span class="hljs-literal">yes</span>
<span class="hljs-attr">SELinux support:</span> <span class="hljs-literal">yes</span>
<span class="hljs-attr">ELF support:</span> <span class="hljs-literal">yes</span>
<span class="hljs-attr">libmnl support:</span> <span class="hljs-literal">no</span>
<span class="hljs-attr">Berkeley DB:</span> <span class="hljs-literal">no</span>

<span class="hljs-attr">docs: latex:</span> <span class="hljs-literal">no</span>
 <span class="hljs-attr">WARNING:</span> <span class="hljs-literal">no</span> <span class="hljs-string">docs</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">built</span> <span class="hljs-string">from</span> <span class="hljs-string">LaTeX</span> <span class="hljs-string">files</span>
 <span class="hljs-attr">sgml2html:</span> <span class="hljs-literal">no</span>
 <span class="hljs-attr">WARNING:</span> <span class="hljs-literal">no</span> <span class="hljs-string">HTML</span> <span class="hljs-string">docs</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">built</span> <span class="hljs-string">from</span> <span class="hljs-string">SGML</span>
<span class="hljs-string">$</span> <span class="hljs-string">make</span>
[<span class="hljs-string">...</span>]
<span class="hljs-string">$</span> <span class="hljs-string">sudo</span> <span class="hljs-string">make</span> <span class="hljs-string">install</span></code></pre></div><p>确保<code>configure</code>脚本显示<code>ELF support: yes</code>，以便iproute2可以处理LLVM后端的ELF文件。</p><h4 id="编译bpftool"><a href="#编译bpftool" class="headerlink" title="编译bpftool"></a>编译bpftool</h4><p>bpftool用于debug bpf程序与bpf map的工具，在内核的<code>tools/bpf/bpftool</code>下。</p><div class="hljs"><pre><code class="hljs routeros">$ cd &lt;kernel-tree&gt;/tools/bpf/bpftool/
$ make
Auto-detecting<span class="hljs-built_in"> system </span>features:
<span class="hljs-built_in">..</span>.                        libbfd: [ on  ]
<span class="hljs-built_in">..</span>.        disassembler-four-args: [ OFF ]

  CC       xlated_dumper.o
  CC       prog.o
  CC       common.o
  CC       cgroup.o
  CC       main.o
  CC       json_writer.o
  CC       cfg.o
  CC       map.o
  CC       jit_disasm.o
  CC       disasm.o
make[1]: Entering directory <span class="hljs-string">&#x27;/home/foo/trees/net/tools/lib/bpf&#x27;</span>

Auto-detecting<span class="hljs-built_in"> system </span>features:
<span class="hljs-built_in">..</span>.                        libelf: [ on  ]
<span class="hljs-built_in">..</span>.                           bpf: [ on  ]

  CC       libbpf.o
  CC       bpf.o
  CC       nlattr.o
  LD       libbpf-in.o
  LINK     libbpf.a
make[1]: Leaving directory <span class="hljs-string">&#x27;/home/foo/trees/bpf/tools/lib/bpf&#x27;</span>
  LINK     bpftool
$ sudo make install</code></pre></div><h3 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h3><p>LLVM是当前唯一提供BPF编译后端的套件，gcc不支持。<br>LLVM 3.7加入BPF后端，一般默认开启，因此在安装clang和LLVM后就可以将C语言编译为BPF对象文件了。<br>典型的工作流程：</p><ul><li>编写C语言文件</li><li>LLVM编译为obj文件或ELF文件</li><li>用户空间的loader工具（iproute2）通过<code>bpf()</code>系统调用加载BPF到内核</li><li>内核验证BPF程序</li><li>JIT编译为本机指令，并新建文件描述符，用于挂载到子系统中(e.g. networking)</li><li>如果支持，子系统进一步将BPF程序offload到NIC上。</li></ul><p>检测LLVM是否支持BPF（llc是LLVM编译器，输入LLVM IR，输出汇编文件或者是目标文件）：</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">$</span> <span class="hljs-string">llc --version</span>
<span class="hljs-attr">LLVM</span> <span class="hljs-string">(http://llvm.org/):</span>
<span class="hljs-attr">LLVM</span> <span class="hljs-string">version 3.8.1</span>
<span class="hljs-attr">Optimized</span> <span class="hljs-string">build.</span>
<span class="hljs-attr">Default</span> <span class="hljs-string">target: x86_64-unknown-linux-gnu</span>
<span class="hljs-attr">Host</span> <span class="hljs-string">CPU: skylake</span>

<span class="hljs-attr">Registered</span> <span class="hljs-string">Targets:</span>
  <span class="hljs-attr">[...]</span>
  <span class="hljs-attr">bpf</span>        <span class="hljs-string">- BPF (host endian)</span>
  <span class="hljs-attr">bpfeb</span>      <span class="hljs-string">- BPF (big endian)</span>
  <span class="hljs-attr">bpfel</span>      <span class="hljs-string">- BPF (little endian)</span>
  <span class="hljs-attr">[...]</span></code></pre></div><p>默认情况，<code>bpf</code>类型的target是和CPU的字节序一致的。可以通过<code>bpfeb</code>和<code>bpfel</code>进行交叉编译，在大端机器上编译小端的BPF程序，在小端机器上运行。需要注意前端clang也需要运行在相同的字节序上。</p><p>一个XDP drop程序样例（<code>xdp-example.c</code>）：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

__section(<span class="hljs-string">&quot;prog&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> XDP_DROP;
&#125;

<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre></div><p>编译并加载到内核：</p><div class="hljs"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> clang -O2 -Wall -target bpf -c xdp-example.c -o xdp-example.o
# ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp obj xdp-example.o</span></code></pre></div><blockquote><p>加载XDP程序到网络设备，需要linux 4.11版本以及对应的device支持，或是linux 4.12以上的版本。</p></blockquote><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">file</span> <span class="hljs-string">xdp-example.o</span>
<span class="hljs-attr">xdp-example.o:</span> <span class="hljs-string">ELF</span> <span class="hljs-number">64</span><span class="hljs-string">-bit</span> <span class="hljs-string">LSB</span> <span class="hljs-string">relocatable,</span> <span class="hljs-string">*unknown</span> <span class="hljs-string">arch</span> <span class="hljs-number">0xf7</span><span class="hljs-string">*</span> <span class="hljs-string">version</span> <span class="hljs-number">1</span> <span class="hljs-string">(SYSV),</span> <span class="hljs-string">not</span> <span class="hljs-string">stripped</span></code></pre></div><p><code>0xf7</code>表示官方BPF机器值<code>EM_BPF</code>，十进制<code>247</code>。<code>LSB</code>表示小端字节序。通过<code>readelf -a xdp-example.o</code>命令可以看到更多的ELF文件信息，比如section头、重定向条目、symbol表。</p><h4 id="编译安装LLVM"><a href="#编译安装LLVM" class="headerlink" title="编译安装LLVM"></a>编译安装LLVM</h4><p>少数情况下可能需要编译安装clang和LLVM：</p><div class="hljs"><pre><code class="hljs sql">$ git clone https://git.llvm.org/git/llvm.git
$ cd llvm/tools
$ git clone <span class="hljs-comment">--depth 1 https://git.llvm.org/git/clang.git</span>
$ cd ..; mkdir build; cd build
$ cmake .. -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; -DBUILD_SHARED_LIBS=OFF -DCMAKE_BUILD_TYPE=<span class="hljs-keyword">Release</span> -DLLVM_BUILD_RUNTIME=<span class="hljs-keyword">OFF</span>
$ make -j $(getconf _NPROCESSORS_ONLN)

$ ./<span class="hljs-keyword">bin</span>/llc <span class="hljs-comment">--version</span>
LLVM (<span class="hljs-keyword">http</span>://llvm.org/):
LLVM <span class="hljs-keyword">version</span> x.y.zsvn
Optimized build.
<span class="hljs-keyword">Default</span> target: x86_64-<span class="hljs-literal">unknown</span>-linux-gnu
Host CPU: skylake

Registered Targets:
  bpf    - BPF (host <span class="hljs-keyword">endian</span>)
  bpfeb  - BPF (<span class="hljs-keyword">big</span> <span class="hljs-keyword">endian</span>)
  bpfel  - BPF (<span class="hljs-keyword">little</span> <span class="hljs-keyword">endian</span>)
  x86    - <span class="hljs-number">32</span>-<span class="hljs-built_in">bit</span> X86: Pentium-Pro <span class="hljs-keyword">and</span> above
  x86<span class="hljs-number">-64</span> - <span class="hljs-number">64</span>-<span class="hljs-built_in">bit</span> X86: EM64T <span class="hljs-keyword">and</span> AMD64

$ <span class="hljs-keyword">export</span> <span class="hljs-keyword">PATH</span>=$PWD/<span class="hljs-keyword">bin</span>:$<span class="hljs-keyword">PATH</span>   <span class="hljs-comment"># add to ~/.bashrc</span></code></pre></div><p>确保<code>--version</code>中会有<code>Optimized build</code>，否则当以debug模式编译时，编译的时间会大大增加。</p><h4 id="汇编输出"><a href="#汇编输出" class="headerlink" title="汇编输出"></a>汇编输出</h4><p>为了调试，clang可以直接产生汇编输出（通过<code>-S</code>）：</p><div class="hljs"><pre><code class="hljs awk">$ clang -O2 -S -Wall -target bpf -c xdp-example.c -o xdp-example.S
$ cat xdp-example.S
    .text
    .section    prog,<span class="hljs-string">&quot;ax&quot;</span>,@progbits
    .globl      xdp_drop
    .p2align    <span class="hljs-number">3</span>
xdp_drop:                             <span class="hljs-comment"># @xdp_drop</span>
<span class="hljs-comment"># BB#0:</span>
    r0 = <span class="hljs-number">1</span>
    <span class="hljs-keyword">exit</span>

    .section    license,<span class="hljs-string">&quot;aw&quot;</span>,@progbits
    .globl    __license               <span class="hljs-comment"># @__license</span>
__license:
    .asciz    <span class="hljs-string">&quot;GPL&quot;</span></code></pre></div><p>从LLVM 6.0开始，提供了BPF汇编解释器，通过<code>llvm-mc</code>将上面的汇编输出编译为obj文件。</p><div class="hljs"><pre><code class="hljs elm"><span class="hljs-title">llvm</span>-mc -triple bpf -file<span class="hljs-keyword">type</span>=obj -o xdp-example.o xdp-example.<span class="hljs-type">S</span></code></pre></div><h4 id="输出DWARF"><a href="#输出DWARF" class="headerlink" title="输出DWARF"></a>输出DWARF</h4><p>在LLVM 4.0版本开始，可以通过<code>-g</code>将debug信息以dwarf的格式编译到obj文件中。然后使用<code>llvm-objdump</code>查看汇编以及对应的C语言的注释。其中编号<code>0</code>和<code>1</code>是与内核验证器的日志输出一致的，因此当未被内核的验证器通过时，可以通过<code>llvm-objdump</code>查看具体报错的C语言代码。</p><div class="hljs"><pre><code class="hljs awk">$ clang -O2 -g -Wall -target bpf -c xdp-example.c -o xdp-example.o
$ llvm-objdump -S -no-show-raw-insn xdp-example.o

xdp-example.o:        file format ELF64-BPF

Disassembly of section prog:
xdp_drop:
; &#123;
    <span class="hljs-number">0</span>:        r0 = <span class="hljs-number">1</span>
; return XDP_DROP;
    <span class="hljs-number">1</span>:        <span class="hljs-keyword">exit</span></code></pre></div><div class="hljs"><pre><code class="hljs routeros">\#<span class="hljs-built_in"> ip </span>link <span class="hljs-builtin-name">set</span> dev em1 xdp obj xdp-example.o verb

Prog section <span class="hljs-string">&#x27;prog&#x27;</span> loaded (5)!
 - Type:         6
 - Instructions: 2 (0 over limit)
 - License:      GPL

Verifier analysis:

0: (b7) r0 = 1
1: (95) exit
processed 2 insns</code></pre></div><p>如果不加<code>-no-show-raw-insn</code>，<code>llvm-objdump</code>还会将<code>struct bpf_insn</code>（BPF指令）以十六进制的形式显示。</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">llvm-objdump</span> <span class="hljs-string">-S</span> <span class="hljs-string">xdp-example.o</span>

<span class="hljs-attr">xdp-example.o:</span>        <span class="hljs-string">file</span> <span class="hljs-string">format</span> <span class="hljs-string">ELF64-BPF</span>

<span class="hljs-attr">Disassembly of section prog:</span>
<span class="hljs-attr">xdp_drop:</span>
<span class="hljs-string">;</span> &#123;
   <span class="hljs-attr">0:</span>       <span class="hljs-string">b7</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>     <span class="hljs-string">r0</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span>
<span class="hljs-string">;</span> <span class="hljs-string">return</span> <span class="hljs-string">foo();</span>
   <span class="hljs-attr">1:</span>       <span class="hljs-number">95</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>     <span class="hljs-string">exit</span></code></pre></div><h4 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h4><p>生成LLVM IR文件用于调试，并进一步通过LLVM IR文件生成obj文件：</p><div class="hljs"><pre><code class="hljs mipsasm">$ clang -O2 -Wall -target <span class="hljs-keyword">bpf </span>-emit-<span class="hljs-keyword">llvm </span>-c xdp-example.c -o xdp-example.<span class="hljs-keyword">bc</span>
<span class="hljs-keyword">$ </span><span class="hljs-keyword">llc </span>xdp-example.<span class="hljs-keyword">bc </span>-march=<span class="hljs-keyword">bpf </span>-filetype=obj -o xdp-example.o</code></pre></div><p>生成的LLVM IR还能转存为人类可读的格式：</p><div class="hljs"><pre><code class="hljs llvm">clang -O<span class="hljs-number">2</span> -Wall -emit-llvm -S -<span class="hljs-keyword">c</span> xdp-example.<span class="hljs-keyword">c</span> -o -</code></pre></div><h4 id="BTF"><a href="#BTF" class="headerlink" title="BTF"></a>BTF</h4><p>除了默认的debug格式DWARF外，BPF还有提供BTF（BPF Type Format）。DWARF能转换成BTF，BTF通过BPF loader工具加载到内核，验证器可以验证BTF的正确性，并追踪BTF中的结构体。<br>将BPF map中的key、value类型的注释（annotate）到BTF中，dump时会同时显示map的类型。BTF是一个通用的debug格式，任意DWARF都可以转换为BTF，比如内核的vmlinux DWARF。<br>BTF与DWARF格式的转换，由于libdw（注：“libdw1 provides a library that provides access to DWARF debug information stored inside ELF files.”）不支持BPF的重定位，因此<code>pahole</code>（注：“<strong>pahole</strong> shows data structure layouts encoded in debugging information formats, DWARF and CTF being supported.”）类似的工具无法正常使用，解决方法包括：</p><ul><li>使用elfutils(&gt;=0.173)，elfutils实现了适当的BPF重定位支持。</li><li><code>llc</code>添加<code>-mattr=dwarfris</code>参数，以关闭DWARF与ELF符号表之间的跨section重定位。<div class="hljs"><pre><code class="hljs routeros">$ llc <span class="hljs-attribute">-march</span>=bpf <span class="hljs-attribute">-mattr</span>=help |&amp; grep dwarfris
  dwarfris - <span class="hljs-builtin-name">Disable</span> MCAsmInfo DwarfUsesRelocationsAcrossSections.
  [<span class="hljs-built_in">..</span>.]</code></pre></div></li></ul><p><code>pahole</code>依赖LLVM输出的DWARF信息，后续将利用BTF信息。将DWARF转换为BTF，需要<code>pahole</code>&gt;=1.12：</p><div class="hljs"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/devel/</span>pahole/pahole.git</code></pre></div><p><code>pahole</code>通过<code>-J</code>将DWARF转换为BTF，查看<code>pahole</code>是否支持转换（<code>pahole</code>还依赖<code>llvm-objcopy</code>工具）</p><div class="hljs"><pre><code class="hljs stata">$ pahole --<span class="hljs-keyword">help</span> | grep BTF
-J, --btf_encode           <span class="hljs-keyword">Encode</span> <span class="hljs-keyword">as</span> BTF</code></pre></div><p>如上面介绍的，debug信息的生成了依赖前端<code>clang</code>的<code>-g</code>选项，比如下面使用<code>-mattr=dwarfris</code>的方式：</p><div class="hljs"><pre><code class="hljs mipsasm">$ clang -O2 -g -Wall -target <span class="hljs-keyword">bpf </span>-emit-<span class="hljs-keyword">llvm </span>-c xdp-example.c -o xdp-example.<span class="hljs-keyword">bc</span>
<span class="hljs-keyword">$ </span><span class="hljs-keyword">llc </span>xdp-example.<span class="hljs-keyword">bc </span>-march=<span class="hljs-keyword">bpf </span>-mattr=dwarfris -filetype=obj -o xdp-example.o</code></pre></div><p>或者也可以直接使用clang生成带有debug信息的obj文件。</p><div class="hljs"><pre><code class="hljs llvm">clang -<span class="hljs-keyword">target</span> bpf -O<span class="hljs-number">2</span> -g -<span class="hljs-keyword">c</span> -Xclang -<span class="hljs-keyword">target</span>-feature -Xclang +dwarfris -<span class="hljs-keyword">c</span> xdp-example.<span class="hljs-keyword">c</span> -o xdp-example.o</code></pre></div><p>使用<code>pahole</code>从DWARF信息中dump出上面BPF程序的数据结构：</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">pahole</span> <span class="hljs-string">xdp-example.o</span>
<span class="hljs-string">struct</span> <span class="hljs-string">xdp_md</span> &#123;
        <span class="hljs-string">__u32</span>                      <span class="hljs-string">data;</span>                 <span class="hljs-string">/*</span>     <span class="hljs-number">0</span>     <span class="hljs-number">4</span> <span class="hljs-string">*/</span>
        <span class="hljs-string">__u32</span>                      <span class="hljs-string">data_end;</span>             <span class="hljs-string">/*</span>     <span class="hljs-number">4</span>     <span class="hljs-number">4</span> <span class="hljs-string">*/</span>
        <span class="hljs-string">__u32</span>                      <span class="hljs-string">data_meta;</span>            <span class="hljs-string">/*</span>     <span class="hljs-number">8</span>     <span class="hljs-number">4</span> <span class="hljs-string">*/</span>

        <span class="hljs-string">/*</span> <span class="hljs-attr">size:</span> <span class="hljs-number">12</span>, <span class="hljs-attr">cachelines:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">members:</span> <span class="hljs-number">3</span> <span class="hljs-string">*/</span>
        <span class="hljs-string">/*</span> <span class="hljs-attr">last cacheline:</span> <span class="hljs-number">12</span> <span class="hljs-string">bytes</span> <span class="hljs-string">*/</span>
&#125;<span class="hljs-string">;</span></code></pre></div><p><code>pahole -J</code>可以将DWARF数据转换为BTF，但最终的obj文件里仍会同时包含DWARF与BTF两种数据。</p><div class="hljs"><pre><code class="hljs llvm">$ clang -<span class="hljs-keyword">target</span> bpf -O<span class="hljs-number">2</span> -Wall -g -<span class="hljs-keyword">c</span> -Xclang -<span class="hljs-keyword">target</span>-feature -Xclang +dwarfris -<span class="hljs-keyword">c</span> xdp-example.<span class="hljs-keyword">c</span> -o xdp-example.o
$ pahole -J xdp-example.o</code></pre></div><p>通过<code>readelf</code>工具可以看到<code>.BTF</code>section。</p><div class="hljs"><pre><code class="hljs angelscript">$ readelf -a xdp-example.o
[...]
  [<span class="hljs-number">18</span>] .BTF              PROGBITS         <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000671</span>
[...]</code></pre></div><h4 id="指令集版本"><a href="#指令集版本" class="headerlink" title="指令集版本"></a>指令集版本</h4><p>默认情况，LLVM为了兼容低版本内核 ，会使用BPF基础指令集进行编译。但是也可以通过LLVM的<code>-mcpu</code>来选择指令集的版本。<code>-mcpu</code>可用于交叉编译的场景。</p><div class="hljs"><pre><code class="hljs fortran">$ llc -march bpf -mcpu=help
Available CPUs for this <span class="hljs-keyword">target</span>:

  <span class="hljs-keyword">generic</span> - <span class="hljs-keyword">Select</span> the <span class="hljs-keyword">generic</span> processor<span class="hljs-number">.</span>
  probe   - <span class="hljs-keyword">Select</span> the probe processor<span class="hljs-number">.</span>
  v1      - <span class="hljs-keyword">Select</span> the v1 processor<span class="hljs-number">.</span>
  v2      - <span class="hljs-keyword">Select</span> the v2 processor<span class="hljs-number">.</span>
[<span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span>]</code></pre></div><p><code>generic</code>是默认的选项，是v1版本的BPF基础指令集。<code>probe</code>（cilium使用）会自动探测内核可用的BPF指令集。完整的是使用样例：</p><div class="hljs"><pre><code class="hljs mipsasm">$ clang -O2 -Wall -target <span class="hljs-keyword">bpf </span>-emit-<span class="hljs-keyword">llvm </span>-c xdp-example.c -o xdp-example.<span class="hljs-keyword">bc</span>
<span class="hljs-keyword">$ </span><span class="hljs-keyword">llc </span>xdp-example.<span class="hljs-keyword">bc </span>-march=<span class="hljs-keyword">bpf </span>-mcpu=probe -filetype=obj -o xdp-example.o</code></pre></div><h4 id="clang-target（64位-32位）"><a href="#clang-target（64位-32位）" class="headerlink" title="clang target（64位/32位）"></a>clang target（64位/32位）</h4><p>使用<code>clang -target bpf</code>和不使用<code>-target bpf</code>而使用默认的target，在不同的系统架构下有些不同的细微差别。<br>引用内核的<code>Documentation/bpf/bpf_devel_QA.txt</code>：</p><ul><li>BPF可以递归引用（include）头文件，在文件范围内内联汇编代码。 默认target可以很好的处理这种情况，但target bpf大多数情况下无法正确处理。</li><li>如果没有加<code>-g</code>参数，对于编译后是否会产生额外的elf sections，默认target可能会生成，但target bpf不会。</li><li>对于C语言中的<code>switch</code>，默认target会生成switch表和跳转操作。但switch表在全局只读section中，bpf程序是无法读取的，因此target bpf不支持这种使用switch表的优化方式。clang可以通过<code>-fno-jump-tables</code>关闭switch表的生成。</li><li>无论底层clang的版本和内核的版本（32位或64位），target bpf总是会保证指针、long 、unsigned long类型是64位的。但默认target是根据底层系统架构来的。</li></ul><p>默认target（例如x86_64的架构上选择<code>x86_64</code>的target）在追踪内核的<code>struct pt_regs</code>结构或其他与寄存器宽带有关的内核结构时有用，<code>struct pt_regs</code>结构用于映射cpu寄存器。但在其他情况下，比如网络的应用场景，建议使用<code>target bpf</code>。<br>LLVM从7.0开始也支持32位的子寄存器和BPF ALU32，需要开启<code>alu32</code>参数，开启后，LLVM会总是尝试使用32位的子寄存器以及BPF ALU32。</p><div class="hljs"><pre><code class="hljs arduino">$ cat <span class="hljs-number">32</span>-<span class="hljs-built_in">bit</span>-example.c
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *c)</span></span>
<span class="hljs-function">    </span>&#123;
      <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sum = *a + *b;
      *c = sum;
    &#125;</code></pre></div><p>默认情况下的汇编：</p><div class="hljs"><pre><code class="hljs awk">$ clang -target bpf -emit-llvm -S <span class="hljs-number">32</span>-bit-example.c
$ llc -march=bpf <span class="hljs-number">32</span>-bit-example.ll
$ cat <span class="hljs-number">32</span>-bit-example.s
    cal:
      r1 = *(u32 *)(r1 + <span class="hljs-number">0</span>)
      r2 = *(u32 *)(r2 + <span class="hljs-number">0</span>)
      r2 += r1
      *(u32 *)(r3 + <span class="hljs-number">0</span>) = r2
      <span class="hljs-keyword">exit</span></code></pre></div><p>开启<code>-mattr=+alu32</code>后：</p><div class="hljs"><pre><code class="hljs awk">$ llc -march=bpf -mattr=+alu32 <span class="hljs-number">32</span>-bit-example.ll
$ cat <span class="hljs-number">32</span>-bit-example.s
    cal:
      w1 = *(u32 *)(r1 + <span class="hljs-number">0</span>)
      w2 = *(u32 *)(r2 + <span class="hljs-number">0</span>)
      w2 += w1
      *(u32 *)(r3 + <span class="hljs-number">0</span>) = w2
      <span class="hljs-keyword">exit</span></code></pre></div><p>上面<code>w</code>表示32位的子寄存器，<code>r</code>表示64位的寄存器。<br>开启32位子寄存器可以减少类型扩展指令。对于32架构上的eBPF JIT编译器来说，会将一对寄存器作为64位的BPF寄存器使用，因此需要额外的指令去操作高位的32位寄存器。使用32位指令后，可以保证读取时，只操作低位的32位寄存器。但写时，仍需要将高位的32位寄存器清零。如果JIT编译器能知道逻辑上一个寄存器的定义就是指32位寄存器，那么高位的子寄存器操作就可以省略。</p><h4 id="C语言开发注意事项"><a href="#C语言开发注意事项" class="headerlink" title="C语言开发注意事项"></a>C语言开发注意事项</h4><p>使用C语言开发BPF与通常的C语言开发不太一样，需要注意：<br>1）<strong>在旧版本的LLVM中不只支持函数调用以及共享库，因此所有方法都需要进行内联</strong>。<br>共享库是无法与BPF一起使用的，但对于一般的库来说，可以通过先放到头文件中，然后再引用到程序中的方式进行使用。比如Cilium大量使用了此方式（<code>bpf/lib/</code>）。也可以直接引用头文件（比如内核或其他库的头文件），然后使用其中内联的方法或者是宏定义。<br>对于内核（4.16+）和LLVM（6.0+）来说，支持BPF2BPF，因此无需内联。其他情况下需要内联，在内联时推荐使用<code>always_inline</code>方式，因为对于<code>inline</code>属性，编译器仍能决定不进行内联。一旦编译器未进行内联，LLVM就会生成带有重定位项（relocation entry）的elf文件，BPF loaders（例如iproute2）只能识别处理BPF maps的重定位，因此会报错。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __inline</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __inline                         \</span>
   <span class="hljs-keyword">inline</span> __attribute__((always_inline))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-function"><span class="hljs-keyword">static</span> __inline <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> XDP_DROP;
&#125;

__section(<span class="hljs-string">&quot;prog&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> foo();
&#125;

<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre></div><p>2）<strong>不同的程序可以在一个C文件的不同section中</strong>。<br>C语言编写的BPF程序中使用大量的section注释，BPF ELF loader会根据section的名称来加载相应的BPF程序和maps。比如iproute2默认使用<code>maps</code>和<code>license</code>作为section的名称，来查询BPF maps以及BPF程序的license信息。BPF程序启用部分helper函数，需要持有GPL兼容license，例如<code>bpf_ktime_get_ns()</code>，<code>bpf_probe_read()</code>。<br>下面的tc程序用于计数ingress和egress的流量，可以加载到某个网卡上 。程序定义了<code>ingress</code>和<code>egress</code>两个section，同时通过内联方式调用<code>account_data()</code>，通过<code>maps</code> section来利用bpf maps。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/pkt_cls.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iproute2/bpf_elf.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __inline</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __inline                         \</span>
   <span class="hljs-keyword">inline</span> __attribute__((always_inline))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> lock_xadd</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> lock_xadd(ptr, val)              \</span>
   ((<span class="hljs-keyword">void</span>)__sync_fetch_and_add(ptr, val))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BPF_FUNC</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> BPF_FUNC(NAME, ...)              \</span>
   (*NAME)(__VA_ARGS__) = (<span class="hljs-keyword">void</span> *)BPF_FUNC_##NAME
#endif

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *BPF_FUNC(map_lookup_elem, <span class="hljs-keyword">void</span> *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_elf_map</span> <span class="hljs-title">acc_map</span> __<span class="hljs-title">section</span>(&quot;<span class="hljs-title">maps</span>&quot;) = &#123;</span>
    .type           = BPF_MAP_TYPE_ARRAY,
    .size_key       = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>),
    .size_value     = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>),
    .pinning        = PIN_GLOBAL_NS,
    .max_elem       = <span class="hljs-number">2</span>,
&#125;;

<span class="hljs-function"><span class="hljs-keyword">static</span> __inline <span class="hljs-keyword">int</span> <span class="hljs-title">account_data</span><span class="hljs-params">(struct __sk_buff *skb, <span class="hljs-keyword">uint32_t</span> dir)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">uint32_t</span> *bytes;

    bytes = map_lookup_elem(&amp;acc_map, &amp;dir);
    <span class="hljs-keyword">if</span> (bytes)
            lock_xadd(bytes, skb-&gt;len);

    <span class="hljs-keyword">return</span> TC_ACT_OK;
&#125;

__section(<span class="hljs-string">&quot;ingress&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tc_ingress</span><span class="hljs-params">(struct __sk_buff *skb)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> account_data(skb, <span class="hljs-number">0</span>);
&#125;

__section(<span class="hljs-string">&quot;egress&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tc_egress</span><span class="hljs-params">(struct __sk_buff *skb)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> account_data(skb, <span class="hljs-number">1</span>);
&#125;

<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre></div><ul><li>上面程序引用了一些头文件，包括内核头文件、C语言标准头文件、iproute2头文件，其中iproute2头文件中定义了<code>struct bpf_elf_map</code>，用于创建BPF map。你可以用<code>struct bpf_elf_map</code>创建多个不同名称的同类型map，但需要都在<code>__section(&quot;maps&quot;)</code>下。另外不同的BPF ELF loader中也有不同的map定义结构，比如libbpf就和iproute2的<code>struct bpf_elf_map</code>不同。</li><li><code>map_lookup_elem()</code>对应<code>BPF_FUNC_map_lookup_elem</code>的helper函数，定义在<code>uapi/linux/bpf.h</code>里。</li><li>因为定义的map是全局的，因此需要使用原子操作。在程序中使用的是<code>lock_xadd()</code>，LLVM将<code>__sync_fetch_and_add()</code>作为BPF原子加的内置函数，对应的指令为<code>BPF_STX | BPF_XADD | BPF_W</code>。</li><li><code>.pinning = PIN_GLOBAL_NS,</code>表示将map pin到BPF的文件系统中，默认情况下，路径为<code>/sys/fs/bpf/tc/globals/acc_map</code>，由于是global，表明各个obj文件都能对其进行访问。比如多个BPF程序都定义了相同（名字和属性都相同）的<code>acc_map</code> bpf map，同时都使用了 <code>PIN_GLOBAL_NS</code>，那么多个BPF程序都会共享这个map。上面的<code>ingress</code>启动后会查询是否存在<code>acc_map</code>对应的文件系统，没有则创建。在<code>egress</code>启动时，则直接使用。</li><li>除了<code>PIN_GLOBAL_NS</code>外，还有<code>PIN_OBJECT_NS</code>，将会创建object对应的目录，将map放在其下。<code>PIN_NONE</code>表示不pin到文件系统中，那么tc结束后，map将不能被从用户空间进行访问，同时程序中的ingress和egress使用的将是两个map。</li><li>可以通过bpf系统调用中的<code>BPF_OBJ_GET</code>来创建指向相同的map的文件描述符，通过这个文件描述符可以对map进行lookup/update/delete的操作。</li></ul><div class="hljs"><pre><code class="hljs routeros">$ clang -O2 -Wall -target bpf -c tc-example.c -o tc-example.o

<span class="hljs-comment"># tc qdisc add dev em1 clsact</span>
<span class="hljs-comment"># tc filter add dev em1 ingress bpf da obj tc-example.o sec ingress</span>
<span class="hljs-comment"># tc filter add dev em1 egress bpf da obj tc-example.o sec egress</span>

<span class="hljs-comment"># tc filter show dev em1 ingress</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[ingress] direct-action id 1 tag c5f7825e5dac396f

<span class="hljs-comment"># tc filter show dev em1 egress</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[egress] direct-action id 2 tag b2fd5adc0f262714

<span class="hljs-comment"># mount | grep bpf</span>
sysfs on /sys/fs/bpf<span class="hljs-built_in"> type </span>sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
bpf on /sys/fs/bpf<span class="hljs-built_in"> type </span>bpf (rw,relatime,<span class="hljs-attribute">mode</span>=0700)

<span class="hljs-comment"># tree /sys/fs/bpf/</span>
/sys/fs/bpf/
+--<span class="hljs-built_in"> ip </span>-&gt; /sys/fs/bpf/tc/
+-- tc
|   +-- globals
|       +-- acc_map
+-- xdp -&gt; /sys/fs/bpf/tc/

4 directories, 1 file</code></pre></div><p>3）<strong>不允许有全局的变量</strong><br>BPF不允许有全局的变量，但可以通过只包含一个值的<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>来替代，因为BPF能确保不会被抢占。可以用于尾调或堆栈限制的扩充。<br>一般，不同BPF程序之间共享状态使用常规BPF map即可。</p><p>4）<strong>不支持const的字符串和数组</strong><br>同样是由于loader不支持重定位导致。可通过<code>trace_printk()</code>helper函数解决 。</p><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BPF_FUNC</span>(<span class="hljs-params">trace_printk, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, <span class="hljs-keyword">int</span> fmt_size, ...</span>)</span>;

<span class="hljs-meta">#ifndef printk</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> printk(fmt, ...)                                      \</span>
    (&#123;                                                         \
        <span class="hljs-keyword">char</span> ____fmt[] = fmt;                                  \
        trace_printk(____fmt, <span class="hljs-keyword">sizeof</span>(____fmt), <span class="hljs-meta">##__VA_ARGS__); \</span>
    &#125;)
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></div><p>上面程序可以通过<code>printk(&quot;skb len:%u\n&quot;, skb-&gt;len);</code>来使用宏，使用<code>tc exec bpf dbg</code>来输出。但<code>track_printk()</code>不推荐生产环境使用：一是由于helper函数最多5个参数，因此<code>track_printk()</code>可输出的信息只能传递三个参数；二是<code>skb len:%u\n</code>这种const string在每次调用<code>track_printk()</code>时都需要重新加载到栈中。（另外<code>track_printk()</code>是全局的）<br>推荐使用<code>skb_event_output()</code>和<code>xdp_event_output()</code>，你可以自定义event结构，将其存储在perf的事件环形缓冲区中，存储过程是无需锁的，比<code>trace_printk()</code>更快。</p><p>5）<strong>使用LLVM内置的方法memset()/memcpy()/memmove()/memcmp()</strong><br>BPF除了helper函数，一般使用库中的方法需要进行内联。此外，LLVM提供了内置的总会被内联的方法：</p><div class="hljs"><pre><code class="hljs lisp">#ifndef memset
# define memset(<span class="hljs-name">dest</span>, chr, n)   __builtin_memset((<span class="hljs-name">dest</span>), (<span class="hljs-name">chr</span>), (<span class="hljs-name">n</span>))
#endif

#ifndef memcpy
# define memcpy(<span class="hljs-name">dest</span>, src, n)   __builtin_memcpy((<span class="hljs-name">dest</span>), (<span class="hljs-name">src</span>), (<span class="hljs-name">n</span>))
#endif

#ifndef memmove
# define memmove(<span class="hljs-name">dest</span>, src, n)  __builtin_memmove((<span class="hljs-name">dest</span>), (<span class="hljs-name">src</span>), (<span class="hljs-name">n</span>))
#endif</code></pre></div><p><code>memcmp()</code>在部分场景下可能不会被内联，暂时不推荐使用。</p><p>6）<strong>不支持循环</strong><br>内核中的BPF验证器会通过深度优先的方式检测所有可能的执行路径，确保没有循环，以保证程序可以终止。<br>通过<code>#pragma unroll</code>可以实现有限的循环。（<code>#pragma unroll</code>的<a target="_blank" rel="noopener" href="https://www.ibm.com/support/knowledgecenter/SSLTBW_2.4.0/com.ibm.zos.v2r4.cbclx01/opt_unroll.htm">介绍</a>)</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#pragma unroll</span>
    <span class="hljs-attr">for</span> <span class="hljs-string">(i = 0; i &lt; IPV6_MAX_HEADERS; i++) &#123;</span>
        <span class="hljs-attr">switch</span> <span class="hljs-string">(nh) &#123;</span>
        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_NONE:</span>
            <span class="hljs-attr">return</span> <span class="hljs-string">DROP_INVALID_EXTHDR;</span>
        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_FRAGMENT:</span>
            <span class="hljs-attr">return</span> <span class="hljs-string">DROP_FRAG_NOSUPPORT;</span>
        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_HOP:</span>
        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_ROUTING:</span>
        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_AUTH:</span>
        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_DEST:</span>
            <span class="hljs-attr">if</span> <span class="hljs-string">(skb_load_bytes(skb, l3_off + len, &amp;opthdr, sizeof(opthdr)) &lt; 0)</span>
                <span class="hljs-attr">return</span> <span class="hljs-string">DROP_INVALID;</span>

            <span class="hljs-attr">nh</span> = <span class="hljs-string">opthdr.nexthdr;</span>
            <span class="hljs-attr">if</span> <span class="hljs-string">(nh == NEXTHDR_AUTH)</span>
                <span class="hljs-attr">len</span> <span class="hljs-string">+= ipv6_authlen(&amp;opthdr);</span>
            <span class="hljs-attr">else</span>
                <span class="hljs-attr">len</span> <span class="hljs-string">+= ipv6_optlen(&amp;opthdr);</span>
            <span class="hljs-attr">break;</span>
        <span class="hljs-attr">default</span>:<span class="hljs-string"></span>
            <span class="hljs-meta">*nexthdr</span> = <span class="hljs-string">nh;</span>
            <span class="hljs-attr">return</span> <span class="hljs-string">len;</span>
        <span class="hljs-attr">&#125;</span>
    <span class="hljs-attr">&#125;</span></code></pre></div><p>另一种方式是通过尾调同一函数，并使用<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>来作为局部缓存。但循环上限为34（本身一次调用，加上尾调上限33）。</p><p>7）<strong>使用尾调对程序进行划分</strong><br>尾调可以实现多阶段的数据包分析，还可以实现事件通知。比如Cilium在运行时通知数据包的drop事件，通过尾调包含<code>skb_event_output()</code>方法的函数。<br>尾调程序的map（<code>BPF_MAP_TYPE_PROG_ARRAY</code>）可以定义灵活的功能，当尾调超过限制时，会进行fall-through。例如XDP或tc的程序，可以设置如下的程序map：</p><ul><li>索引0中的程序执行流量采样（traffic sampling）</li><li>然后跳到索引1执行防火墙策略，然后DROP或者是继续执行索引2</li><li>索引2执行其他的修改，然后发出数据包<div class="hljs"><pre><code class="hljs cpp">[...]

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __stringify</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __stringify(X)   #X</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section_tail</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section_tail(ID, KEY)          \</span>
   __section(__stringify(ID) <span class="hljs-string">&quot;/&quot;</span> __stringify(KEY))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BPF_FUNC</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> BPF_FUNC(NAME, ...)              \</span>
   (*NAME)(__VA_ARGS__) = (<span class="hljs-keyword">void</span> *)BPF_FUNC_##NAME
#endif

#define BPF_JMP_MAP_ID   <span class="hljs-number">1</span>

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> BPF_FUNC(tail_call, struct __sk_buff *skb, <span class="hljs-keyword">void</span> *<span class="hljs-built_in">map</span>,
                     <span class="hljs-keyword">uint32_t</span> index);

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_elf_map</span> <span class="hljs-title">jmp_map</span> __<span class="hljs-title">section</span>(&quot;<span class="hljs-title">maps</span>&quot;) = &#123;</span>
    .type           = BPF_MAP_TYPE_PROG_ARRAY,
    .id             = BPF_JMP_MAP_ID,
    .size_key       = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>),
    .size_value     = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>),
    .pinning        = PIN_GLOBAL_NS,
    .max_elem       = <span class="hljs-number">1</span>,
&#125;;

__section_tail(JMP_MAP_ID, <span class="hljs-number">0</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">looper</span><span class="hljs-params">(struct __sk_buff *skb)</span></span>
<span class="hljs-function"></span>&#123;
    printk(<span class="hljs-string">&quot;skb cb: %u\n&quot;</span>, skb-&gt;cb[<span class="hljs-number">0</span>]++);
    tail_call(skb, &amp;jmp_map, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> TC_ACT_OK;
&#125;

__section(<span class="hljs-string">&quot;prog&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">entry</span><span class="hljs-params">(struct __sk_buff *skb)</span></span>
<span class="hljs-function"></span>&#123;
    skb-&gt;cb[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    tail_call(skb, &amp;jmp_map, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> TC_ACT_OK;
&#125;

<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre></div> 上面的程序中，首先是创建了一个prog map <code>jmp_map</code>，并pin到global下的<code>jmp_map</code>中。其次，通过<code>__section_tail()</code>对looper设置id和key，设置的方式是对section进行特定的命名。可以看到<code>jmp_map</code>的ID和<code>__section_tail()</code>对<code>looper()</code>函数设定的ID一致，都是<code>JMP_MAP_ID</code>。在<code>entry()</code>中，进行尾调<code>tail_call</code>，尾调指定了key为0，正好是<code>looper()</code>的key。<div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">llvm-objdump</span> <span class="hljs-string">-S</span> <span class="hljs-string">--no-show-raw-insn</span> <span class="hljs-string">prog_array.o</span> <span class="hljs-string">|</span> <span class="hljs-string">less</span>
<span class="hljs-attr">prog_array.o:</span>   <span class="hljs-string">file</span> <span class="hljs-string">format</span> <span class="hljs-string">ELF64-BPF</span>

<span class="hljs-attr">Disassembly of section 1/0:</span>
<span class="hljs-attr">looper:</span>
       <span class="hljs-attr">0:</span>       <span class="hljs-string">r6</span> <span class="hljs-string">=</span> <span class="hljs-string">r1</span>
       <span class="hljs-attr">1:</span>       <span class="hljs-string">r2</span> <span class="hljs-string">=</span> <span class="hljs-string">*(u32</span> <span class="hljs-string">*)(r6</span> <span class="hljs-string">+</span> <span class="hljs-number">48</span><span class="hljs-string">)</span>
       <span class="hljs-attr">2:</span>       <span class="hljs-string">r1</span> <span class="hljs-string">=</span> <span class="hljs-string">r2</span>
       <span class="hljs-attr">3:</span>       <span class="hljs-string">r1</span> <span class="hljs-string">+=</span> <span class="hljs-number">1</span>
       <span class="hljs-attr">4:</span>       <span class="hljs-string">*(u32</span> <span class="hljs-string">*)(r6</span> <span class="hljs-string">+</span> <span class="hljs-number">48</span><span class="hljs-string">)</span> <span class="hljs-string">=</span> <span class="hljs-string">r1</span>
       <span class="hljs-attr">5:</span>       <span class="hljs-string">r1</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">ll</span>
       <span class="hljs-attr">7:</span>       <span class="hljs-string">call</span> <span class="hljs-number">-1</span>
       <span class="hljs-attr">8:</span>       <span class="hljs-string">r1</span> <span class="hljs-string">=</span> <span class="hljs-string">r6</span>
       <span class="hljs-attr">9:</span>       <span class="hljs-string">r2</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">ll</span>
      <span class="hljs-attr">11:</span>       <span class="hljs-string">r3</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
      <span class="hljs-attr">12:</span>       <span class="hljs-string">call</span> <span class="hljs-number">12</span>
      <span class="hljs-attr">13:</span>       <span class="hljs-string">r0</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
      <span class="hljs-attr">14:</span>       <span class="hljs-string">exit</span>
<span class="hljs-attr">Disassembly of section prog:</span>
<span class="hljs-attr">entry:</span>
       <span class="hljs-attr">0:</span>       <span class="hljs-string">r2</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
       <span class="hljs-attr">1:</span>       <span class="hljs-string">*(u32</span> <span class="hljs-string">*)(r1</span> <span class="hljs-string">+</span> <span class="hljs-number">48</span><span class="hljs-string">)</span> <span class="hljs-string">=</span> <span class="hljs-string">r2</span>
       <span class="hljs-attr">2:</span>       <span class="hljs-string">r2</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">ll</span>
       <span class="hljs-attr">4:</span>       <span class="hljs-string">r3</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
       <span class="hljs-attr">5:</span>       <span class="hljs-string">call</span> <span class="hljs-number">12</span>
       <span class="hljs-attr">6:</span>       <span class="hljs-string">r0</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>
       <span class="hljs-attr">7:</span>       <span class="hljs-string">exi</span></code></pre></div><blockquote><p>注：这里看到尾调都是<code>call 12</code>，是因为<code>BPF_FUN_tail_call</code>的ID为12。<br><code>include/uapi/linux/bpf.h</code></p><div class="hljs"><pre><code class="hljs sqf"><span class="hljs-comment">/* integer value in &#x27;imm&#x27; field of BPF_CALL instruction selects which helper</span>
<span class="hljs-comment">* function eBPF program intends to call</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __BPF_ENUM_FN(x) BPF_FUNC_ ## x</span>
enum bpf_func_id &#123;
<span class="hljs-variable">__BPF_FUNC_MAPPER</span>(<span class="hljs-variable">__BPF_ENUM_FN</span>)
<span class="hljs-variable">__BPF_FUNC_MAX_ID</span>,
&#125;;
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> __BPF_ENUM_FN</span></code></pre></div></blockquote></li></ul><p>上面的<code>section 1/0</code>表示是map id为1，key为0的函数，即<code>looper()</code>。<code>jmp_map</code>可以被用户空间的应用修改，也能被tc修改。更新是原子操作，比如：</p><div class="hljs"><pre><code class="hljs maxima"># tc exec bpf graft m:globals/jmp_map <span class="hljs-built_in">key</span> <span class="hljs-number">0</span> obj <span class="hljs-built_in">new</span>.o <span class="hljs-built_in">sec</span> foo</code></pre></div><p>上面使用了tc的<code>graft</code>命令，更新了<code>globals/jmp_map</code>key为0的方法，更新为<code>new.o</code>中的<code>section foo</code>。</p><p>8）<strong>栈空间最大限制为512bytes</strong><br>BPF程序栈空间的限制为512bytes，但是可以如上面第三条所述的，通过<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>去扩大栈的空间。</p><p>9）<strong>可以使用BPF嵌入汇编</strong><br>LLVM 6.0开始运行BPF程序使用嵌入汇编。比如下面是64位的原子加操作。相关文档在LLVM源码的<code>lib/Target/BPF/BPFInstrInfo.td</code>以及<code>test/CodeGen/BPF/</code>中。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

__section(<span class="hljs-string">&quot;prog&quot;</span>)
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_test</span><span class="hljs-params">(struct xdp_md *ctx)</span></span>
<span class="hljs-function"></span>&#123;
    __u64 a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, *c = &amp;a;
    <span class="hljs-comment">/* just a toy xadd example to show the syntax */</span>
    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lock *(u64 *)(%0+0) += %1&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(c) : <span class="hljs-string">&quot;r&quot;</span>(b), <span class="hljs-string">&quot;0&quot;</span>(c))</span></span>;
    <span class="hljs-keyword">return</span> a;
&#125;

<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre></div><p>上面的程序对应的BPF指令为：</p><div class="hljs"><pre><code class="hljs apache"><span class="hljs-attribute">Verifier</span> analysis:

<span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">2</span>
<span class="hljs-attribute">1</span>: (<span class="hljs-number">7</span>b) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = r<span class="hljs-number">1</span>
<span class="hljs-attribute">2</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">3</span>
<span class="hljs-attribute">3</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>
<span class="hljs-attribute">4</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>
<span class="hljs-attribute">5</span>: (db) lock *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">2</span> +<span class="hljs-number">0</span>) += r<span class="hljs-number">1</span>
<span class="hljs-attribute">6</span>: (<span class="hljs-number">79</span>) r<span class="hljs-number">0</span> = *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>)
<span class="hljs-attribute">7</span>: (<span class="hljs-number">95</span>) exit
<span class="hljs-attribute">processed</span> <span class="hljs-number">8</span> insns (limit <span class="hljs-number">131072</span>), stack depth <span class="hljs-number">8</span></code></pre></div><blockquote><p>注：Cilium在tail call的实现上使用的是内嵌汇编，同样<code>call 12</code>表示<code>BPF_FUN_tail_call</code>。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> __always_inline __maybe_unused <span class="hljs-keyword">void</span>
tail_call_static(<span class="hljs-keyword">const</span> struct __ctx_buff *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *<span class="hljs-built_in">map</span>,
		 <span class="hljs-keyword">const</span> __u32 slot)
&#123;
	<span class="hljs-keyword">if</span> (!__builtin_constant_p(slot))
		__throw_build_bug();

	<span class="hljs-comment">/* Don&#x27;t gamble, but _guarantee_ that LLVM won&#x27;t optimize setting</span>
<span class="hljs-comment">	 * r2 and r3 from different paths ending up at the same call insn as</span>
<span class="hljs-comment">	 * otherwise we won&#x27;t be able to use the jmpq/nopl retpoline-free</span>
<span class="hljs-comment">	 * patching by the x86-64 JIT in the kernel.</span>
<span class="hljs-comment">	 *</span>
<span class="hljs-comment"> * Note on clobber list: we need to stay in-line with BPF calling</span>
<span class="hljs-comment"> * convention, so even if we don&#x27;t end up using r0, r4, r5, we need</span>
<span class="hljs-comment"> * to mark them as clobber so that LLVM doesn&#x27;t end up using them</span>
<span class="hljs-comment"> * before / after the call.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;r1 = %[ctx]\n\t&quot;</span></span></span>
<span class="hljs-function"><span class="hljs-params">	     <span class="hljs-string">&quot;r2 = %[map]\n\t&quot;</span></span></span>
<span class="hljs-function"><span class="hljs-params">	     <span class="hljs-string">&quot;r3 = %[slot]\n\t&quot;</span></span></span>
<span class="hljs-function"><span class="hljs-params">	     <span class="hljs-string">&quot;call 12\n\t&quot;</span></span></span>
<span class="hljs-function"><span class="hljs-params">	     :: [ctx]<span class="hljs-string">&quot;r&quot;</span>(ctx), [<span class="hljs-built_in">map</span>]<span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-built_in">map</span>), [slot]<span class="hljs-string">&quot;i&quot;</span>(slot)</span></span>
<span class="hljs-function"><span class="hljs-params">	     : <span class="hljs-string">&quot;r0&quot;</span>, <span class="hljs-string">&quot;r1&quot;</span>, <span class="hljs-string">&quot;r2&quot;</span>, <span class="hljs-string">&quot;r3&quot;</span>, <span class="hljs-string">&quot;r4&quot;</span>, <span class="hljs-string">&quot;r5&quot;</span>)</span></span>;
&#125;</code></pre></div></blockquote><p>10）<strong>使用#pragma取消struct的填充</strong></p><div class="hljs"><pre><code class="hljs awk">struct called_info &#123;
    u64 start;  <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte
    u64 end;    <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte
    u32 sector; <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>-byte
&#125;; <span class="hljs-regexp">//</span> size of <span class="hljs-number">20</span>-byte ?

printf(<span class="hljs-string">&quot;size of %d-byte\n&quot;</span>, sizeof(struct called_info)); <span class="hljs-regexp">//</span> size of <span class="hljs-number">24</span>-byte

<span class="hljs-regexp">//</span> Actual compiled composition of struct called_info
<span class="hljs-regexp">//</span> <span class="hljs-number">0</span>x0(<span class="hljs-number">0</span>)                   <span class="hljs-number">0</span>x8(<span class="hljs-number">8</span>)
<span class="hljs-regexp">//</span>  ↓________________________↓
<span class="hljs-regexp">//</span>  |        start (<span class="hljs-number">8</span>)       |
<span class="hljs-regexp">//</span>  |________________________|
<span class="hljs-regexp">//</span>  |         end  (<span class="hljs-number">8</span>)       |
<span class="hljs-regexp">//</span>  |________________________|
<span class="hljs-regexp">//</span>  |  sector(<span class="hljs-number">4</span>) |  PADDING  | &lt;= address aligned to <span class="hljs-number">8</span>
<span class="hljs-regexp">//</span>  |____________|___________|     with <span class="hljs-number">4</span>-byte PADDING.</code></pre></div><p>一般为了读取效率，struct会进行对齐填充，会导致BPF验证器的<code>bpf_prog_load()</code>报错<code>invalid indirect read from stack</code>。</p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> called_info &#123;
    u64 start;
    u64 <span class="hljs-keyword">end</span>;
    u32 sector;
&#125;;

<span class="hljs-keyword">struct</span> bpf_map_def <span class="hljs-constructor">SEC(<span class="hljs-string">&quot;maps&quot;</span>)</span> called_info_map = &#123;
    .<span class="hljs-keyword">type</span> = BPF_MAP_TYPE_HASH,
    .key_size = sizeof(long),
    .value_size = sizeof(<span class="hljs-keyword">struct</span> called_info),
    .max_entries = <span class="hljs-number">4096</span>,
&#125;;

<span class="hljs-constructor">SEC(<span class="hljs-string">&quot;kprobe/submit_bio&quot;</span>)</span>
<span class="hljs-built_in">int</span> submit<span class="hljs-constructor">_bio_entry(<span class="hljs-params">struct</span> <span class="hljs-params">pt_regs</span> <span class="hljs-operator">*</span><span class="hljs-params">ctx</span>)</span>
&#123;
    <span class="hljs-built_in">char</span> fmt<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;submit_bio(bio=0x%lx) called: %llu\n&quot;</span>;
    u64 start_time = bpf<span class="hljs-constructor">_ktime_get_ns()</span>;
    long bio_ptr = <span class="hljs-constructor">PT_REGS_PARM1(<span class="hljs-params">ctx</span>)</span>;
    <span class="hljs-keyword">struct</span> called_info called_info = &#123;
            .start = start_time,
            .<span class="hljs-keyword">end</span> = <span class="hljs-number">0</span>,
            .bi_sector = <span class="hljs-number">0</span>
    &#125;;

    bpf<span class="hljs-constructor">_map_update_elem(&amp;<span class="hljs-params">called_info_map</span>, &amp;<span class="hljs-params">bio_ptr</span>, &amp;<span class="hljs-params">called_info</span>, BPF_ANY)</span>;
    bpf<span class="hljs-constructor">_trace_printk(<span class="hljs-params">fmt</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">fmt</span>)</span>, bio_ptr, start_time);
    return <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">// On bpf_load_program</span>
bpf<span class="hljs-constructor">_load_program()</span> err=<span class="hljs-number">13</span>
<span class="hljs-number">0</span>: (bf) r6 = r1
...
<span class="hljs-number">19</span>: (b7) r1 = <span class="hljs-number">0</span>
<span class="hljs-number">20</span>: (<span class="hljs-number">7</span>b) *(u64 *)(r10 -<span class="hljs-number">72</span>) = r1
<span class="hljs-number">21</span>: (<span class="hljs-number">7</span>b) *(u64 *)(r10 -<span class="hljs-number">80</span>) = r7
<span class="hljs-number">22</span>: (<span class="hljs-number">63</span>) *(u32 *)(r10 -<span class="hljs-number">64</span>) = r1
...
<span class="hljs-number">30</span>: (<span class="hljs-number">85</span>) call bpf_map_update_elem#<span class="hljs-number">2</span>
invalid indirect read from stack off -<span class="hljs-number">80</span>+<span class="hljs-number">20</span> size <span class="hljs-number">24</span></code></pre></div><p>比如上面的代码中，<code>bpf_prog_load()</code>会调用BPF验证器的<code>bpf_check()</code>，其中会调用 <code>check_func_arg() -&gt; check_stack_boundary()</code>。由于<code>called_info</code>被对齐，为24位大小，但报错中可以看到从+20处（实际上就是<code>PADDING</code>开始的地方）读取是禁止的。<br><code>check_stack_boundary()</code>内部循环遍历指针的每个<code>access_size</code>(24字节)，确保其在栈的范围内，并且已初始化。通过<code>#pragma</code>去除填充：</p><div class="hljs"><pre><code class="hljs awk"><span class="hljs-comment">#pragma pack(4)</span>
struct called_info &#123;
    u64 start;  <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte
    u64 end;    <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte
    u32 sector; <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>-byte
&#125;; <span class="hljs-regexp">//</span> size of <span class="hljs-number">20</span>-byte ?

printf(<span class="hljs-string">&quot;size of %d-byte\n&quot;</span>, sizeof(struct called_info)); <span class="hljs-regexp">//</span> size of <span class="hljs-number">20</span>-byte

<span class="hljs-regexp">//</span> Actual compiled composition of packed struct called_info
<span class="hljs-regexp">//</span> <span class="hljs-number">0</span>x0(<span class="hljs-number">0</span>)                   <span class="hljs-number">0</span>x8(<span class="hljs-number">8</span>)
<span class="hljs-regexp">//</span>  ↓________________________↓
<span class="hljs-regexp">//</span>  |        start (<span class="hljs-number">8</span>)       |
<span class="hljs-regexp">//</span>  |________________________|
<span class="hljs-regexp">//</span>  |         end  (<span class="hljs-number">8</span>)       |
<span class="hljs-regexp">//</span>  |________________________|
<span class="hljs-regexp">//</span>  |  sector(<span class="hljs-number">4</span>) |             &lt;= address aligned to <span class="hljs-number">4</span>
<span class="hljs-regexp">//</span>  |____________|                 with no PADDING.</code></pre></div><p>上面的<code>#pragma pack(4)</code>告诉编译器按照4字节进行对齐。但无PADDING会导致读取性能的下降，一般更好的解决方式是显示的填充。</p><div class="hljs"><pre><code class="hljs awk">struct called_info &#123;
    u64 start;  <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte
    u64 end;    <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte
    u32 sector; <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>-byte
    u32 pad;    <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>-byte
&#125;; <span class="hljs-regexp">//</span> size of <span class="hljs-number">24</span>-byte ?

printf(<span class="hljs-string">&quot;size of %d-byte\n&quot;</span>, sizeof(struct called_info)); <span class="hljs-regexp">//</span> size of <span class="hljs-number">24</span>-byte

<span class="hljs-regexp">//</span> Actual compiled composition of struct called_info with explicit padding
<span class="hljs-regexp">//</span> <span class="hljs-number">0</span>x0(<span class="hljs-number">0</span>)                   <span class="hljs-number">0</span>x8(<span class="hljs-number">8</span>)
<span class="hljs-regexp">//</span>  ↓________________________↓
<span class="hljs-regexp">//</span>  |        start (<span class="hljs-number">8</span>)       |
<span class="hljs-regexp">//</span>  |________________________|
<span class="hljs-regexp">//</span>  |         end  (<span class="hljs-number">8</span>)       |
<span class="hljs-regexp">//</span>  |________________________|
<span class="hljs-regexp">//</span>  |  sector(<span class="hljs-number">4</span>) |  pad (<span class="hljs-number">4</span>)  | &lt;= address aligned to <span class="hljs-number">8</span>
<span class="hljs-regexp">//</span>  |____________|___________|     with explicit PADDING.</code></pre></div><p>11）<strong>通过无效的引用访问包中的数据</strong><br>BPF helper函数中有部分（例如：<code>bpf_skb_stort_bytes</code>）可能会改动数据包的大小。由于验证器服务跟踪这种变化，因此会认定之前的包引用为无效引用，因此在包变动后，访问包前需要更新引用。例如：</p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> iphdr *ip4 = (<span class="hljs-keyword">struct</span> iphdr *) skb-&gt;data + ETH_HLEN;

skb<span class="hljs-constructor">_store_bytes(<span class="hljs-params">skb</span>, <span class="hljs-params">l3_off</span> + <span class="hljs-params">offsetof</span>(<span class="hljs-params">struct</span> <span class="hljs-params">iphdr</span>, <span class="hljs-params">saddr</span>)</span>, &amp;new_saddr, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>);

<span class="hljs-keyword">if</span> (ip4-&gt;protocol<span class="hljs-operator"> == </span>IPPROTO_TCP) &#123;
    <span class="hljs-comment">// do something</span>
&#125;</code></pre></div><p>由于<code>skb_store_bytes</code>后<code>skb</code>发生变化，因此验证器会认定<code>ip4</code>无效。</p><div class="hljs"><pre><code class="hljs angelscript">R1=pkt_end(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">0</span>,imm=<span class="hljs-number">0</span>) R2=pkt(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">34</span>,r=<span class="hljs-number">34</span>,imm=<span class="hljs-number">0</span>) R3=inv0
R6=ctx(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">0</span>,imm=<span class="hljs-number">0</span>) R7=inv(id=<span class="hljs-number">0</span>,umax_value=<span class="hljs-number">4294967295</span>,var_off=(<span class="hljs-number">0x0</span>; <span class="hljs-number">0xffffffff</span>))
R8=inv4294967162 R9=pkt(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">0</span>,r=<span class="hljs-number">34</span>,imm=<span class="hljs-number">0</span>) R10=fp0,call_<span class="hljs-number">-1</span>
...
<span class="hljs-number">18</span>: (<span class="hljs-number">85</span>) call bpf_skb_store_bytes#<span class="hljs-number">9</span>
<span class="hljs-number">19</span>: (<span class="hljs-number">7</span>b) *(u64 *)(r10 <span class="hljs-number">-56</span>) = r7
R0=inv(id=<span class="hljs-number">0</span>) R6=ctx(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">0</span>,imm=<span class="hljs-number">0</span>) R7=inv(id=<span class="hljs-number">0</span>,umax_value=<span class="hljs-number">2</span>,var_off=(<span class="hljs-number">0x0</span>; <span class="hljs-number">0x3</span>))
R8=inv4294967162 R9=inv(id=<span class="hljs-number">0</span>) R10=fp0,call_<span class="hljs-number">-1</span> fp<span class="hljs-number">-48</span>=mmmm???? fp<span class="hljs-number">-56</span>=mmmmmmmm
<span class="hljs-number">21</span>: (<span class="hljs-number">61</span>) r1 = *(u32 *)(r9 +<span class="hljs-number">23</span>)
R9 invalid mem access <span class="hljs-string">&#x27;inv&#x27;</span></code></pre></div><p>修复此问题需要在重新更新<code>ip4</code>：</p><div class="hljs"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span></span> *ip4 = (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span></span> *) skb-&gt;data + ETH_HLEN;

skb_store_bytes(skb, l3_off + offsetof(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span></span>, saddr), &amp;new_saddr, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>);

ip4 = (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span></span> *) skb-&gt;data + ETH_HLEN;

<span class="hljs-keyword">if</span> (ip4-&gt;protocol == IPPROTO_TCP) &#123;
    <span class="hljs-comment">// do something</span>
&#125;</code></pre></div><h3 id="iproute2"><a href="#iproute2" class="headerlink" title="iproute2"></a>iproute2</h3><p>BPF loader有多种工具，例如bbc、perf、iproute2等。perf主要使用内核中的<code>tools/lib/bpf/</code>库。bbc主要用于track，使用的是嵌有C的python编写BPF，编写逻辑和一般的BPF有细小区别（有专门函数，类似于BPF help函数）。另外还有如内核<code>samples/bpf</code>下的程序，编译为obj文件后，通过系统调用来加载。<br>本章主要介绍iproute2对tc、XDP、lwt类型的BPF程序的加载。因为Cilium使用的是iproute2，Cilium后面可能会实现自己原生的loader，但仍会兼容iproute2。支持iproute2的BPF程序都有相同的loader逻辑。</p><p>1）<strong>加载XDP BPF</strong><br>下面命令加载<code>prog.o</code>的BPF到<code>em1</code>设备上：</p><div class="hljs"><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp obj prog.o</span></code></pre></div><p>上面命令未指定section，默认使用<code>prog</code> section。也可以指定section，比如指定加载<code>foobar</code> section。</p><div class="hljs"><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp obj prog.o sec foobar</span></code></pre></div><p>也可以从<code>.text</code> section中加载程序，例如下面为指定<code>__section()</code>。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>
   __attribute__((section(NAME), used))
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> XDP_DROP;
&#125;

<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre></div><p>可以通过如下方式加载：</p><div class="hljs"><pre><code class="hljs css"># <span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">link</span> <span class="hljs-selector-tag">set</span> <span class="hljs-selector-tag">dev</span> <span class="hljs-selector-tag">em1</span> <span class="hljs-selector-tag">xdp</span> <span class="hljs-selector-tag">obj</span> <span class="hljs-selector-tag">prog</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">sec</span> <span class="hljs-selector-class">.text</span></code></pre></div><p>默认情况下，通过<code>ip</code>加载XDP到某个已加载XDP程序的设备上时，会报错。需要使用<code>-force</code>选项进行替换。</p><div class="hljs"><pre><code class="hljs gams"># ip -force link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp obj prog.o</span></code></pre></div><p>大多数支持XDP的驱动在替换XDP时都是原子操作，不会中断流量。一个设备只会加载一个XDP，但你可以通过尾调或是BPF2BPF来实现复杂的逻辑。<br>通过<code>ip link | grep xdp</code>可以看到设备上是否有XDP程序，通过<code>ip -d link</code>以及<code>bpftool</code>可以获取更多的信息。<br>关闭XDP程序：</p><div class="hljs"><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp off</span></code></pre></div><p>在non-XDP与native XDP切换过程中，设备会重新配置接收rings，确保接收的包线性的存储在单个页面，以供BPF程序读写。一旦配置完后，后续XDP程序的替换就是原子操作。<br>在iproute2中支持的XDP模式为<code>xdpdrv</code>、<code>xdpoffload</code>、<code>xdpgeneric</code>。<br><code>xdpdrv</code>需要驱动支持，其处理点在驱动的接收路径上，是软件层面能达到的最早处理点。</p><blockquote><p> 通过<code>lspci -vvv</code>可以查看网卡的驱动。比如我的驱动是<code>e1000e</code><br></p><div class="hljs"><pre><code class="hljs routeros"> 00:1f.6<span class="hljs-built_in"> Ethernet </span>controller: Intel Corporation<span class="hljs-built_in"> Ethernet Connection </span>(7) I219-LM (rev 10)
 <span class="hljs-built_in">..</span>.
Kernel driver <span class="hljs-keyword">in</span> use: e1000e
Kernel modules: e1000e</code></pre></div><br>在<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</a> 中可以看到<code>e1000e</code>目前不支持XDP。<p></p></blockquote><p><code>xdpgeneric</code>是针对不支持XDP的驱动的一种实验性模式。<code>xdpgeneric</code>的hook点在包作为<code>skb</code>进入协议栈后，因此性能不如<code>xdpdrv</code>。一般<code>xdpgeneric</code>只作为实验场景，不作为生产场景。<br><code>xdpoffload</code>需要驱动支持<code>SmartNICs</code>，例如<code>Netronome</code>的nfp驱动。这种模式会将BPF程序加载到硬件上，由硬件处理数据包，并且<code>xdpoffload</code>中，并非所有的BPF map和BPF helper函数都是支持的，如果使用了不支持的BPF功能，BPF验证器会拒绝并指出。<br>在通过<code>ip link set dev em1 xdp obj [...]</code>命令进行XDP加载时，会先尝试<code>xdpdrv</code>模式，如果驱动不支持，则使用<code>xdpgeneric</code>模式。显示的使用<code>xdpdrv</code>代替<code>xdp</code>，会在驱动不支持时，直接报错，而避免使用<code>xdpgeneric</code>模式。<br>下面的例子中，强制以<code>xdpdrv</code>加载XDP程序，查看详情，卸载。</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># ip -force link set dev em1 xdpdrv obj prog.o</span>
<span class="hljs-comment"># ip link show</span>
[<span class="hljs-built_in">..</span>.]
6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc mq state UP mode DORMANT<span class="hljs-built_in"> group default </span>qlen 1000
    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff
    prog/xdp id 1 tag 57cd311f2e27366b
[<span class="hljs-built_in">..</span>.]
<span class="hljs-comment"># ip link set dev em1 xdpdrv off</span></code></pre></div><p>下面的例子中，强制以<code>xdpgeneric</code>加载XDP，查看详情，获取汇编指令，卸载。</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># ip -force link set dev em1 xdpgeneric obj prog.o</span>
<span class="hljs-comment"># ip link show</span>
[<span class="hljs-built_in">..</span>.]
6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpgeneric qdisc mq state UP mode DORMANT<span class="hljs-built_in"> group default </span>qlen 1000
    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff
    prog/xdp id 4 tag 57cd311f2e27366b                &lt;-- BPF program ID 4
[<span class="hljs-built_in">..</span>.]
<span class="hljs-comment"># bpftool prog dump xlated id 4                       &lt;-- Dump of instructions running on em1</span>
0: (b7) r0 = 1
1: (95) exit
<span class="hljs-comment"># ip link set dev em1 xdpgeneric off</span></code></pre></div><div class="hljs"><pre><code class="hljs angelscript"># ip -force link <span class="hljs-keyword">set</span> dev em1 xdpoffload obj prog.o
# ip link show
[...]
<span class="hljs-number">6</span>: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="hljs-number">1500</span> xdpoffload qdisc mq state UP mode DORMANT group <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>
    link/ether be:<span class="hljs-number">08</span>:<span class="hljs-number">4</span>d:b6:<span class="hljs-number">85</span>:<span class="hljs-number">65</span> brd ff:ff:ff:ff:ff:ff
    prog/xdp id <span class="hljs-number">8</span> tag <span class="hljs-number">57</span>cd311f2e27366b
[...]
# bpftool prog show id <span class="hljs-number">8</span>
<span class="hljs-number">8</span>: xdp  tag <span class="hljs-number">57</span>cd311f2e27366b dev em1                  &lt;-- Also indicates a BPF program offloaded to em1
    loaded_at Apr <span class="hljs-number">11</span>/<span class="hljs-number">20</span>:<span class="hljs-number">38</span>  uid <span class="hljs-number">0</span>
    xlated <span class="hljs-number">16</span>B  <span class="hljs-keyword">not</span> jited  memlock <span class="hljs-number">4096</span>B
# ip link <span class="hljs-keyword">set</span> dev em1 xdpoffload off</code></pre></div><p>不同模式之间是不允许直接进行切换的，需要关闭之前的模式。</p><div class="hljs"><pre><code class="hljs sas"># ip -force <span class="hljs-meta">link</span> <span class="hljs-meta">set</span> dev em1 xdpgeneric obj prog.o
# ip -force <span class="hljs-meta">link</span> <span class="hljs-meta">set</span> dev em1 xdpoffload obj prog.o
RTNETLINK answers: <span class="hljs-meta">File</span> exists
# ip -force <span class="hljs-meta">link</span> <span class="hljs-meta">set</span> dev em1 xdpdrv obj prog.o
RTNETLINK answers: <span class="hljs-meta">File</span> exists
# ip -force <span class="hljs-meta">link</span> <span class="hljs-meta">set</span> dev em1 xdpgeneric obj prog.o    &lt;-- Succeeds due to xdpgeneric
#</code></pre></div><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># ip -force link set dev em1 xdpgeneric obj prog.o</span>
<span class="hljs-comment"># ip -force link set dev em1 xdpgeneric off</span>
<span class="hljs-comment"># ip -force link set dev em1 xdpoffload obj prog.o</span>
<span class="hljs-comment"># ip l</span>
[<span class="hljs-built_in">..</span>.]
6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc mq state UP mode DORMANT<span class="hljs-built_in"> group default </span>qlen 1000
    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff
    prog/xdp id 17 tag 57cd311f2e27366b
[<span class="hljs-built_in">..</span>.]
<span class="hljs-comment"># ip -force link set dev em1 xdpoffload off</span></code></pre></div><p>2）<strong>加载tc BPF obj文件</strong><br>tc BPF程序的加载不依赖驱动的支持：</p><div class="hljs"><pre><code class="hljs vim"># <span class="hljs-keyword">tc</span> qdisc <span class="hljs-built_in">add</span> dev em1 clsact
# <span class="hljs-keyword">tc</span> <span class="hljs-built_in">filter</span> <span class="hljs-built_in">add</span> dev em1 ingress bpf da obj prog.<span class="hljs-keyword">o</span></code></pre></div><p><code>clsact</code>不进行排队，只保存分类或操作，<code>clsact</code>提供<code>ingress</code>和<code>egress</code>两个hooks。<code>ingress</code> hook在<code>__netif_receive_skb_core() -&gt; sch_handle_ingress()</code>中调用，<code>egress</code> hook在<code>__dev_queue_xmit() -&gt; sch_handle_egress()</code>中调用。添加<code>egress</code>：</p><div class="hljs"><pre><code class="hljs vim"># <span class="hljs-keyword">tc</span> <span class="hljs-built_in">filter</span> <span class="hljs-built_in">add</span> dev em1 egress bpf da obj prog.<span class="hljs-keyword">o</span></code></pre></div><p><code>clsact</code>还可以挂载在虚拟的、无队列的设备上，例如容器的<code>veth</code>设备。<br><code>tc filter</code>使用<code>da</code>（direct-action）模式加载BPF tc程序，因为BPF程序会处理数据包的转发或其他操作，不需要tc action模块。<br>section的指定类似于XDP：</p><div class="hljs"><pre><code class="hljs vim"># <span class="hljs-keyword">tc</span> <span class="hljs-built_in">filter</span> <span class="hljs-built_in">add</span> dev em1 egress bpf da obj prog.<span class="hljs-keyword">o</span> sec foobar</code></pre></div><p>列出加载的tc程序：</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># tc filter show dev em1 ingress</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 prog.o:[ingress] direct-action id 1 tag c5f7825e5dac396f

<span class="hljs-comment"># tc filter show dev em1 egress</span>
filter protocol all pref 49152 bpf
filter protocol all pref 49152 bpf handle 0x1 prog.o:[egress] direct-action id 2 tag b2fd5adc0f262714</code></pre></div><p><code>prog.o:[ingress] direct-action</code>表示程序加载的是ingress section，使用da模式。后面的<code>id</code>是tc程序的唯一标识符，可以与<code>bpftool</code>一起使用来dump tc程序信息。<code>tag</code>是tc程序指令编码的hash，可以与<code>perf</code>的输出或obj文件进行对应。<br>虽然可以通过链式加载多个tc程序，但是一般使用一个BPF即可，因为da模式下，BPF程序本身就能返回tc active，比如<code>TC_ACT_OK</code>、<code>TC_ACT_SHOT</code>等。<br>上面的<code>perf 49152</code>与<code>handle 0x1</code>如果没显示的指定，就是自动生成的。<code>perf</code>表示优先级的编号，如果附加了多个分类器，则按照升序来依次执行，<code>hanler</code>用于表示在同一<code>perf</code>下的某个分类器的多个实例。这两个值仅建议在计划自动替换BPF程序的时候指定，例如：</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar</span>

<span class="hljs-comment"># tc filter show dev em1 ingress</span>
filter protocol all pref 1 bpf
filter protocol all pref 1 bpf handle 0x1 prog.o:[foobar] direct-action id 1 tag c5f7825e5dac396f</code></pre></div><p>原子的替换之前的tc：</p><div class="hljs"><pre><code class="hljs angelscript"># tc filter replace dev em1 ingress pref <span class="hljs-number">1</span> handle <span class="hljs-number">1</span> bpf da obj prog.o sec foobar</code></pre></div><p>删除所有的tc程序：</p><div class="hljs"><pre><code class="hljs vala"><span class="hljs-meta"># tc filter del dev em1 ingress</span>
<span class="hljs-meta"># tc filter del dev em1 egress</span></code></pre></div><p>也可以通过删除<code>clsact</code> qdisc，一次性删除所有的tc：</p><div class="hljs"><pre><code class="hljs vala"><span class="hljs-meta"># tc qdisc del dev em1 clsact</span></code></pre></div><p>如果网卡支持，tc也可以像XDP一样进行offload：</p><div class="hljs"><pre><code class="hljs subunit"># tc qdisc add dev em1 clsact
# tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o
<span class="hljs-keyword">Error: </span>TC offload is disabled on net device.
We have an error talking to the kernel</code></pre></div><p>上面的报错表示需要开启设备的offload：</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># ethtool -K em1 hw-tc-offload on</span>
<span class="hljs-comment"># tc qdisc add dev em1 clsact</span>
<span class="hljs-comment"># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o</span>
<span class="hljs-comment"># tc filter show dev em1 ingress</span>
filter protocol all pref 1 bpf
filter protocol all pref 1 bpf handle 0x1 prog.o:[classifier] direct-action skip_sw in_hw id 19 tag 57cd311f2e27366b</code></pre></div><p><code>in_hw</code>表示tc程序已经offload到NIC上。另外，XDP与tc不能同时使用offload。</p><p>3）<strong>通过netdevsim测试BPF offload</strong><br>netdevsim作为内核一部分实现了XDP与tc的offload接口，可以用于测试。<br>创建一个netdevsim设备：</p><div class="hljs"><pre><code class="hljs pf"><span class="hljs-comment"># modprobe netdevsim</span>
// [ID] [PORT_COUNT]
<span class="hljs-comment"># echo &quot;1 1&quot; &gt; /sys/bus/netdevsim/new_device</span>
<span class="hljs-comment"># devlink dev</span>
netdevsim/netdevsim1
<span class="hljs-comment"># devlink port</span>
netdevsim/netdevsim1/<span class="hljs-number">0</span>: type eth netdev eth0 flavour physical
<span class="hljs-comment"># ip l</span>
[...]
<span class="hljs-number">4</span>: eth0: <span class="hljs-variable">&lt;BROADCAST,NOARP,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN mode DEFAULT <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>
    link/ether <span class="hljs-number">2</span>a:d5:cd:<span class="hljs-number">08</span>:d1:<span class="hljs-number">3</span>f brd ff:ff:ff:ff:ff:ff</code></pre></div><p>然后可以将XDP或tc offload到此设备上：</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># ip -force link set dev eth0 xdpoffload obj prog.o</span>
<span class="hljs-comment"># ip l</span>
[<span class="hljs-built_in">..</span>.]
4: eth0: &lt;BROADCAST,NOARP,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc noqueue state UNKNOWN mode<span class="hljs-built_in"> DEFAULT group default </span>qlen 1000
    link/ether 2a:d5:cd:08:d1:3f brd ff:ff:ff:ff:ff:ff
    prog/xdp id 16 tag a04f5eef06a7f555</code></pre></div><p>BPF的loader操作除了上面的命令外，还有一些高级选项，下面以XDP进行介绍，tc同样可用。<br>1）<strong>输出日志</strong><br>通过<code>verb</code>选项，可以输出验证器验证成功的日志或是验证失败的日志。</p><div class="hljs"><pre><code class="hljs awk"><span class="hljs-comment"># ip link set dev em1 xdp obj xdp-example.o verb</span>

Prog section <span class="hljs-string">&#x27;prog&#x27;</span> loaded (<span class="hljs-number">5</span>)!
 - Type:         <span class="hljs-number">6</span>
 - Instructions: <span class="hljs-number">2</span> (<span class="hljs-number">0</span> over limit)
 - License:      GPL

Verifier analysis:

<span class="hljs-number">0</span>: (b7) r0 = <span class="hljs-number">1</span>
<span class="hljs-number">1</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span>
processed <span class="hljs-number">2</span> insns</code></pre></div><p>2）<strong>加载BPF文件系统上的程序</strong><br>上面加载都是使用的obj文件，可通过如下命令加载BPF文件系统上的程序：</p><div class="hljs"><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp pinned</span> /sys/<span class="hljs-comment">fs</span>/bpf/<span class="hljs-comment">prog</span></code></pre></div><p>也可以使用简写：</p><div class="hljs"><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp pinned m:prog</span></code></pre></div><p>当加载BPF程序时，iproute2会自动检测是否有BPF文件系统的实例（为了pinning BPF program或是BPF map），一旦未找BPF文件系统，就是自动在<code>/sys/fs/bpf</code>下mount一个。如果找到，则不会在进行mount，例如：</p><div class="hljs"><pre><code class="hljs gradle"># mkdir <span class="hljs-regexp">/var/</span>run/bpf
# mount --bind <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/bpf /</span>var<span class="hljs-regexp">/run/</span>bpf
# mount -t bpf bpf <span class="hljs-regexp">/var/</span>run/bpf
# tc filter add dev em1 ingress bpf da obj tc-example.o sec prog
# tree <span class="hljs-regexp">/var/</span>run/bpf
<span class="hljs-regexp">/var/</span>run/bpf
+-- ip -&gt; <span class="hljs-regexp">/run/</span>bpf<span class="hljs-regexp">/tc/</span>
+-- tc
|   +-- globals
|       +-- jmp_map
+-- xdp -&gt; <span class="hljs-regexp">/run/</span>bpf<span class="hljs-regexp">/tc/</span>

<span class="hljs-number">4</span> directories, <span class="hljs-number">1</span> <span class="hljs-keyword">file</span></code></pre></div><p>默认情况下，load tc程序将创建如上所示的初始化目录，各个子系统（XDP等）的目录通过链接的方式指向相同的globals空间，以便于BPF map在不同类型的BPF程序之间共享。但如果文件系统目录已经被创建，则loader不会重新修改已有的目录结构，这样可以分离<code>lwt</code>、<code>tc</code>和<code>XDP</code>的BPF map。<br>iproute2在安装时会安装头文件，可以在BPF程序中引用：</p><div class="hljs"><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iproute2/bpf_elf.h&gt;</span></span></code></pre></div><p>头文件提供了map的API以及BPF程序默认的section，iproute2中通过<code>struct bpf_elf_map</code>定义map。iproute2解析BPF obj文件的过程：</p><ul><li>遍历所有section，获取<code>map</code>与<code>license</code>。</li><li>验证<code>map</code>，并创建map对象。如果BPF文件系统中已存在pinned map，则使用，否则，创建新的map，并pin到BPF文件系统中。</li><li>处理包含ELF重定向（这里的重定向只包含map操作的）的section，将map的文件描述符编码为立即数。</li><li>通过系统调用创建BPF程序，如果提供了尾调的program map，更新其中程序的文件描述符。</li></ul><h3 id="bpftool"><a href="#bpftool" class="headerlink" title="bpftool"></a>bpftool</h3><p>bpftool是在内核<code>tools/bpf/bpftool/</code>下提供的debug工具。作用：</p><ul><li>dump已加载的BPF程序或map的信息，dump BPF程序使用的map信息。</li><li>dump BPF map的键值对，查询、删除、修改某个键值对，查询某个key的下一个key。</li><li>可以通过BPF程序或map的ID进行操作，也可以指定pin到的文件系统路径来操作。</li><li>pin BPF程序或map到某个文件系统上。</li></ul><h4 id="查询概况"><a href="#查询概况" class="headerlink" title="查询概况"></a>查询概况</h4><p>查看当前机器上所有的BPF程序概况：</p><div class="hljs"><pre><code class="hljs"><span class="hljs-comment"># bpftool prog</span>
<span class="hljs-attribute">398</span>: sched_cls  tag <span class="hljs-number">56207908</span>be<span class="hljs-number">8</span>ad<span class="hljs-number">877</span>
   <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>
   <span class="hljs-attribute">xlated</span> <span class="hljs-number">8800</span>B  jited <span class="hljs-number">6184</span>B  memlock <span class="hljs-number">12288</span>B  map_ids <span class="hljs-number">18</span>,<span class="hljs-number">5</span>,<span class="hljs-number">17</span>,<span class="hljs-number">14</span>
<span class="hljs-attribute">399</span>: sched_cls  tag abc<span class="hljs-number">95</span>fb<span class="hljs-number">4835</span>a<span class="hljs-number">6</span>ec<span class="hljs-number">9</span>
   <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>
   <span class="hljs-attribute">xlated</span> <span class="hljs-number">344</span>B  jited <span class="hljs-number">223</span>B  memlock <span class="hljs-number">4096</span>B  map_ids <span class="hljs-number">18</span>
<span class="hljs-attribute">400</span>: sched_cls  tag afd<span class="hljs-number">2</span>e<span class="hljs-number">542</span>b<span class="hljs-number">30</span>ff<span class="hljs-number">3</span>ec
   <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>
   <span class="hljs-attribute">xlated</span> <span class="hljs-number">1720</span>B  jited <span class="hljs-number">1001</span>B  memlock <span class="hljs-number">4096</span>B  map_ids <span class="hljs-number">17</span>
<span class="hljs-attribute">401</span>: sched_cls  tag <span class="hljs-number">2</span>dbbd<span class="hljs-number">74</span>ee<span class="hljs-number">5</span>d<span class="hljs-number">51</span>cc<span class="hljs-number">8</span>
   <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>
   <span class="hljs-attribute">xlated</span> <span class="hljs-number">3728</span>B  jited <span class="hljs-number">2099</span>B  memlock <span class="hljs-number">4096</span>B  map_ids <span class="hljs-number">17</span>
[...]</code></pre></div><p>查询map概况：</p><div class="hljs"><pre><code class="hljs"><span class="hljs-comment"># bpftool map</span>
<span class="hljs-attribute">5</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>
    <span class="hljs-attribute">key</span> <span class="hljs-number">20</span>B  value <span class="hljs-number">112</span>B  max_entries <span class="hljs-number">65535</span>  memlock <span class="hljs-number">13111296</span>B
<span class="hljs-attribute">6</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>
    <span class="hljs-attribute">key</span> <span class="hljs-number">20</span>B  value <span class="hljs-number">20</span>B  max_entries <span class="hljs-number">65536</span>  memlock <span class="hljs-number">7344128</span>B
<span class="hljs-attribute">7</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>
    <span class="hljs-attribute">key</span> <span class="hljs-number">10</span>B  value <span class="hljs-number">16</span>B  max_entries <span class="hljs-number">8192</span>  memlock <span class="hljs-number">790528</span>B
<span class="hljs-attribute">8</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>
    <span class="hljs-attribute">key</span> <span class="hljs-number">22</span>B  value <span class="hljs-number">28</span>B  max_entries <span class="hljs-number">8192</span>  memlock <span class="hljs-number">987136</span>B
<span class="hljs-attribute">9</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>
    <span class="hljs-attribute">key</span> <span class="hljs-number">20</span>B  value <span class="hljs-number">8</span>B  max_entries <span class="hljs-number">512000</span>  memlock <span class="hljs-number">49352704</span>B
[...]</code></pre></div><p>可以添加参数<code>--json</code>来输出json格式，参数<code>--pretty</code>来翻译为可读的信息。</p><div class="hljs"><pre><code class="hljs ada"># bpftool prog <span class="hljs-comment">--json --pretty</span></code></pre></div><h4 id="dump-BPF程序"><a href="#dump-BPF程序" class="headerlink" title="dump BPF程序"></a>dump BPF程序</h4><p>dump已经验证的BPF程序的image，先通过tc获取信息：</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># tc filter show dev cilium_host egress</span>
filter protocol all pref 1 bpf chain 0
filter protocol all pref 1 bpf chain 0 handle 0x1 bpf_host.o:[from-netdev] \
                    direct-action not_in_hw id 406 tag e0362f5bd9163a0a jited</code></pre></div><p>可以看出，BPF程序来着<code>bpf_host.o</code>文件，section为<code>from-netdev</code>，ID为<code>406</code>。使用bpftool获取更多元信息：</p><div class="hljs"><pre><code class="hljs apache"><span class="hljs-comment"># bpftool prog show id 406</span>
<span class="hljs-attribute">406</span>: sched_cls  tag e<span class="hljs-number">0362</span>f<span class="hljs-number">5</span>bd<span class="hljs-number">9163</span>a<span class="hljs-number">0</span>a
     <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>
     <span class="hljs-attribute">xlated</span> <span class="hljs-number">11144</span>B  jited <span class="hljs-number">7721</span>B  memlock <span class="hljs-number">12288</span>B  map_ids <span class="hljs-number">18</span>,<span class="hljs-number">20</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span></code></pre></div><p>可以看到BPF程序类型为<code>sched_cls</code>（<code>BPF_PROG_TYPE_SCHED_CLS</code>），器tag为<code>e0362f5bd9163a0a</code>，由uid 0(<code>root</code>)在<code>Apr 09/16:24</code>加载，BPF指令大小为<code>11144B</code>，JIT编译后的image为<code>7721B</code>，程序本身（不包括map）占用了<code>12288B</code>的内存空间，在map方面，使用了id为<code>18,20,8,5,6,14</code>的这几个BPF map。<br>dump BPF程序的指令（输出对BPF map和BPF helper做了专门的注释）：</p><div class="hljs"><pre><code class="hljs"><span class="hljs-comment"># bpftool prog dump xlated id 406</span>
 <span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">7</span> = <span class="hljs-number">0</span>
 <span class="hljs-attribute">1</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">60</span>) = r<span class="hljs-number">7</span>
 <span class="hljs-attribute">2</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">56</span>) = r<span class="hljs-number">7</span>
 <span class="hljs-attribute">3</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">52</span>) = r<span class="hljs-number">7</span>
[...]
<span class="hljs-attribute">47</span>: (bf) r<span class="hljs-number">4</span> = r<span class="hljs-number">10</span>
<span class="hljs-attribute">48</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">4</span> += -<span class="hljs-number">40</span>
<span class="hljs-attribute">49</span>: (<span class="hljs-number">79</span>) r<span class="hljs-number">6</span> = *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">104</span>)
<span class="hljs-attribute">50</span>: (bf) r<span class="hljs-number">1</span> = r<span class="hljs-number">6</span>
<span class="hljs-attribute">51</span>: (<span class="hljs-number">18</span>) r<span class="hljs-number">2</span> = map[id:<span class="hljs-number">18</span>]                    &lt;-- BPF map id <span class="hljs-number">18</span>
<span class="hljs-attribute">53</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">5</span> = <span class="hljs-number">32</span>
<span class="hljs-attribute">54</span>: (<span class="hljs-number">85</span>) call bpf_skb_event_output#<span class="hljs-number">5656112</span>  &lt;-- BPF helper call
<span class="hljs-attribute">55</span>: (<span class="hljs-number">69</span>) r<span class="hljs-number">1</span> = *(u<span class="hljs-number">16</span> *)(r<span class="hljs-number">6</span> +<span class="hljs-number">192</span>)
[...]</code></pre></div><p>交叉输出指令对应的opcodes的编码：</p><div class="hljs"><pre><code class="hljs angelscript"># bpftool prog dump xlated id <span class="hljs-number">406</span> opcodes
 <span class="hljs-number">0</span>: (b7) r7 = <span class="hljs-number">0</span>
    b7 <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
 <span class="hljs-number">1</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">60</span>) = r7
    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">3</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
 <span class="hljs-number">2</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">56</span>) = r7
    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">38</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
 <span class="hljs-number">3</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">52</span>) = r7
    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">34</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
 <span class="hljs-number">4</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">48</span>) = r7
    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">30</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
 <span class="hljs-number">5</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">64</span>) = r7
    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
 [...]</code></pre></div><p>dump JIT编译过的image汇编信息：</p><div class="hljs"><pre><code class="hljs gcode"><span class="hljs-attr"># bpftool prog dump jited id 406</span>
 <span class="hljs-number">0</span>:        push   <span class="hljs-meta">%</span>rbp
 <span class="hljs-number">1</span>:        mov    <span class="hljs-meta">%</span>rsp,<span class="hljs-meta">%</span>rbp
 <span class="hljs-number">4</span>:        <span class="hljs-keyword">sub</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">228</span>,<span class="hljs-meta">%</span>rsp
 b:        <span class="hljs-keyword">sub</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">28</span>,<span class="hljs-meta">%</span>rbp
 f:        mov    <span class="hljs-meta">%</span>rbx,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><span class="hljs-comment">(%rbp)</span>
<span class="hljs-number">13</span>:        mov    <span class="hljs-meta">%</span>r<span class="hljs-number">13</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span><span class="hljs-comment">(%rbp)</span>
<span class="hljs-number">17</span>:        mov    <span class="hljs-meta">%</span>r<span class="hljs-number">14</span>,<span class="hljs-number">0</span>x<span class="hljs-number">10</span><span class="hljs-comment">(%rbp)</span>
<span class="hljs-number">1</span>b:        mov    <span class="hljs-meta">%</span>r<span class="hljs-number">15</span>,<span class="hljs-number">0</span>x<span class="hljs-number">18</span><span class="hljs-comment">(%rbp)</span>
<span class="hljs-number">1</span>f:        <span class="hljs-keyword">xor</span>    <span class="hljs-meta">%</span>eax,<span class="hljs-meta">%</span>eax
<span class="hljs-number">21</span>:        mov    <span class="hljs-meta">%</span>rax,<span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-comment">(%rbp)</span>
<span class="hljs-number">25</span>:        mov    <span class="hljs-number">0</span>x<span class="hljs-number">80</span><span class="hljs-comment">(%rdi)</span>,<span class="hljs-meta">%</span>r<span class="hljs-number">9</span>d
[...]</code></pre></div><p>交叉输出opcodes的编码：</p><div class="hljs"><pre><code class="hljs angelscript"># bpftool prog dump jited id <span class="hljs-number">406</span> opcodes
 <span class="hljs-number">0</span>:        push   %rbp
           <span class="hljs-number">55</span>
 <span class="hljs-number">1</span>:        mov    %rsp,%rbp
           <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5
 <span class="hljs-number">4</span>:        sub    $<span class="hljs-number">0x228</span>,%rsp
           <span class="hljs-number">48</span> <span class="hljs-number">81</span> ec <span class="hljs-number">28</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
 b:        sub    $<span class="hljs-number">0x28</span>,%rbp
           <span class="hljs-number">48</span> <span class="hljs-number">83</span> ed <span class="hljs-number">28</span>
 f:        mov    %rbx,<span class="hljs-number">0x0</span>(%rbp)
           <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">5</span>d <span class="hljs-number">00</span>
<span class="hljs-number">13</span>:        mov    %r13,<span class="hljs-number">0x8</span>(%rbp)
           <span class="hljs-number">4</span>c <span class="hljs-number">89</span> <span class="hljs-number">6</span>d <span class="hljs-number">08</span>
<span class="hljs-number">17</span>:        mov    %r14,<span class="hljs-number">0x10</span>(%rbp)
           <span class="hljs-number">4</span>c <span class="hljs-number">89</span> <span class="hljs-number">75</span> <span class="hljs-number">10</span>
<span class="hljs-number">1</span>b:        mov    %r15,<span class="hljs-number">0x18</span>(%rbp)
           <span class="hljs-number">4</span>c <span class="hljs-number">89</span> <span class="hljs-number">7</span>d <span class="hljs-number">18</span>
[...]</code></pre></div><p>可以通过bpftool与graphviz进行指令的可视化，生成相应的png：</p><div class="hljs"><pre><code class="hljs lua"># bpftool prog <span class="hljs-built_in">dump</span> xlated id <span class="hljs-number">406</span> visual &amp;&gt; <span class="hljs-built_in">output</span>.dot
$ dot -Tpng <span class="hljs-built_in">output</span>.dot -o <span class="hljs-built_in">output</span>.png</code></pre></div><p><img src="/img/bpf_dot_2020032901.png" srcset="/img/loading.gif"></p><p>需要注意的是<code>xlated</code>是验证器验证后的程序，因此dump的指令与通过解释器的BPF指令一样。在内核中，验证器会对BPF loader提供的原生指令进行重写。比如对内联的BPF helper函数进行重写，以map lookup为例：</p><div class="hljs"><pre><code class="hljs"><span class="hljs-comment"># bpftool prog dump xlated id 3</span>
 <span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">2</span>
 <span class="hljs-attribute">1</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">4</span>) = r<span class="hljs-number">1</span>
 <span class="hljs-attribute">2</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>
 <span class="hljs-attribute">3</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">4</span>
 <span class="hljs-attribute">4</span>: (<span class="hljs-number">18</span>) r<span class="hljs-number">1</span> = map[id:<span class="hljs-number">2</span>]                      &lt;-- BPF map id <span class="hljs-number">2</span>
 <span class="hljs-attribute">6</span>: (<span class="hljs-number">85</span>) call __htab_map_lookup_elem#<span class="hljs-number">77408</span>   &lt;-+ BPF helper inlined rewrite
 <span class="hljs-attribute">7</span>: (<span class="hljs-number">15</span>) if r<span class="hljs-number">0</span> == <span class="hljs-number">0</span>x<span class="hljs-number">0</span> goto pc+<span class="hljs-number">2</span>                |
 <span class="hljs-attribute">8</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">0</span> += <span class="hljs-number">56</span>                              |
 <span class="hljs-attribute">9</span>: (<span class="hljs-number">79</span>) r<span class="hljs-number">0</span> = *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">0</span>)                &lt;-+
<span class="hljs-attribute">10</span>: (<span class="hljs-number">15</span>) if r<span class="hljs-number">0</span> == <span class="hljs-number">0</span>x<span class="hljs-number">0</span> goto pc+<span class="hljs-number">24</span>
<span class="hljs-attribute">11</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>
<span class="hljs-attribute">12</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">4</span>
[...]</code></pre></div><p>bpftool通过kallsyms来关联bpf helper函数以及bpf2bpf，因此需要确保如下参数开启：</p><div class="hljs"><pre><code class="hljs gradle"># echo <span class="hljs-number">0</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>kptr_restrict
# echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_kallsyms</code></pre></div><p>对于BPF2BPF，JIT编译后的dump信息，与使用解释器的dump信息是一样的，只不过JIT中使用tag来代替请求的目标函数，如下下面，<code>pc+2</code>表示子程序的偏移量：</p><div class="hljs"><pre><code class="hljs awk"><span class="hljs-comment"># bpftool prog dump xlated id 1</span>
<span class="hljs-number">0</span>: (<span class="hljs-number">85</span>) call pc+<span class="hljs-number">2</span><span class="hljs-comment">#__bpf_prog_run_args32</span>
<span class="hljs-number">1</span>: (b7) r0 = <span class="hljs-number">1</span>
<span class="hljs-number">2</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span>
<span class="hljs-number">3</span>: (b7) r0 = <span class="hljs-number">2</span>
<span class="hljs-number">4</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span></code></pre></div><p>上面是通过解释器加载的BPF程序，下面是通过JIT编译后的：</p><div class="hljs"><pre><code class="hljs awk"><span class="hljs-comment"># bpftool prog dump xlated id 1</span>
<span class="hljs-number">0</span>: (<span class="hljs-number">85</span>) call pc+<span class="hljs-number">2</span><span class="hljs-comment">#bpf_prog_3b185187f1855c4c_F</span>
<span class="hljs-number">1</span>: (b7) r0 = <span class="hljs-number">1</span>
<span class="hljs-number">2</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span>
<span class="hljs-number">3</span>: (b7) r0 = <span class="hljs-number">2</span>
<span class="hljs-number">4</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span></code></pre></div><p>对于尾调，与BPF helper函数类似，会映射为一条call指令：</p><div class="hljs"><pre><code class="hljs angelscript"># bpftool prog dump xlated id <span class="hljs-number">2</span>
[...]
<span class="hljs-number">10</span>: (b7) r2 = <span class="hljs-number">8</span>
<span class="hljs-number">11</span>: (<span class="hljs-number">85</span>) call bpf_trace_printk#<span class="hljs-number">-41312</span>
<span class="hljs-number">12</span>: (bf) r1 = r6
<span class="hljs-number">13</span>: (<span class="hljs-number">18</span>) r2 = map[id:<span class="hljs-number">1</span>]
<span class="hljs-number">15</span>: (b7) r3 = <span class="hljs-number">0</span>
<span class="hljs-number">16</span>: (<span class="hljs-number">85</span>) call bpf_tail_call#<span class="hljs-number">12</span>
<span class="hljs-number">17</span>: (b7) r1 = <span class="hljs-number">42</span>
<span class="hljs-number">18</span>: (<span class="hljs-number">6</span>b) *(u16 *)(r6 +<span class="hljs-number">46</span>) = r1
<span class="hljs-number">19</span>: (b7) r0 = <span class="hljs-number">0</span>
<span class="hljs-number">20</span>: (<span class="hljs-number">95</span>) exit

# bpftool map show id <span class="hljs-number">1</span>
<span class="hljs-number">1</span>: prog_array  flags <span class="hljs-number">0x0</span>
      key <span class="hljs-number">4</span>B  value <span class="hljs-number">4</span>B  max_entries <span class="hljs-number">1</span>  memlock <span class="hljs-number">4096</span>B</code></pre></div><h4 id="dump-BPF-map"><a href="#dump-BPF-map" class="headerlink" title="dump BPF map"></a>dump BPF map</h4><p>可以通过<code>map dump</code>子命令来dump map中的所有数据：</p><div class="hljs"><pre><code class="hljs angelscript"># bpftool map dump id <span class="hljs-number">5</span>
key:
f0 <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">0</span>a <span class="hljs-number">66</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">8</span>a d6
<span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
value:
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
key:
<span class="hljs-number">0</span>a <span class="hljs-number">66</span> <span class="hljs-number">1</span>c ee <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
value:
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
[...]
Found <span class="hljs-number">6</span> elements</code></pre></div><p>结合BTF，还能输出map的结构体。例如结合BTF与iproute2中的<code>BPF_ANNOTATE_KV_PAIR()</code>宏：<br>程序源码：</p><div class="hljs"><pre><code class="hljs rust"># cat tools/testing/selftests/bpf/test_xdp_noinline.c
  [...]
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_value</span></span> &#123;
         <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>
                 __<span class="hljs-built_in">u64</span> value;
                 __<span class="hljs-built_in">u32</span> ifindex;
                 __<span class="hljs-built_in">u8</span> mac[<span class="hljs-number">6</span>];
         &#125;;
   &#125;;

   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_def</span></span> __attribute__ ((section(<span class="hljs-string">&quot;maps&quot;</span>), used)) ctl_array = &#123;
          .<span class="hljs-keyword">type</span>            = BPF_MAP_TYPE_ARRAY,
          .key_size        = sizeof(__<span class="hljs-built_in">u32</span>),
          .value_size      = sizeof(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_value</span></span>),
          .max_entries     = <span class="hljs-number">16</span>,
          .map_flags       = <span class="hljs-number">0</span>,
   &#125;;
   BPF_ANNOTATE_KV_PAIR(ctl_array, __<span class="hljs-built_in">u32</span>, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_value</span></span>);

   [...]</code></pre></div><p><code>BPF_ANNOTATE_KV_PAIR()</code>宏用于生成一个map专用的ELF section，其中保存了一组空的键值对。通过这个section，iproute2可以与BTF中的数据对应起来，从而从BTF中选择相应的类型，来进行映射输出。<br>通过clang进行编译，并通过pahole生成BTF信息：</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-comment"># clang [...] -O2 -target bpf -g -emit-llvm -c test_xdp_noinline.c -o - |</span>
  llc <span class="hljs-attribute">-march</span>=bpf <span class="hljs-attribute">-mcpu</span>=probe <span class="hljs-attribute">-mattr</span>=dwarfris <span class="hljs-attribute">-filetype</span>=obj -o test_xdp_noinline.o
<span class="hljs-comment"># pahole -J test_xdp_noinline.o</span></code></pre></div><p>加载到内核中，然后dump map：</p><div class="hljs"><pre><code class="hljs angelscript"># ip -force link <span class="hljs-keyword">set</span> dev lo xdp obj test_xdp_noinline.o sec xdp-test
# ip a
<span class="hljs-number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="hljs-number">65536</span> xdpgeneric/id:<span class="hljs-number">227</span> qdisc noqueue state UNKNOWN group <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>
    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>
    inet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">8</span> scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host
       valid_lft forever preferred_lft forever
[...]
# bpftool prog show id <span class="hljs-number">227</span>
<span class="hljs-number">227</span>: xdp  tag a85e060c275c5616  gpl
    loaded_at <span class="hljs-number">2018</span><span class="hljs-number">-07</span><span class="hljs-number">-17</span>T14:<span class="hljs-number">41</span>:<span class="hljs-number">29</span>+<span class="hljs-number">0000</span>  uid <span class="hljs-number">0</span>
    xlated <span class="hljs-number">8152</span>B  <span class="hljs-keyword">not</span> jited  memlock <span class="hljs-number">12288</span>B  map_ids <span class="hljs-number">381</span>,<span class="hljs-number">385</span>,<span class="hljs-number">386</span>,<span class="hljs-number">382</span>,<span class="hljs-number">384</span>,<span class="hljs-number">383</span>
# bpftool map dump id <span class="hljs-number">386</span>
 [&#123;
      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">&quot;value&quot;</span>: &#123;
          <span class="hljs-string">&quot;&quot;</span>: &#123;
              <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">0</span>,
              <span class="hljs-string">&quot;ifindex&quot;</span>: <span class="hljs-number">0</span>,
              <span class="hljs-string">&quot;mac&quot;</span>: []
          &#125;
      &#125;
  &#125;,&#123;
      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-number">1</span>,
      <span class="hljs-string">&quot;value&quot;</span>: &#123;
          <span class="hljs-string">&quot;&quot;</span>: &#123;
              <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">0</span>,
              <span class="hljs-string">&quot;ifindex&quot;</span>: <span class="hljs-number">0</span>,
              <span class="hljs-string">&quot;mac&quot;</span>: []
          &#125;
      &#125;
  &#125;,&#123;
[...]</code></pre></div><p>还可以通过bpftool对map指定key进行查询、更改或删除。如果BPF程序成功添加了BTF信息，在<code>prog show</code>中可以查看到<code>btf_id</code>：</p><div class="hljs"><pre><code class="hljs apache"><span class="hljs-comment"># bpftool prog show id 72</span>
<span class="hljs-attribute">72</span>: xdp  name balancer_ingres  tag acf<span class="hljs-number">44</span>cabb<span class="hljs-number">48385</span>ed  gpl
   <span class="hljs-attribute">loaded_at</span> <span class="hljs-number">2020</span>-<span class="hljs-number">04</span>-<span class="hljs-number">13</span>T<span class="hljs-number">23</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span>+<span class="hljs-number">0900</span>  uid <span class="hljs-number">0</span>
   <span class="hljs-attribute">xlated</span> <span class="hljs-number">19104</span>B  jited <span class="hljs-number">10732</span>B  memlock <span class="hljs-number">20480</span>B  map_ids <span class="hljs-number">126</span>,<span class="hljs-number">130</span>,<span class="hljs-number">131</span>,<span class="hljs-number">127</span>,<span class="hljs-number">129</span>,<span class="hljs-number">128</span>
   <span class="hljs-attribute">btf_id</span> <span class="hljs-number">60</span></code></pre></div><p>通过<code>btf show</code>命令也能查看：</p><div class="hljs"><pre><code class="hljs angelscript"># bpftool btf show
<span class="hljs-number">60</span>: size <span class="hljs-number">12243</span>B  prog_ids <span class="hljs-number">72</span>  map_ids <span class="hljs-number">126</span>,<span class="hljs-number">130</span>,<span class="hljs-number">131</span>,<span class="hljs-number">127</span>,<span class="hljs-number">129</span>,<span class="hljs-number">128</span></code></pre></div><p>通过<code>btf dump</code>可以输出btf的信息，可以是c或是raw：</p><div class="hljs"><pre><code class="hljs crystal"><span class="hljs-comment"># bpftool btf dump id 60 format c</span>
  [...]
   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_value</span> &#123;</span>
         <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>
                 __u64 value;
                 __u32 ifindex;
                 __u8 mac[<span class="hljs-number">6</span>];
         &#125;;
   &#125;;

   typedef unsigned int u32;
   [...]</code></pre></div><h3 id="BPF-sysctls"><a href="#BPF-sysctls" class="headerlink" title="BPF sysctls"></a>BPF sysctls</h3><p>BPF相关的内核参数：</p><ul><li><code>/proc/sys/net/core/bpf_jit_enable</code>：开启或关闭BPF JIT</li></ul><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>关闭JIT，使用内核解释器（默认值）</td></tr><tr><td>1</td><td>开启JIT</td></tr><tr><td>2</td><td>开启JIT，并产生debug信息到内核日志中</td></tr><tr><td>当设置为2时，可以使用<code>bpf_jit_disasm</code>进行调试。</td><td></td></tr></tbody></table><ul><li><code>/proc/sys/net/core/bpf_jit_harden</code>：开启或关闭BPF JIT加固。注意开启后会损耗性能，并且会盲化BPF中的立即数。对于通过解释器处理的BPF程序，无需加固。</li></ul><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>关闭JIT加固（默认值）</td></tr><tr><td>1</td><td>对非特权用户启用JIT加固</td></tr><tr><td>2</td><td>对所有用户启动JIT加固</td></tr></tbody></table><ul><li><code>/proc/sys/net/core/bpf_jit_kallsyms</code>：控制是否将JIT编译的BPF程序作为内核符号输出到<code>/proc/kallsyms</code>中，以便与<code>perf</code>一起使用，或是提供堆栈展开的功能。符号名称包含BPF程序的tag（<code>bpf_prog_&lt;tag&gt;</code>）。如果开启<code>bpf_jit_harden</code>，则此特性需要关闭：</li></ul><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>关闭JIT的kallsyms输出（默认值）</td></tr><tr><td>1</td><td>对特权用户开启JIT的kallsyms输出</td></tr></tbody></table><ul><li><code>/proc/sys/kernel/unprivileged_bpf_disabled</code>：开启或关闭非特权用户的<code>bpf(2)</code>系统调用。默认是开启了非特权用户的使用的，这个值是一次性开关，一旦切换，会永久禁用，除非重启。开关不影响其他使用非<code>bpf(2)</code>进行加载的BPF程序，比如seccomp和传统套接字过滤。</li></ul><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>允许非特权用户进行bpf系统调用 （默认值）</td></tr><tr><td>1</td><td>禁止非特权用户进行bpf系统调用</td></tr></tbody></table><h3 id="内核测试"><a href="#内核测试" class="headerlink" title="内核测试"></a>内核测试</h3><p>内核提供了BPF的自测，在<code>tools/testing/selftests/bpf/</code>中：</p><div class="hljs"><pre><code class="hljs awk">$ cd tools<span class="hljs-regexp">/testing/</span>selftests<span class="hljs-regexp">/bpf/</span>
$ make
<span class="hljs-comment"># make run_tests</span></code></pre></div><p>测试涉及：</p><ul><li>BPF验证器</li><li>BPF程序tags</li><li>各种BPF map接口与各类型的BPF map</li><li>检测LLVM后端的C代码</li><li>检测解释器与JIT的eBPF与cBPF汇编代码</li></ul><h3 id="JIT-debug"><a href="#JIT-debug" class="headerlink" title="JIT debug"></a>JIT debug</h3><p>通过修改<code>bpf_jit_enable</code>可以将每次编译的JIT image信息发送到内核日志中：</p><div class="hljs"><pre><code class="hljs gradle"># echo <span class="hljs-number">2</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_enable</code></pre></div><p>当BPF程序load后，可以通过<code>dmesg</code>输出：</p><div class="hljs"><pre><code class="hljs angelscript">[ <span class="hljs-number">3389.935842</span>] flen=<span class="hljs-number">6</span> proglen=<span class="hljs-number">70</span> pass=<span class="hljs-number">3</span> image=ffffffffa0069c8f <span class="hljs-keyword">from</span>=tcpdump pid=<span class="hljs-number">20583</span>
[ <span class="hljs-number">3389.935847</span>] JIT code: <span class="hljs-number">00000000</span>: <span class="hljs-number">55</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5 <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">60</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">5</span>d f8 <span class="hljs-number">44</span> <span class="hljs-number">8</span>b <span class="hljs-number">4f</span> <span class="hljs-number">68</span>
[ <span class="hljs-number">3389.935849</span>] JIT code: <span class="hljs-number">00000010</span>: <span class="hljs-number">44</span> <span class="hljs-number">2</span>b <span class="hljs-number">4f</span> <span class="hljs-number">6</span>c <span class="hljs-number">4</span>c <span class="hljs-number">8</span>b <span class="hljs-number">87</span> d8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> be <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
[ <span class="hljs-number">3389.935850</span>] JIT code: <span class="hljs-number">00000020</span>: e8 <span class="hljs-number">1</span>d <span class="hljs-number">94</span> ff e0 <span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">75</span> <span class="hljs-number">16</span> be <span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
[ <span class="hljs-number">3389.935851</span>] JIT code: <span class="hljs-number">00000030</span>: <span class="hljs-number">00</span> e8 <span class="hljs-number">28</span> <span class="hljs-number">94</span> ff e0 <span class="hljs-number">83</span> f8 <span class="hljs-number">01</span> <span class="hljs-number">75</span> <span class="hljs-number">07</span> b8 ff ff <span class="hljs-number">00</span> <span class="hljs-number">00</span>
[ <span class="hljs-number">3389.935852</span>] JIT code: <span class="hljs-number">00000040</span>: eb <span class="hljs-number">02</span> <span class="hljs-number">31</span> c0 c9 c3</code></pre></div><p><code>flen</code>表示程序BFP指令的数量（6条BPF指令），<code>proglen</code>表示JIT生成image的大小（70字节），<code>pass=3</code>表示image经过了3个编译器passes（例如<code>x86_64</code>中为了减小image的大小，会有多种进行优化的passes）。<code>image</code>表示JIT image的地址，<code>from</code>与<code>pid</code>表示触发此次编译的用户空间的程序与PID。下面的JIT code可以使用<code>tools/bpf/</code>中的<code>bpf_jit_disasm</code>来反汇编。</p><div class="hljs"><pre><code class="hljs angelscript"># ./bpf_jit_disasm
<span class="hljs-number">70</span> bytes emitted <span class="hljs-keyword">from</span> JIT compiler (pass:<span class="hljs-number">3</span>, flen:<span class="hljs-number">6</span>)
ffffffffa0069c8f + &lt;x&gt;:
   <span class="hljs-number">0</span>:       push   %rbp
   <span class="hljs-number">1</span>:       mov    %rsp,%rbp
   <span class="hljs-number">4</span>:       sub    $<span class="hljs-number">0x60</span>,%rsp
   <span class="hljs-number">8</span>:       mov    %rbx,<span class="hljs-number">-0x8</span>(%rbp)
   c:       mov    <span class="hljs-number">0x68</span>(%rdi),%r9d
  <span class="hljs-number">10</span>:       sub    <span class="hljs-number">0x6c</span>(%rdi),%r9d
  <span class="hljs-number">14</span>:       mov    <span class="hljs-number">0xd8</span>(%rdi),%r8
  <span class="hljs-number">1</span>b:       mov    $<span class="hljs-number">0xc</span>,%esi
  <span class="hljs-number">20</span>:       callq  <span class="hljs-number">0xffffffffe0ff9442</span>
  <span class="hljs-number">25</span>:       cmp    $<span class="hljs-number">0x800</span>,%eax
  <span class="hljs-number">2</span>a:       jne    <span class="hljs-number">0x0000000000000042</span>
  <span class="hljs-number">2</span>c:       mov    $<span class="hljs-number">0x17</span>,%esi
  <span class="hljs-number">31</span>:       callq  <span class="hljs-number">0xffffffffe0ff945e</span>
  <span class="hljs-number">36</span>:       cmp    $<span class="hljs-number">0x1</span>,%eax
  <span class="hljs-number">39</span>:       jne    <span class="hljs-number">0x0000000000000042</span>
  <span class="hljs-number">3</span>b:       mov    $<span class="hljs-number">0xffff</span>,%eax
  <span class="hljs-number">40</span>:       jmp    <span class="hljs-number">0x0000000000000044</span>
  <span class="hljs-number">42</span>:       <span class="hljs-keyword">xor</span>    %eax,%eax
  <span class="hljs-number">44</span>:       leaveq
  <span class="hljs-number">45</span>:       retq</code></pre></div><p>还可以插上opcode：</p><div class="hljs"><pre><code class="hljs angelscript"># ./bpf_jit_disasm -o
<span class="hljs-number">70</span> bytes emitted <span class="hljs-keyword">from</span> JIT compiler (pass:<span class="hljs-number">3</span>, flen:<span class="hljs-number">6</span>)
ffffffffa0069c8f + &lt;x&gt;:
   <span class="hljs-number">0</span>:       push   %rbp
    <span class="hljs-number">55</span>
   <span class="hljs-number">1</span>:       mov    %rsp,%rbp
    <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5
   <span class="hljs-number">4</span>:       sub    $<span class="hljs-number">0x60</span>,%rsp
    <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">60</span>
   <span class="hljs-number">8</span>:       mov    %rbx,<span class="hljs-number">-0x8</span>(%rbp)
    <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">5</span>d f8
   c:       mov    <span class="hljs-number">0x68</span>(%rdi),%r9d
    <span class="hljs-number">44</span> <span class="hljs-number">8</span>b <span class="hljs-number">4f</span> <span class="hljs-number">68</span>
  <span class="hljs-number">10</span>:       sub    <span class="hljs-number">0x6c</span>(%rdi),%r9d
    <span class="hljs-number">44</span> <span class="hljs-number">2</span>b <span class="hljs-number">4f</span> <span class="hljs-number">6</span>c
  <span class="hljs-number">14</span>:       mov    <span class="hljs-number">0xd8</span>(%rdi),%r8
    <span class="hljs-number">4</span>c <span class="hljs-number">8</span>b <span class="hljs-number">87</span> d8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
  <span class="hljs-number">1</span>b:       mov    $<span class="hljs-number">0xc</span>,%esi
    be <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
  <span class="hljs-number">20</span>:       callq  <span class="hljs-number">0xffffffffe0ff9442</span>
    e8 <span class="hljs-number">1</span>d <span class="hljs-number">94</span> ff e0
  <span class="hljs-number">25</span>:       cmp    $<span class="hljs-number">0x800</span>,%eax
    <span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
  <span class="hljs-number">2</span>a:       jne    <span class="hljs-number">0x0000000000000042</span>
    <span class="hljs-number">75</span> <span class="hljs-number">16</span>
  <span class="hljs-number">2</span>c:       mov    $<span class="hljs-number">0x17</span>,%esi
    be <span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
  <span class="hljs-number">31</span>:       callq  <span class="hljs-number">0xffffffffe0ff945e</span>
    e8 <span class="hljs-number">28</span> <span class="hljs-number">94</span> ff e0
  <span class="hljs-number">36</span>:       cmp    $<span class="hljs-number">0x1</span>,%eax
    <span class="hljs-number">83</span> f8 <span class="hljs-number">01</span>
  <span class="hljs-number">39</span>:       jne    <span class="hljs-number">0x0000000000000042</span>
    <span class="hljs-number">75</span> <span class="hljs-number">07</span>
  <span class="hljs-number">3</span>b:       mov    $<span class="hljs-number">0xffff</span>,%eax
    b8 ff ff <span class="hljs-number">00</span> <span class="hljs-number">00</span>
  <span class="hljs-number">40</span>:       jmp    <span class="hljs-number">0x0000000000000044</span>
    eb <span class="hljs-number">02</span>
  <span class="hljs-number">42</span>:       <span class="hljs-keyword">xor</span>    %eax,%eax
    <span class="hljs-number">31</span> c0
  <span class="hljs-number">44</span>:       leaveq
    c9
  <span class="hljs-number">45</span>:       retq
    c3</code></pre></div><p>最新的<code>bpftool</code>已经可以通过指定BPF程序的ID来dump JITed BPF程序（上面bpftool中介绍了）。<br>可以使用<code>perf</code>对JITed BPF程序进行性能分析，需要kallsyms信息的支持：</p><div class="hljs"><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_enable
# echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_kallsyms</code></pre></div><p>切换<code>bpf_jit_kallsyms</code>不需要重新加载BPF程序。下面的例子中：perf记录<code>bpf_clone_redirect()</code>helper函数中的分配失败。因为直接写，<code>bpf_clone_redirect()</code>中调用的<code>bpf_try_make_head_writable()</code>会失败，然后会释放克隆的<code>skb</code>，并返回错。<code>perf</code>记录了所有的<code>kfree_skb</code>事件。</p><div class="hljs"><pre><code class="hljs awk"><span class="hljs-comment"># tc qdisc add dev em1 clsact</span>
<span class="hljs-comment"># tc filter add dev em1 ingress bpf da obj prog.o sec main</span>
<span class="hljs-comment"># tc filter show dev em1 ingress</span>
filter protocol all pref <span class="hljs-number">49152</span> bpf
filter protocol all pref <span class="hljs-number">49152</span> bpf handle <span class="hljs-number">0</span>x1 prog.o:[main] direct-action id <span class="hljs-number">1</span> tag <span class="hljs-number">8227</span>addf251b7543

<span class="hljs-comment"># cat /proc/kallsyms</span>
[...]
ffffffffc00349e0 t fjes_hw_init_command_registers    [fjes]
ffffffffc003e2e0 d __tracepoint_fjes_hw_stop_debug_err    [fjes]
ffffffffc0036190 t fjes_hw_epbuf_tx_pkt_send    [fjes]
ffffffffc004b000 t bpf_prog_8227addf251b7543

<span class="hljs-comment"># perf record -a -g -e skb:kfree_skb sleep 60</span>
<span class="hljs-comment"># perf script --kallsyms=/proc/kallsyms</span>
[...]
ksoftirqd/<span class="hljs-number">0</span>     <span class="hljs-number">6</span> [<span class="hljs-number">000</span>]  <span class="hljs-number">1004.578402</span>:    skb:kfree_skb: skbaddr=<span class="hljs-number">0</span>xffff9d4161f20a00 protocol=<span class="hljs-number">2048</span> location=<span class="hljs-number">0</span>xffffffffc004b52c
   <span class="hljs-number">7</span>fffb8745961 bpf_clone_redirect (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffc004e52c bpf_prog_8227addf251b7543 (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffc05b6283 cls_bpf_classify (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb875957a tc_classify (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb8729840 __netif_receive_skb_core (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb8729e38 __netif_receive_skb (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb872ae05 process_backlog (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb872a43e net_rx_action (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb886176c __do_softirq (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb80ac5b9 run_ksoftirqd (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb80ca7fa smpboot_thread_fn (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb80c6831 kthread (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)
   <span class="hljs-number">7</span>fffb885e09c ret_from_fork (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)</code></pre></div><p>从上面perf的输出可以看出，<code>bpf_prog_8227addf251b7543</code>是调用栈中的一层，表示tag为<code>8227addf251b7543</code>的BPF程序与<code>kfree_skb</code>事件相关。</p><h3 id="内省（Introspection"><a href="#内省（Introspection" class="headerlink" title="内省（Introspection)"></a>内省（Introspection)</h3><p>内核提供了关于BPF和XDP的各种跟踪点，可以用于内省。BPF的跟踪点：</p><div class="hljs"><pre><code class="hljs less"># <span class="hljs-selector-tag">perf</span> <span class="hljs-selector-tag">list</span> | <span class="hljs-selector-tag">grep</span> <span class="hljs-selector-tag">bpf</span>:
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_create</span>                                 <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_delete_elem</span>                            <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_lookup_elem</span>                            <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_next_key</span>                               <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_update_elem</span>                            <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_obj_get_map</span>                                <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_obj_get_prog</span>                               <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_obj_pin_map</span>                                <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_obj_pin_prog</span>                               <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_prog_get_type</span>                              <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_prog_load</span>                                  <span class="hljs-selector-attr">[Tracepoint event]</span>
<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_prog_put_rcu</span>                               <span class="hljs-selector-attr">[Tracepoint event]</span></code></pre></div><p>比如使用perf（这里可以用tc程序代替sleep）</p><div class="hljs"><pre><code class="hljs angelscript"># perf record -a -e bpf:* sleep <span class="hljs-number">10</span>
# perf script
sock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">283.980322</span>:      bpf:bpf_map_create: map type=ARRAY ufd=<span class="hljs-number">4</span> key=<span class="hljs-number">4</span> val=<span class="hljs-number">8</span> max=<span class="hljs-number">256</span> flags=<span class="hljs-number">0</span>
sock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">283.980721</span>:       bpf:bpf_prog_load: prog=a5ea8fa30ea6849c type=SOCKET_FILTER ufd=<span class="hljs-number">5</span>
sock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">283.988423</span>:   bpf:bpf_prog_get_type: prog=a5ea8fa30ea6849c type=SOCKET_FILTER
sock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">283.988443</span>: bpf:bpf_map_lookup_elem: map type=ARRAY ufd=<span class="hljs-number">4</span> key=[<span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>] val=[<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>]
[...]
sock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">288.990868</span>: bpf:bpf_map_lookup_elem: map type=ARRAY ufd=<span class="hljs-number">4</span> key=[<span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>] val=[<span class="hljs-number">14</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>]
     swapper     <span class="hljs-number">0</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">289.338243</span>:    bpf:bpf_prog_put_rcu: prog=a5ea8fa30ea6849c type=SOCKET_FILTER</code></pre></div><p>对于BPF程序，会显示单独的程序tag。<br>perf还能捕获XDP引发的异常事件：</p><div class="hljs"><pre><code class="hljs apache"><span class="hljs-comment"># perf list | grep xdp:</span>
<span class="hljs-attribute">xdp</span>:xdp_exception                                 <span class="hljs-meta"> [Tracepoint event]</span></code></pre></div><p>异常触发的场景包括：</p><ul><li>BPF程序返回了无效的XDP action code</li><li>BPF程序返回<code>XDP_ABORTED</code>表示为能优雅退出</li><li>BPF程序返回<code>XDP_TX</code>，但传输过程中出现错误，比如端口未运行、分配失败、传输ring已满等</li></ul><p>还可以将BPF程序加载到一个或多个跟踪点（tracepoints），从而进一步收集信息存储在map中，或是通过<code>bpf_pert_event_output()</code> helper函数来发送到用户空间。</p><h3 id="跟踪管道（tracing-pipe）"><a href="#跟踪管道（tracing-pipe）" class="headerlink" title="跟踪管道（tracing pipe）"></a>跟踪管道（tracing pipe）</h3><p>BPF可以使用<code>bpf_trace_printk()</code>将输出发送到内核的tracing pipe中，用户可以通过如下命令获取其中的内容：</p><div class="hljs"><pre><code class="hljs gradle"># tail -f <span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/trace_pipe
...</code></pre></div><blockquote><p><code>bpf_trace_printk()</code>方法是全局的，并且操作是加锁的，生产环境一般使用。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>与perf类似，BPF程序和map也是受<code>RLIMIT_MEMLOCK</code>限制的，可以通过<code>ulimit -l</code>查看当前可用的系统页数量。<br>默认的限制可能不足以加载复杂的BPF程序或是较大的BPF map，会导致BPF系统调用返回<code>EPERM</code>的<code>errno</code>。可以设置更大的limit或通过<code>RLIMIT_MEMLOCK</code>取消限制。<code>RLIMIT_MEMLOCK</code>通常是针对非特权用户的，一般可以为特权用户设置更高的限制。</p><h2 id="程序类型"><a href="#程序类型" class="headerlink" title="程序类型"></a>程序类型</h2><p>目前，BPF共有18种程序类型，其中网络主要是两类：XDP与tc。</p><h3 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h3><p>XDP是eXpress Data Path的缩写，处理点在软件层面能达到的最早的地方，即驱动收到数据包的时候。因此，XDP处理的数据包未进行<code>skb</code>的构建，也未经过GRO的处理。<br>XDP将数据留在内核中处理的优点（相比于DPDK）：</p><ul><li>XDP可以利用上游的内核网络驱动程序、用户空间的工具，以及BPF helper函数（可以访问路由表、socket这些内核网络基础设施）。</li><li>由于在内核中，因此可以和内核其余模块一样，使用类似的安全模型来访问硬件设备。</li><li>无需进行内核与用户空间的跨越，另外由于处理的数据包不出内核，可以灵活地转发到另外的Namespace中。</li><li>可以从XDP中向内核转发数据包，利用内核的TCP/IP协议栈。</li><li>完全的可编程，并且ABI的稳定性可以得到保证。相比于一般的内核模块，由于使用了BPF验证器，安全更能得到保证。</li><li>可以在运行时原子的替换BPF程序，而不中断流量。</li><li>XDP可以灵活得到集成到内核中，比如可以运行在“busy polling”与”interrupt driven”两种模式 （前者轮询，后者中断），不需要占用单独的CPU，也不需要特殊的硬件支持或是hugepages。</li><li>无需第三方的内核模块或许可。</li><li>主流发行版中，内核4.8+的版本都支持XDP，支持主流的万兆网络驱动。</li></ul><p>作为驱动程序中运行的BPF，XDP确保数据包以线性的方式存储在单个DMA页上，以供BPF程序读写。XDP还能使用256字节的额外的headroom，可以通过<code>bpf_xdp_adjust_head()</code>实现自定义的数据包封装，或是通过<code>bpf_xdp_adjust_meta()</code>来在数据包前添加自定义的元数据。<br>XDP允许直接对数据包进行访问，程序可以将指向数据包的指针保存在寄存器中，加载数据包的数据到寄存器，将寄存器中的数据写入数据包。</p><h4 id="XDP的上下文"><a href="#XDP的上下文" class="headerlink" title="XDP的上下文"></a>XDP的上下文</h4><p>XDP的上下文（ctx）：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xdp_buff</span> &#123;</span>
    <span class="hljs-keyword">void</span> *data;
    <span class="hljs-keyword">void</span> *data_end;
    <span class="hljs-keyword">void</span> *data_meta;
    <span class="hljs-keyword">void</span> *data_hard_start;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xdp_rxq_info</span> *<span class="hljs-title">rxq</span>;</span>
&#125;;</code></pre></div><p><code>data</code>指向页中数据包的开始位置，<code>data_end</code>指向数据包结束位置，<code>data_hard_start</code>指向可能的最大headroom开始的地方，封装后通过<code>bpf_xdp_adjust_head()</code>调整<code>data</code>，解封后也一样。</p><blockquote><p>headroom与tailroom分别是包data前后分配的空间，封装时，会在data前添加封装头，data指针向headroom靠近，反之远离。</p></blockquote><p><code>data_meta</code>开始时与<code>data</code>指向相同的地方，可以通过<code>bpf_xdp_adjust_meta()</code>来将指针向<code>data_hard_start</code>方向进行调整，来保存自定义的元数据。<code>data_meta</code>与<code>data</code>之间保存的自定义元数据在常规内核网络协议栈中是不可见的，只可用于tc BPF读取。相同的，使用<code>bpf_xdp_adjust_meta()</code>将指针向<code>data</code>方向移动，能删除自定义的元数据。<code>data_meta</code>可以用于在尾调的函数之间传递状态，类似于tc BPF用<code>skb-&gt;cb[]</code>传递状态。<br>上面指针之间的关系：<code>data_hard_start</code> &lt;= <code>data_meta</code> &lt;= <code>data</code> &lt; <code>data_end</code>。<br><code>rxq</code>保存单个接收队列的元数据。</p><div class="hljs"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xdp_rxq_info</span></span> &#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span></span> *dev;
    <span class="hljs-built_in">u32</span> queue_index;
    <span class="hljs-built_in">u32</span> reg_state;
&#125; ____cacheline_aligned;</code></pre></div><p>BPF程序可以通过<code>netdevice</code>获取<code>queue_index</code>或其他信息，比如<code>ifindex</code>等。</p><h4 id="XDP的返回值"><a href="#XDP的返回值" class="headerlink" title="XDP的返回值"></a>XDP的返回值</h4><p>XDP的返回值用于指示下一步如何处理数据包，定义在<code>linux/bpf.h</code>中：</p><div class="hljs"><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">xdp_action</span> &#123;</span>
    XDP_ABORTED = <span class="hljs-number">0</span>,
    XDP_DROP,
    XDP_PASS,
    XDP_TX,
    XDP_REDIRECT,
&#125;;</code></pre></div><ul><li><code>XDP_DROP</code>丢弃不再浪费资源进行处理。DDoS中常用。</li><li><code>XDP_PASS</code>继续进入内核协议栈进行处理，是没有XDP程序时，数据包的默认行为。<code>XDP_PASS</code>意味着当前CPU会转而去处理数据包的<code>skb</code>分配，传递数据包到GRO中。</li><li><code>XDP_TX</code>从接收的网卡中发出，可用于实现负载均衡（在XDP BPF中对数据包进行重写）</li><li><code>XDP_REDIRECT</code>类似于<code>XDP_TX</code>，但是是从其他NIC中发出，类似于转发。另外<code>XDP_REDIRECT</code>可以将数据包转发到BPF cpumap中，意味着用于处理XDP的CPU会仍然处理XDP，而将需要进入内核协议栈的数据包交由其它CPU处理，这种情况类似于<code>XDP_PASS</code>，但CPU不会处理发送数据包到内核协议栈的工作，因此XDP处理性能会更高。</li><li><code>XDP_ABORTED</code>用于表示程序中的异常状态，与<code>XDP_DROP</code>的行为相同，但会传递到<code>trace_xdp_exception</code>的tracepoint中。</li></ul><h4 id="XDP主要使用场景"><a href="#XDP主要使用场景" class="headerlink" title="XDP主要使用场景"></a>XDP主要使用场景</h4><ul><li><p><strong>DDoS防御，防火墙</strong><br>由于可以通过<code>XDP_DROP</code>在早期就丢弃数据包，因此很适合处理DDoS攻击。更普遍的情况是使用BPF实现任何类型的防火墙。比如作为独立式设备（stand alone appliance），通过<code>XDP_TX</code>进行流量“清理”，或是广泛部署节点上来保护终端设备。offload XDP通过NIC线性速率的处理，提供更高的性能。</p></li><li><p><strong>转发或负载均衡</strong><br>可以通过<code>XDP_TX</code>与<code>XDP_REDIRECT</code>来转发或进行负载均衡。XDP BPF可以对数据包进行任意的处理，可以在发送之前进行封装或解封。<code>XDP_REDIRECT</code>可以与BPF cpumap使用，将数据包负载均衡到本地的协议栈中。</p></li><li><p><strong>协议栈之前的过滤或处理</strong><br>可以在协议栈之前过滤掉无关的数据包，比如我们已知此节点只处理TCP，那么就能DROP掉UDP、SCTP以及其他4层协议的包。此外，如果在内核接收路径上存在某个潜在的BUG可能会导致“ping of death”，可以通过XDP来过滤掉这些可能触发BUG的数据包。<br>另一个使用场景是在数据包进入协议栈前对数据包进行修改。比如这种自定义封装协议的场景下，可能由于GRO对封装协议的不支持而导致无法进行数据包的聚合，则可以通过XDP进行先解封。或者是通过写入元数据（对内核协议栈不可见），来与tc BPF协调处理。</p></li><li><p><strong>流量的采样与监控</strong><br>XDP可以用于流量的采样、监控或者网络分析。可以将数据包（截断的或是完整的payload）或者是用户自定义的元数据发送到无锁、per CPU的内存映射缓冲区，缓冲区由linux perf基础设施提供，供用户空间的应用读取。<br>此外还可以对流量的初始数据包进行分析，一旦判定是正常流量后，对此流量不再进行监控。</p></li></ul><p>XDP生产环境使用案例：Facebooks的SHIV和Droplet，前者用于4层负载，后者用于抗DDoS，相比IPVS性能提升了10倍以上。</p><ul><li>Slides: <a target="_blank" rel="noopener" href="https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf">https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf</a></li><li>Video:<a target="_blank" rel="noopener" href="https://youtu.be/YEU2ClcGqts">https://youtu.be/YEU2ClcGqts</a></li></ul><p>另一个案例：Cloudflare的抗DDoS使用了XDP，原来使用的是cBPF与iptables的<code>xt_bpf</code>，由于使用了iptables，在面临DDoS时，会有性能的下降。</p><ul><li>Slides：<a target="_blank" rel="noopener" href="https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf">https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf</a></li><li>Video：<a target="_blank" rel="noopener" href="https://youtu.be/7OuOukmuivg">https://youtu.be/7OuOukmuivg</a></li></ul><h4 id="XDP的操作模式"><a href="#XDP的操作模式" class="headerlink" title="XDP的操作模式"></a>XDP的操作模式</h4><ul><li><p><strong>Native XDP</strong><br>默认模式，运行在网络驱动的早期接收路径上。需要网卡的支持。</p></li><li><p><strong>Offloaded XDP</strong><br>将XDP offload到NIC上，使用NIC处理，而非本机的CPU，性能最高。需要支持多线程、多核处理的SmartNIC支持。可能不支持部分BPF helper。一般支持此模式的NIC，都支持Native XDP。</p></li><li><p><strong>Generic XDP</strong><br>一般用于不支持Native XDP的场景，代码运行的位置在协议栈靠后部分。</p></li></ul><h4 id="驱动支持"><a href="#驱动支持" class="headerlink" title="驱动支持"></a>驱动支持</h4><p>从内核4.17支持的情况：<br>** 支持native XDP**</p><ul><li><p><strong>Broadcom</strong></p><ul><li>bnxt</li></ul></li><li><p><strong>Cavium</strong></p><ul><li>thunderx</li></ul></li><li><p><strong>Intel</strong></p><ul><li>ixgbe</li><li>ixgbevf</li><li>i40e</li></ul></li><li><p><strong>Mellanox</strong></p><ul><li>mlx4</li><li>mlx5</li></ul></li><li><p><strong>Netronome</strong></p><ul><li>nfp</li></ul></li><li><p><strong>Others</strong></p><ul><li>tun</li><li>virtio_net</li></ul></li><li><p><strong>Qlogic</strong></p><ul><li>qede</li></ul></li><li><p><strong>Solarflare</strong></p><ul><li>sfc <a target="_blank" rel="noopener" href="https://docs.cilium.io/en/stable/bpf/#id4">[1]</a></li></ul></li></ul><p><strong>支持offloaded XDP</strong></p><ul><li><strong>Netronome</strong><ul><li>nfp <a target="_blank" rel="noopener" href="https://docs.cilium.io/en/stable/bpf/#id5">[2]</a></li></ul></li></ul><h3 id="TC"><a href="#TC" class="headerlink" title="TC"></a>TC</h3><p>除了XDP外，BPF还可以在tc层运行 ，两者的区别在于：</p><ul><li><p>上下文不一样，tc的是<code>sk_buff</code>，而XDP是<code>xdp_buff</code>。内核在收到数据包，经过XDP那一层后，需要为数据包分配空间、解析并存储到<code>sk_buff</code>结构中。因此tc可以利用<code>sk_buff</code>中包含的数据包的元数据，但<code>sk_buff</code>的创建也会带来性能的损耗。XDP由于在<code>sk_buff</code>生成之前，因此无法利用<code>sk_buff</code>中的数据包元数据。<br> tc BPF可以读写<code>sk_buff</code>中的<code>mark</code>, <code>pkt_type</code>, <code>protocol</code>, <code>priority</code>, <code>queue_mapping</code>, <code>napi_id</code>, <code>cb[]</code>,<code>hash</code>, <code>tc_classid</code>或者<code>tc_index</code>,vlan数据,XDP写入的自定义元数据等。<code>sk_buff</code>的定义在<code>linux/bpf.h</code>下。<br> <code>sk_buff</code>与<code>xdp_buff</code>各有优劣势：<code>sk_buff</code>可以方便的处理相关的数据包元数据，而<code>xdp_buff</code>则不行。但<code>sk_buff</code>很难通过重写数据包字段来切换协议，因为协议栈处理数据包时依据其元数据，而非每次都读取数据包来判断协议。因此需要额外的BPF helper函数来处理元数据。而<code>xdp_buff</code>则可以直接对数据包进行重写 ，因为此时还不存在 <code>sk_buff</code>以及其中的元数据。一般可以XDP与tc配合使用（通过XDP的自定义元数据来与tc进行数据传递）。</p><ul><li><p>XDP只能在ingress路径上触发，tc能在ingress和egress路径上触发。tc中的两个hook：<code>sch_handle_ingress()</code>和<code>sch_handle_egress()</code>分别由内核中的<code>__netif_receive_skb_core()</code>和<code>__dev_queue_xmit()</code>触发。不考虑XDP，后面两个函数是每个数据包进入和发出都会经过的。</p></li><li><p>tc不需要NIC的支持。对于ingress，tc在内核的处于GRO之后，但在任何协议处理、iptable防火墙（例如PREROUTING、nftable ingress hook、或其他数据包处理）之前；对于egress，tc在数据包交于driver传输之前的最后一段，即在iptables防火墙（例如POSTROUTING）之后，但在GSO之前。唯一需要驱动支持的tc是offload的场景，与XDP offload类似，但两者的上下文、支持的helper函数以及返回值不一样。</p></li></ul></li></ul><h4 id="tc-bpf的分类器"><a href="#tc-bpf的分类器" class="headerlink" title="tc bpf的分类器"></a>tc bpf的分类器</h4><p>tc BPF运行在<code>cls_bpf</code>分类器中，虽然<code>cls_bpf</code>也称为分类器，但它可以做到完全的可编程的数据包处理，包括对<code>skb</code>元数据和包数据进行读取、更改、返回tc action。<code>cls_bpf</code>可被认为是一个用于管理tc BPF程序的独立的实体。</p><p><code>cls_bpf</code>可以包含一个或多个tc bpf程序。Cilium中<code>cls_bpf</code>在<code>direct-action</code>模式下，只包含一个tc bpf程序。传统的，分类器classifier与动作action是分开的，一个分类器可以有多个action，即当分类器匹配成功后实施多个action。这种模式不适合扩展复杂的处理逻辑 ，而tc bpf可以将解析（类似分类匹配）和action结合在一起，并且在<code>cls_bpf</code>的<code>direct-action</code>模式下，只会获取tc bpf返回的tc action，然后终止程序，这样可以通过编程来扩展复杂的处理逻辑。<code>cls_bpf</code>是唯一支持这种模式的“分类器”。</p><p>与XDP BPF相同，tc BPF也可以无缝切换，无需重启或中断流量。</p><p><code>cls_bpf</code>可以被attach到ingress或egress hook上，而ingress hook与egress hook是由<code>sch_clsact</code> qdisc管理的，它可以直接替换ingress qdisc，是ingress qdisc的超集。对于<code>__dev_queue_xmit()</code>中的tc egresss hook，它不在qdisc root lock下执行，因此tc的ingress和egress都是在无锁下执行，且禁止抢占，在RCU读侧运行。</p><p>在典型的egress qdiscs中，比如 <code>sch_mq</code>, <code>sch_fq</code>, <code>sch_fq_codel</code> 或 <code>sch_htb</code>，有些是分类型qdiscs，他们包含一些子类，利用数据包的分类机制来对数据包进行分类，这个过程是由<code>tcf_classify()</code>调用相应的分类器来实现的。<code>cls_bpf</code>也可作为分类器被调用，但这种过程一般是在qdisc root lock下执行的，会产生锁的竞争。而<code>sch_clsact</code>的egress hook处于处理流程中更早的阶段，不在qdisc root lock的范围内。因此对于<code>sch_htb</code>来说，<code>sch_clsact</code>可以无锁下通过tc BPF进行复杂的数据包分类，将分类结果记录到<code>skb-&gt;mark</code>或是<code>skb-&gt;priority</code>中，而<code>sch_htb</code>只需要在qdisc root lock下，实现简单的映射，从而减少了锁的竞争。</p><p><code>sch_clsact</code>与<code>cls_bpf</code>结合使用的场景也支持offload tc bpf，bpf会通过JIT编译，然后运行在NIC上。只有<code>cls_bpf</code>的<code>direct-action</code>支持offload，并且只支持包含单个bpf程序，只支持ingress。</p><p>当一个<code>cls_bpf</code>内包含多个bpf程序时，当bpf返回<code>TC_ACT_UNSPEC</code>，则会继续执行下一个tc bpf。但这样做的缺点是各个BPF程序需要各自解析数据包 ，从而导致性能下降。</p><h4 id="TC-BPF的返回值"><a href="#TC-BPF的返回值" class="headerlink" title="TC BPF的返回值"></a>TC BPF的返回值</h4><p>ingress和egress共用返回值，在<code>linux/pkg_cls.h</code>下定义：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_UNSPEC         (-1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_OK               0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_SHOT             2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_STOLEN           4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_REDIRECT         7</span></code></pre></div><p>在头文件中还提供了一些其他的<code>TC_ACT_*</code>的返回值，也可以用于ingress和egress。但他们语义相同，<code>TC_ACT_OK</code>和<code>TC_ACT_RECLASSIFY</code>的语义相同，<code>TC_ACT_STOLEN</code>、<code>TC_ACT_QUEUED</code>和<code>TC_ACT_TRAP</code>的语义相同。</p><ul><li><p><code>TC_ACT_UNSPEC</code>，表示”unspecified action”，用于以下三种情况：</p><p>i）加载了offload tc BPF，且运行了tc ingress hook，则代表offload tc BPF的<code>cls_bpf</code>将返回<code>TC_ACT_UNSPEC</code></p><p>ii）在<code>cls_bpf</code>包含多个bpf程序的情况下，为了执行下一个bpf程序。这种情况可以与第一点中的offload tc bpf一起使用。执行完offload tc BPF后，再执行下一个非offload的tc BPF。</p><p>iii）在单bpf程序下，表示数据包<code>skb</code>继续进行内核的处理。此时<code>TC_ACT_UNSPEC</code>类似于<code>TC_ACT_OK</code>，都是将<code>skb</code>发送到上层内核协议栈进行进一步处理，或是发送给网络驱动来发出数据包。不同的地方在于<code>TC_ACK_OK</code>会根据tc BPF程序的classid设置<code>skb-&gt;tc_index</code>，而<code>TC_ACT_UNSPEC</code>是在tc BPF程序外，根据BPF ctx中的<code>skb-&gt;tc_classid</code>设置。</p></li><li><p><code>TC_ACT_SHOT</code>表示Drop。<code>TC_ACT_SHOT</code>与<code>TC_ACT_STOLEN</code>相似，但有区别：前者通过<code>kfree_skb()</code>来释放<code>skb</code>，并返回<code>NET_XMIT_DROP</code>。后者通过<code>consume_skb()</code>来释放<code>skb</code>，然后返回<code>NET_XMIT_SUCCESS</code>来假装传输成功。因此监视<code>kfree_skb()</code>的perf不会记录到<code>TC_ACK_STOLEN</code>引起的drop，因为语义上，<code>skb</code>不是”dropped”，而是”consumed”。</p></li><li><p><code>TC_ACT_REDIRECT</code>用于转发，结合<code>bpf_redirect()</code> helper函数，将<code>skb</code>转发到相同的、或是不同的设备的ingress、或是egress。对于转发的目标设备来说，不需要设备上运行BPF或是有其他限制要求，只需要是个网络设备</p></li></ul><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p><strong>作为tc action模块的<code>act_bpf</code>是否可用？</strong></p><p>不常用。虽然<code>act_bpf</code>与<code>cls_bpf</code>对tc BPF来说功能是一样的，但<code>cls_bpf</code>作为<code>act_bpf</code>的超集，使用起来更灵活。tc action需要挂载到某个tc classifiers上，为了和<code>cls_bpf</code>一样，<code>act_bpf</code>需要挂载到<code>cls_matchall</code>的分类器上，这种分类器会匹配任何流量，发送到action中进行处理。这种使用方式性能不如<code>cls_bpf</code>，如果<code>act_bpf</code>使用除<code>cls_bpf</code>和<code>cls_matchall</code>以外的分类器，则会更糟。因为数据包可能需要经过多个分类器后才会被匹配，从而发送给<code>act_bpf</code>处理。因此<code>act_bpf</code>没有太大的使用场景，另外，<code>act_bpf</code>没有实现tc offload的接口。</p></li></ul><ul><li><p><strong>推荐使用<code>cls_bpf</code>的非<code>direct-action</code>模式吗？</strong></p><p>不推荐。主要是考虑复杂处理逻辑的扩展。tc BPF本身已经能够高效地完成各种处理，因此没有必要使用除了<code>direct-action</code>以外的其他action。</p></li></ul><ul><li><p><strong>offload <code>cls_bpf</code>与offload XDP的性能差异</strong></p><p>没有性能差异。两者都是通过内核JIT进行编译，offload到SmartNIC中，加载机制也类似。BPF程序会被转换成相同的目标指令集，以便在NIC上本地运行。两者有不同的特性，可能会为了在offload场景中使用特定的helper函数，而相互替换。</p></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>虽然tc的许多使用场景与XDP是重合的，但是两者大多时候是互补的作用。</p><ul><li><p><strong>容器网络策略的执行</strong></p><p>tc BPF可以用于容器或pod的安全策略、防火墙。通常，容器是使用namespace进行资源隔离，通过veth pair将容器的namespace与宿主机的namespace相连，因此进出的流量都会通过宿主机端的veth，可以在veth设备的ingress hook和egress hook上加载tc BPF，则发送给容器的流量会触发egress，容器发出的流量会触发ingress（注意这里是相反的）。</p><p>对于veth设备使用XDP是不合适的，因为这里内核的操作仅仅是对<code>skb</code>进行的，而XDP会有限制，不能操作克隆的<code>skb</code>。而在TCP/IP协议栈中，为了重传会持有数据片（data segments），使用克隆的<code>skb</code>，这种情况下会直接绕过XDP。其次，XDP处理时需要将<code>skb</code>线性化（linearize，将分页的<code>skb</code>线性化为一个对象），而导致性能下降。tc BPF则是专门用于处理<code>skb</code>的，没有XDP的那些限制。</p></li></ul><ul><li><p><strong>转发或负载均衡</strong></p><p>转发或负载均衡的使用案例和XDP相似，但tc bpf会更倾向于东西向的容器流量，而非南北向流量，虽然两种流量都可以使用XDP和tc。XDP只能作用于ingress，tc则可以作用于egress。例如可以在宿主机上通过BPF对容器的egress流量进行NAT与负载均衡。由于内核网络栈的属性，egress流量是基于<code>sk_buff</code>的，因此tc适合对数据包进行重写或重定向。通过利用<code>bpf_redirect()</code> helper函数，BPF可以将数据包转发到其他设备上，因此也无需使用网桥类的设备。</p></li></ul><ul><li><p><strong>流量的采样与监控</strong></p><p>类似于XDP，采样与监控也是通过一个高性能的、无锁的、per-CPU的内存映射缓冲区实现，tc BPF程序会通过<code>bpf_skb_event_output()</code> helper函数将数据push到缓冲区中，<code>bpf_skb_event_output()</code>功能与<code>bpf_xdp_event_output()</code>是相同的。同样的，tc也能加载到ingress和egress上 ，这样就能监控节点双向的所有流量。这与tcpdump和Wireshark有些类似，但不需要克隆<code>skb</code>，而且更加灵活的处理<code>skb</code>。例如BPF可以在内核里进行聚合，而不是将所有内容都推送到用户空间，或者是推送自定义的注释。在Cilium中使用了大量的自定义注释，用于关联容器标签以及为何需要Drop数据包等，以提供更丰富的信息。</p></li></ul><ul><li><p><strong>数据包调度前的预处理</strong></p><p><code>sch_clsact</code>的egress hook被称为<code>sch_handle_egress()</code>，它在获取qdisc root lock之前调用，因此在数据包进入到真正的例如<code>sch_htb</code>之类的qdisc前，可以通过tc BPF来执行复杂繁重的数据包分类与处理。因为tc BPF的执行是无锁的，通过<code>sch_clsact</code>与真正的qdisc结合使用（比如上面提到的<code>sch_htb</code>），可以提高处理性能。</p></li></ul><p>生产环境的使用案例：Cilium。</p><ul><li>Slides: <a target="_blank" rel="noopener" href="https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp">https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp</a></li><li>Video: <a target="_blank" rel="noopener" href="https://youtu.be/ilKlmTDdFgk">https://youtu.be/ilKlmTDdFgk</a></li><li>Github: <a target="_blank" rel="noopener" href="https://github.com/cilium/cilium">https://github.com/cilium/cilium</a></li></ul><h4 id="驱动支持-1"><a href="#驱动支持-1" class="headerlink" title="驱动支持"></a>驱动支持</h4><p>因为tc BPF是由内核网络协议栈触发的，而非网络驱动触发，因此不依赖与网络驱动。唯一的例外是offload tc BPF。</p><p><strong>支持offload tc BPF的驱动</strong></p><ul><li>Netronome<ul><li>nfp</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JIT技术的介绍：<a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/j-lo-just-in-time/#:~:text=JIT%20%E6%98%AFjust%20in%20time,Java%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E3%80%82&text=%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6JIT%20%E4%BC%9A,%E7%9C%8B%EF%BC%8CJIT%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E3%80%82">深入浅出 JIT 编译器</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104697246">dwarf格式</a></p><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2015/01/22/linker.html">高级语言的编译：链接及装载过程介绍</a></p><p><a target="_blank" rel="noopener" href="http://chuquan.me/2018/05/21/elf-introduce/">计算机那些事(4)——ELF文件结构</a></p><p><a target="_blank" rel="noopener" href="https://linux.cn/article-6073-1.html">为什么人人都该懂点LLVM</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/140462815">LLVM基本概念入门</a></p><p>bbc介绍：<a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md</a><br><a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md">https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md</a></p><p>介绍内核各种track技术的文章：<a target="_blank" rel="noopener" href="https://jvns.ca/blog/2017/07/05/linux-tracing-systems/#kprobes">https://jvns.ca/blog/2017/07/05/linux-tracing-systems/#kprobes</a></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/BPF/">BPF</a></div></div><p class="note note-warning">转载请注明出处</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/2022/08/09/Cilium%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-%E4%B8%80/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Cilium流量分析(一)</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"> <a href="/2021/02/26/Kubernetes-Controller%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-controller-runtime/"><span class="hidden-mobile">Kubernetes Controller开发利器:controller-runtime</span> <span class="visible-mobile">下一篇</span><i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"> <span id="leancloud-site-pv-container" style="display:none">总访问量<span id="leancloud-site-pv"></span> 次</span> <span id="leancloud-site-uv-container" style="display:none">总访客数<span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer="defer">
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2021/03/01/%E7%AC%94%E8%AE%B0-BPF-and-XDP-Reference-Guide-cilium/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'rGBkjlpYFYPq3Mztf0uHkwm2-gzGzoHsz'
    var app_key = 'IwuJ6qbGLXA8pB3qeHHjuDT3'
    var server_url = 'https://rgbkjlpy.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>