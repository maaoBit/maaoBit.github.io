<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="maao"><meta name="keywords" content=""><title>RocksDB中Cuckoo Table技术内幕解析 - MAAO的博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>maao's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"> <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"> <span class="h2" id="subtitle">RocksDB中Cuckoo Table技术内幕解析</span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-08-19 15:08" pubdate>2025年8月19日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.8k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 97 分钟</span><span id="leancloud-post-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i><span id="leancloud-post-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">RocksDB中Cuckoo Table技术内幕解析</h1><div class="markdown-body" id="post-body"><p>Cuckoo-Table作为RocksDB里的一种SST文件格式，具有高吞吐量的随机点查找 (point lookups)能力，本文详细介绍了Cuckoo-Table的实现细节。</p><a id="more"></a><h2 id="一、-Cuckoo-Table-概述：一种为点查找优化的-SST-文件格式"><a href="#一、-Cuckoo-Table-概述：一种为点查找优化的-SST-文件格式" class="headerlink" title="一、 Cuckoo Table 概述：一种为点查找优化的 SST 文件格式"></a>一、 Cuckoo Table 概述：一种为点查找优化的 SST 文件格式</h2><p>在深入代码细节之前，我们首先需要理解 Cuckoo Table 在 RocksDB 生态系统中的位置和它的设计目标。</p><h3 id="1-1-RocksDB-的可插拔表格式-Pluggable-Table-Format-架构"><a href="#1-1-RocksDB-的可插拔表格式-Pluggable-Table-Format-架构" class="headerlink" title="1.1 RocksDB 的可插拔表格式 (Pluggable Table Format) 架构"></a>1.1 RocksDB 的可插拔表格式 (Pluggable Table Format) 架构</h3><p>RocksDB 的一个强大特性是其高度模块化和可插拔的架构。SST (Sorted String Table) 文件的物理布局并非一成不变，而是由一个称为 <code>TableFactory</code> 的抽象工厂来定义的。这意味着开发者可以根据不同的工作负载，选择甚至开发不同的表格式实现，以达到最优的性能。</p><p>RocksDB 允许在数据库级别，甚至是列族 (Column Family) 级别指定不同的 <code>TableFactory</code>。这为精细化的性能调优提供了极大的灵活性。Cuckoo Table 正是 RocksDB 提供的、一种高度特化的表格式实现。</p><h3 id="1-2-Cuckoo-Table-的定位与适用场景"><a href="#1-2-Cuckoo-Table-的定位与适用场景" class="headerlink" title="1.2 Cuckoo Table 的定位与适用场景"></a>1.2 Cuckoo Table 的定位与适用场景</h3><p>Cuckoo Table 的设计目标非常明确：为<strong>高吞吐量的随机点查找 (point lookups)</strong> 提供极致的性能。它基于布谷鸟哈希算法，能够以近乎 O(1) 的时间复杂度完成键查找。</p><p>为了达到这个目标，它建立在一些严格的假设和约束之上：</p><ul><li> **键和值必须是定长的 (Fixed Length)**：这是其数据布局的基础。</li><li> <strong>不支持 Merge 操作</strong>：它的结构不适合处理需要合并的写操作。</li><li> **不支持前缀布隆过滤器 (Prefix Bloom Filter)**：它的哈希基于完整的用户键 (<code>user_key</code>)。</li><li> <strong>范围扫描性能较差</strong>：由于键是按哈希值散乱分布的，范围扫描的效率远低于默认的 <code>BlockBasedTable</code>。</li></ul><p>因此，Cuckoo Table 的理想使用场景是：当你的业务主要是通过 <code>Get()</code> API 进行大量、快速的随机键查询，且很少或几乎没有范围扫描 (<code>Iterator</code>) 需求时，例如用作某些索引或元数据的存储。</p><h3 id="1-3-Cuckoo-Table-与默认-Block-Based-Table-的核心区别"><a href="#1-3-Cuckoo-Table-与默认-Block-Based-Table-的核心区别" class="headerlink" title="1.3 Cuckoo Table 与默认 Block-Based Table 的核心区别"></a>1.3 Cuckoo Table 与默认 Block-Based Table 的核心区别</h3><p>为了更清晰地理解其定位，我们可以将它与 RocksDB 默认的 <code>BlockBasedTable</code> 格式进行对比。</p><table><thead><tr><th align="left">特性</th><th align="left">Cuckoo Table</th><th align="left">Block-Based Table (默认)</th></tr></thead><tbody><tr><td align="left"><strong>核心数据结构</strong></td><td align="left">哈希表 (Hash Table)</td><td align="left">B-Tree (通过索引块和数据块模拟)</td></tr><tr><td align="left"><strong>点查找机制</strong></td><td align="left">直接哈希计算内存地址，近 O(1)</td><td align="left">查找索引块 (1-2次 I/O)，再读取数据块 (1次 I/O)</td></tr><tr><td align="left"><strong>范围扫描机制</strong></td><td align="left">昂贵 (首次需全量读取并排序)</td><td align="left">高效 (按序迭代数据块)</td></tr><tr><td align="left"><strong>键/值长度</strong></td><td align="left">必须是定长</td><td align="left">可变长</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">专用于高速点查找</td><td align="left">通用场景，点查找和范围扫描性能均衡</td></tr></tbody></table><h2 id="二、-CuckooTableFactory：配置中心与构造工厂"><a href="#二、-CuckooTableFactory：配置中心与构造工厂" class="headerlink" title="二、 CuckooTableFactory：配置中心与构造工厂"></a>二、 CuckooTableFactory：配置中心与构造工厂</h2><p><code>CuckooTableFactory</code> 是使用 Cuckoo Table 的入口。它遵循工厂设计模式，作为连接 RocksDB 内核与 Cuckoo Table 具体实现的桥梁。</p><h3 id="2-1-Factory-的核心职责与设计模式"><a href="#2-1-Factory-的核心职责与设计模式" class="headerlink" title="2.1 Factory 的核心职责与设计模式"></a>2.1 Factory 的核心职责与设计模式</h3><p><code>CuckooTableFactory</code> 继承自 <code>rocksdb::TableFactory</code>，其核心职责有二：</p><ol><li> <strong>持有配置</strong>：保存用户为 Cuckoo Table 指定的所有配置项 (<code>CuckooTableOptions</code>)。</li><li> <strong>创建实例</strong>：当 RocksDB 需要创建或读取 SST 文件时，调用工厂的 <code>NewTableBuilder</code> 或 <code>NewTableReader</code> 方法，来生产出配置正确的具体实例。</li></ol><h3 id="2-2-CuckooTableOptions：定制你的-Cuckoo-Table"><a href="#2-2-CuckooTableOptions：定制你的-Cuckoo-Table" class="headerlink" title="2.2 CuckooTableOptions：定制你的 Cuckoo Table"></a>2.2 CuckooTableOptions：定制你的 Cuckoo Table</h3><p>用户通过 <code>CuckooTableOptions</code> 结构体来定制 Cuckoo Table 的行为。</p><p><strong>代码 (<code>rocksdb/table.h</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CuckooTableOptions</span> &#123;</span>
  <span class="hljs-comment">// Determines the space utilization of the hash table.</span>
  <span class="hljs-comment">// Smaller values result in more space being used but fewer collisions.</span>
  <span class="hljs-keyword">double</span> hash_table_ratio = <span class="hljs-number">0.9</span>;

  <span class="hljs-comment">// Maximum number of Cuckoo hash functions.</span>
  <span class="hljs-keyword">uint32_t</span> max_search_depth = <span class="hljs-number">100</span>;

  <span class="hljs-comment">// In case of collision, Cuckoo hash will attempt to kick out an element</span>
  <span class="hljs-comment">// to other locations. This defines the block size that will be searched</span>
  <span class="hljs-comment">// within Cuckoo hash.</span>
  <span class="hljs-keyword">uint32_t</span> cuckoo_block_size = <span class="hljs-number">5</span>;

  <span class="hljs-comment">// If this option is enabled, user key is treated as uint64_t and its value</span>
  <span class="hljs-comment">// is used as hash value. This option is valid only when user key is 8 bytes.</span>
  <span class="hljs-keyword">bool</span> identity_as_first_hash = <span class="hljs-literal">false</span>;

  <span class="hljs-comment">// If this option is set to true, module hashing will be used to calculate</span>
  <span class="hljs-comment">// hash values. Otherwise, bit-masking will be used.</span>
  <span class="hljs-keyword">bool</span> use_module_hash = <span class="hljs-literal">true</span>;
&#125;;</code></pre></div><ul><li> <code>hash_table_ratio</code>: 哈希表空间利用率。值越小，哈希表越大，冲突越少，但空间浪费越多。</li><li> <code>max_search_depth</code>: 解决哈希冲突时，”踢出”路径的最大搜索深度，防止无限循环。</li><li> <code>cuckoo_block_size</code>: Cuckoo 块大小。这是一个优化，当哈希到一个位置时，会线性探测一个大小为 <code>cuckoo_block_size</code> 的区域，可以有效减少冲突。</li><li> <code>identity_as_first_hash</code>: 一个性能优化。当键本身就是 8 字节的整数时，可以直接将其值作为第一个哈希值，避免计算开销。</li></ul><h3 id="2-3-核心算法：CuckooHash-函数深度解析"><a href="#2-3-核心算法：CuckooHash-函数深度解析" class="headerlink" title="2.3 核心算法：CuckooHash 函数深度解析"></a>2.3 核心算法：CuckooHash 函数深度解析</h3><p><code>CuckooHash</code> 函数是整个 Cuckoo Table 功能的数学基础，它负责为同一个键生成多个不同的哈希位置。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_factory.h</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">CuckooHash</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> Slice&amp; user_key, <span class="hljs-keyword">uint32_t</span> hash_cnt, <span class="hljs-keyword">bool</span> use_module_hash,</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">uint64_t</span> table_size_, <span class="hljs-keyword">bool</span> identity_as_first_hash,</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">uint64_t</span> (*get_slice_hash)(<span class="hljs-keyword">const</span> Slice&amp;, <span class="hljs-keyword">uint32_t</span>, <span class="hljs-keyword">uint64_t</span>))</span> </span>&#123;
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined NDEBUG || defined OS_WIN</span>
  <span class="hljs-keyword">if</span> (get_slice_hash != <span class="hljs-literal">nullptr</span>) &#123;
    <span class="hljs-keyword">return</span> get_slice_hash(user_key, hash_cnt, table_size_);
  &#125;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
  (<span class="hljs-keyword">void</span>)get_slice_hash;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

  <span class="hljs-keyword">uint64_t</span> value = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (hash_cnt == <span class="hljs-number">0</span> &amp;&amp; identity_as_first_hash) &#123;
    value = (*<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span>*&gt;(user_key.data()));
  &#125; <span class="hljs-keyword">else</span> &#123;
    value = MurmurHash(user_key.data(), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(user_key.size()),
                       kCuckooMurmurSeedMultiplier * hash_cnt);
  &#125;
  <span class="hljs-keyword">if</span> (use_module_hash) &#123;
    <span class="hljs-keyword">return</span> value % table_size_;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">return</span> value &amp; (table_size_ - <span class="hljs-number">1</span>);
  &#125;
&#125;</code></pre></div><h4 id="2-3-1-多哈希函数与种子"><a href="#2-3-1-多哈希函数与种子" class="headerlink" title="2.3.1 多哈希函数与种子"></a>2.3.1 多哈希函数与种子</h4><p>布谷鸟哈希需要为同一个键计算多个哈希值。这里的实现非常巧妙：它使用同一个 <code>MurmurHash</code> 算法，但通过传入不同的种子 (seed) 来达到目的。种子是由 <code>kCuckooMurmurSeedMultiplier * hash_cnt</code> 计算得来的。<code>hash_cnt</code> 从 0 开始递增，从而为同一个 <code>user_key</code> 生成一个哈希值序列。</p><h4 id="2-3-2-Identity-as-first-hash-优化"><a href="#2-3-2-Identity-as-first-hash-优化" class="headerlink" title="2.3.2 Identity-as-first-hash 优化"></a>2.3.2 Identity-as-first-hash 优化</h4><p><code>if (hash_cnt == 0 &amp;&amp; ...)</code> 这段代码是一个性能捷径。当此选项开启，且键的长度为 8 字节时，第一个哈希函数 (<code>hash_cnt == 0</code>) 不会执行 <code>MurmurHash</code>，而是直接将键的 8 个字节内容重新解释 (reinterpret_cast) 为一个 <code>int64_t</code> 作为哈希值。对于本身就是数字类型的键，这极大地提升了哈希计算的速度。</p><h4 id="2-3-3-范围映射：位运算与取模"><a href="#2-3-3-范围映射：位运算与取模" class="headerlink" title="2.3.3 范围映射：位运算与取模"></a>2.3.3 范围映射：位运算与取模</h4><p><code>if (use_module_hash)</code> 分支决定了如何将 64 位的哈希值映射到 <code>[0, table_size_ - 1]</code> 的桶索引范围。</p><ul><li> <code>value % table_size_</code>: 取模运算，通用但性能稍慢。</li><li> <code>value &amp; (table_size_ - 1)</code>: 按位与运算。当 <code>table_size_</code> 是 2 的整数次幂时，这个操作与取模等价，但速度快得多。<code>CuckooTableBuilder</code> 在 <code>use_module_hash</code> 为 <code>false</code> 时会确保 <code>table_size_</code> 满足此条件。</li></ul><h3 id="2-4-创建-Builder-和-Reader-实例"><a href="#2-4-创建-Builder-和-Reader-实例" class="headerlink" title="2.4 创建 Builder 和 Reader 实例"></a>2.4 创建 Builder 和 Reader 实例</h3><p>这两个方法是 <code>TableFactory</code> 接口的核心实现，负责“生产”具体的读写工具。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_factory.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">TableBuilder* <span class="hljs-title">CuckooTableFactory::NewTableBuilder</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> TableBuilderOptions&amp; table_builder_options,</span></span>
<span class="hljs-function"><span class="hljs-params">    WritableFileWriter* file)</span> <span class="hljs-keyword">const</span> </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CuckooTableBuilder(
      file, table_options_.hash_table_ratio, <span class="hljs-number">64</span>,
      table_options_.max_search_depth,
      table_builder_options.internal_comparator.user_comparator(),
      table_options_.cuckoo_block_size, table_options_.use_module_hash,
      table_options_.identity_as_first_hash, <span class="hljs-literal">nullptr</span> <span class="hljs-comment">/* get_slice_hash */</span>,
      table_builder_options.column_family_id,
      table_builder_options.column_family_name, table_builder_options.db_id,
      table_builder_options.db_session_id, table_builder_options.cur_file_num);
&#125;

<span class="hljs-function">Status <span class="hljs-title">CuckooTableFactory::NewTableReader</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> ReadOptions&amp; <span class="hljs-comment">/*ro*/</span>, <span class="hljs-keyword">const</span> TableReaderOptions&amp; table_reader_options,</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;RandomAccessFileReader&gt;&amp;&amp; file, <span class="hljs-keyword">uint64_t</span> file_size,</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TableReader&gt;* table,</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">bool</span> <span class="hljs-comment">/*prefetch_index_and_filter_in_cache*/</span>)</span> <span class="hljs-keyword">const</span> </span>&#123;
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;CuckooTableReader&gt; <span class="hljs-title">new_reader</span><span class="hljs-params">(<span class="hljs-keyword">new</span> CuckooTableReader(</span></span>
<span class="hljs-function"><span class="hljs-params">      table_reader_options.ioptions, <span class="hljs-built_in">std</span>::move(file), file_size,</span></span>
<span class="hljs-function"><span class="hljs-params">      table_reader_options.internal_comparator.user_comparator(), <span class="hljs-literal">nullptr</span>))</span></span>;
  Status s = new_reader-&gt;status();
  <span class="hljs-keyword">if</span> (s.ok()) &#123;
    *table = <span class="hljs-built_in">std</span>::move(new_reader);
  &#125;
  <span class="hljs-keyword">return</span> s;
&#125;</code></pre></div><ul><li> <strong><code>NewTableBuilder</code></strong>: 当 RocksDB 需要创建 Cuckoo Table 格式的 SST 文件时调用此方法。它会实例化一个 <code>CuckooTableBuilder</code>，并将工厂自身存储的 <code>table_options_</code> 配置以及 RocksDB 核心传入的通用参数（如文件句柄、比较器等）一并传给 <code>Builder</code> 的构造函数。</li><li> <strong><code>NewTableReader</code></strong>: 当 RocksDB 需要读取一个 Cuckoo Table 格式的 SST 文件时调用此方法。它会实例化一个 <code>CuckooTableReader</code>，并将文件句柄、文件大小等信息传递给 <code>Reader</code> 的构造函数，以便 <code>Reader</code> 进行初始化。</li></ul><h2 id="三、-CuckooTableBuilder：从零到一构建哈希表"><a href="#三、-CuckooTableBuilder：从零到一构建哈希表" class="headerlink" title="三、 CuckooTableBuilder：从零到一构建哈希表"></a>三、 CuckooTableBuilder：从零到一构建哈希表</h2><p><code>CuckooTableBuilder</code> 负责将无序的键值对集合转换成一个结构紧凑、查询高效的 Cuckoo Table SST 文件。其过程可以概括为“收集 -&gt; 构建 -&gt; 写入”。</p><h3 id="3-1-Builder-的核心流程：收集-gt-构建-gt-写入"><a href="#3-1-Builder-的核心流程：收集-gt-构建-gt-写入" class="headerlink" title="3.1 Builder 的核心流程：收集 -&gt; 构建 -&gt; 写入"></a>3.1 Builder 的核心流程：收集 -&gt; 构建 -&gt; 写入</h3><ol><li> <strong>收集 (Collect)</strong>: 在 <code>Add()</code> 方法被调用时，<code>Builder</code> 并不立即构建哈希表。它首先进行约束验证（如键值是否定长），然后将所有键值对线性地追加到内存中的 <code>kvs_</code> 和 <code>deleted_keys_</code> 两个字符串缓冲区内。</li><li> <strong>构建 (Build)</strong>: 当 <code>Finish()</code> 方法被调用时，真正的构建工作开始。<code>Builder</code> 会在内存中创建一个 <code>std::vector&lt;CuckooBucket&gt;</code> 来代表哈希表。它会遍历所有收集到的键，通过 <code>MakeHashTable()</code> 方法将它们逐一安置到 <code>CuckooBucket</code> 向量中，并在此过程中解决所有哈希冲突。</li><li> <strong>写入 (Write)</strong>: 内存中的哈希表布局一旦确定，<code>Finish()</code> 方法就会遍历 <code>CuckooBucket</code> 向量，将每个桶的内容（真实的键值对或空桶占位符）按顺序写入文件。最后，附上包含所有元数据的属性块和文件尾部，完成 SST 文件的创建。</li></ol><h3 id="3-2-关键数据结构：CuckooBucket-的巧妙设计"><a href="#3-2-关键数据结构：CuckooBucket-的巧妙设计" class="headerlink" title="3.2 关键数据结构：CuckooBucket 的巧妙设计"></a>3.2 关键数据结构：CuckooBucket 的巧妙设计</h3><p><code>CuckooBucket</code> 是构建过程中哈希桶在内存中的临时表达，其设计的核心是效率。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_builder.h</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CuckooBucket</span> &#123;</span>
    CuckooBucket() : vector_idx(kMaxVectorIdx), make_space_for_key_call_id(<span class="hljs-number">0</span>) &#123;&#125;
    <span class="hljs-keyword">uint32_t</span> vector_idx;
    <span class="hljs-keyword">uint32_t</span> make_space_for_key_call_id;
  &#125;;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> kMaxVectorIdx = <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">int32_t</span>&gt;::max();</code></pre></div><h4 id="3-2-1-vector-idx：轻量级数据指针"><a href="#3-2-1-vector-idx：轻量级数据指针" class="headerlink" title="3.2.1 vector_idx：轻量级数据指针"></a>3.2.1 vector_idx：轻量级数据指针</h4><p>该字段是一个 <code>uint32_t</code> 索引，指向键值对在 <code>kvs_</code> 或 <code>deleted_keys_</code> 字符串缓冲区中的位置。这种“指针”而非“实体”的设计极大地节省了内存。一个特殊值 <code>kMaxVectorIdx</code> 被用来标记这是一个空桶。</p><h4 id="3-2-2-make-space-for-key-call-id：无重置的“已访问”标记"><a href="#3-2-2-make-space-for-key-call-id：无重置的“已访问”标记" class="headerlink" title="3.2.2 make_space_for_key_call_id：无重置的“已访问”标记"></a>3.2.2 make_space_for_key_call_id：无重置的“已访问”标记</h4><p>在 <code>MakeSpaceForKey</code> 的 BFS 搜索中，需要标记已访问的节点以防循环。常规的 <code>bool visited</code> 标志需要在每次搜索前重置整个哈希表，代价高昂。此字段通过一个不断递增的“调用ID”来解决这个问题。每次搜索都有一个唯一的ID，一个桶只有其 <code>make_space_for_key_call_id</code> 与当前搜索的ID相同时，才被认为是“已访问”。这巧妙地避免了重置操作，是重要的性能优化。具体的：</p><ul><li><p><code>CuckooTableBuilder</code> 内部维护一个从 0 开始的计数器 <code>make_space_for_key_call_id</code>。</p></li><li><p>每次调用 MakeSpaceForKey 时, 这个计数器会 ++, 得到一个本次调用独一无二的 ID.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// in cuckoo_table_builder.cc</span>
<span class="hljs-comment">// 在 MakeHashTable 的循环中</span>
<span class="hljs-keyword">while</span> (!bucket_found &amp;&amp;
    !MakeSpaceForKey(hash_vals, ++make_space_for_key_call_id, buckets,
     &amp;bucket_id)) &#123;
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div></li><li><p>在 <code>MakeSpaceForKey</code> 的 BFS 搜索中, 当访问一个桶时, 它会把这个桶的 <code>make_space_for_key_call_id</code> 字段设置为当前调用的ID.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// in cuckoo_table_builder.cc:</span>
<span class="hljs-comment">// 在 MakeSpaceForKey 的 BFS 探索中</span>
(*buckets)[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(child_bucket_id)]
  .make_space_for_key_call_id = make_space_for_key_call_id;</code></pre></div></li><li><p>在检查一个桶是否”已访问”时, 它不再检查 bool 值, 而是比较桶的 make_space_for_key_call_id 是否等于当前调用的ID.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// in cuckoo_table_builder.cc`):</span>
<span class="hljs-keyword">if</span> ((*buckets)[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(child_bucket_id)]
        .make_space_for_key_call_id == make_space_for_key_call_id) &#123;
    <span class="hljs-comment">// 已在本次搜索中访问过, 跳过</span>
  <span class="hljs-keyword">continue</span>;
&#125;</code></pre></div></li></ul><h3 id="3-3-Add-方法：数据收集与约束验证"><a href="#3-3-Add-方法：数据收集与约束验证" class="headerlink" title="3.3 Add() 方法：数据收集与约束验证"></a>3.3 Add() 方法：数据收集与约束验证</h3><p><code>Add()</code> 方法是数据流入 <code>Builder</code> 的入口，负责验证和暂存。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_builder.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CuckooTableBuilder::Add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slice&amp; key, <span class="hljs-keyword">const</span> Slice&amp; value)</span> </span>&#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">if</span> (!has_seen_first_key_) &#123;
    is_last_level_file_ = ikey.sequence == <span class="hljs-number">0</span>;
    has_seen_first_key_ = <span class="hljs-literal">true</span>;
    <span class="hljs-comment">// ...</span>
    key_size_ = is_last_level_file_ ? ikey.user_key.size() : key.size();
  &#125;
  <span class="hljs-keyword">if</span> (key_size_ != (is_last_level_file_ ? ikey.user_key.size() : key.size())) &#123;
    status_ = Status::NotSupported(<span class="hljs-string">&quot;all keys have to be the same size&quot;</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-comment">// ... (similar check for value_size_)</span>

  <span class="hljs-keyword">if</span> (ikey.type == kTypeValue) &#123;
    kvs_.append(is_last_level_file_ ? ikey.user_key.data() : key.data(),
                is_last_level_file_ ? ikey.user_key.size() : key.size());
    kvs_.append(value.data(), value.size());
    <span class="hljs-comment">// ...</span>
  &#125;
  <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><h4 id="3-3-1-键值定长：Cuckoo-Table-的硬性要求"><a href="#3-3-1-键值定长：Cuckoo-Table-的硬性要求" class="headerlink" title="3.3.1 键值定长：Cuckoo Table 的硬性要求"></a>3.3.1 键值定长：Cuckoo Table 的硬性要求</h4><p>代码中的 <code>if (!has_seen_first_key_)</code> 块会在添加第一个键时执行，捕获其键长和值长。后续所有 <code>Add()</code> 调用都会检查新的键值是否与第一次的长度严格相等。这是因为最终的 SST 文件是一个由定长桶组成的连续数组，<code>Reader</code> 需要依赖这个定长来计算偏移量。</p><h4 id="3-3-2-LSM-Tree-Level-判断与序列号剥离优化"><a href="#3-3-2-LSM-Tree-Level-判断与序列号剥离优化" class="headerlink" title="3.3.2 LSM-Tree Level 判断与序列号剥离优化"></a>3.3.2 LSM-Tree Level 判断与序列号剥离优化</h4><p><code>is_last_level_file_ = ikey.sequence == 0;</code> 这一行代码是一个关键优化。在 RocksDB 中，只有当一个键在整个数据库中是最新版本时（即所有旧版本已被合并，且上层没有新版本），其序列号才可能在Compaction到最底层时被“剥离”为0。因此，<code>sequence == 0</code> 是一个强烈的信号，表明这个文件将被放在 LSM-Tree 的最底层。在这种情况下，<code>user_key</code> 在该层是唯一的，<code>Builder</code> 便可以只存储 <code>user_key</code> 而非完整的 <code>InternalKey</code>，为每个键节省8字节。</p><blockquote><p>为什么<code>sequence == 0</code>能表明这个文件在LSM-Tree的最底层？为什么<code>user_key</code> 在该层是唯一的</p><ol><li><p>基础: Sequence Number (序列号) 的作用</p><p>首先, 我们要理解 Sequence Number (后文简称 seq) 是什么.<br>在 RocksDB 中, 每一次写入操作 (Put, Delete, Merge) 都会被分配一个全局唯一、单调递增的 seq. 它就像这次操作的”时间戳”或”版本号”. seq 的核心作用是实现多版本并发控制 (MVCC),也就是让不同时间的读请求能看到不同版本的数据快照.</p><p>例如:</p></li><li><p>Put(“mykey”, “v1”) -&gt; 分配 seq=100</p></li><li><p>Put(“mykey”, “v2”) -&gt; 分配 seq=101</p></li><li><p>Delete(“mykey”) -&gt; 分配 seq=102</p><p>在 RocksDB 内部, 这三个操作对应三个不同的 InternalKey: mykey@100, mykey@101, mykey@102. 即使它们的 user_key (“mykey”) 相同, 但因为 seq 不同, 它们是三个独立的条目.</p></li><li><p>解答: 为什么最底层的 user_key 是唯一的?</p><p>这归功于 Compaction (合并) 机制.</p><p>LSM-Tree 的数据是从高层 (Level 0, L0) 向底层 (Level 1, L2, …, Lmax) 不断合并的. Compaction 的一个核心任务就是清理冗余数据.</p></li></ol><ul><li><p>在高层 (如 L0, L1): 一个 user_key 可能存在多个版本. 比如 L0 中可能同时存在 mykey@100 和 mykey@101. 这是因为 L0 的文件是 MemTable 直接 Flush 下来的,可能包含重叠的键范围和多个版本.</p></li><li><p>合并过程中的版本选择: 当 RocksDB 将 L_N 层的文件和 L_{N+1} 层的文件进行合并时, 对于任何一个相同的 user_key, 它只会保留<code>seq</code> 最高 (也就是最新) 的那一个版本,而所有旧版本都会被丢弃.</p></li><li><p>到达最底层 (Last Level): “最底层” (我们称之为 Lmax) 是数据的最终归宿. 当数据经过一层又一层的 Compaction 到达 Lmax 时, 所有关于同一个 user_key的历史版本都已经被处理掉了. 因此, 在 Lmax 这一层的所有 SST 文件中, 任意一个 <code>user_key</code> 最多只会存在一个条目. 如果这个 user_key 有一个更新的版本,那么这个新版本必然存在于比 Lmax 更高的层级 (L0 到 L_{max-1}).</p><p>结论: Compaction 机制保证了在最底层的数据集合中, <code>user_key</code> 是唯一的.</p></li></ul><ol start="3"><li><p>为什么 ikey.sequence == 0 能假定在最底层?</p><p>这是基于上述结论的一个非常重要的优化.</p><p>既然我们知道了在最底层, user_key 是唯一的, 那么版本号 (seq) 对于区分 user_key 的多个版本来说, 就失去了意义. 它的存在只是为了和上层可能存在的新版本进行比较.</p><p>RocksDB 在执行到最底层的 Compaction 时, 会进行一个特殊的检查:</p><p>对于一个即将被写入最底层 Lmax 的键 user_key (假设其版本为 seq=S), RocksDB 会检查所有上层 (L0 到 L_{max-1}) 是否存在任何版本比 <code>S</code> 更新的 <code>user_key</code>.</p></li></ol><ul><li><p>情况A: 存在更新的版本. 如果上层有一个 mykey@S_newer (其中 S_newer &gt; S), 那么写入 Lmax 的这个键必须保留它原始的 seq=S, 以便未来的读请求能正确地选择上层的最新版本.</p></li><li><p>情况B: 不存在任何更新的版本. 如果检查发现所有上层都没有 mykey 的踪影, 这意味着当前要写入 Lmax 的这个版本就是整个数据库中最新的、最权威的版本. 在这种情况下, seq<br>对于版本控制来说是多余的. 为了节省空间 (每个 seq 占用 7 个字节), RocksDB 会执行一个”序列号剥离” (Sequence Number Stripping) 的优化: 直接将 <code>seq</code> 设置为 0.</p><p>所以, 逻辑链是这样的:</p></li></ul><ol><li><p>只有在 Compaction 到最底层时, 才有可能触发 “序列号剥离” 优化.</p></li><li><p>只有当一个键在整个数据库中没有更老的版本(已被清理)也没有更新的版本(不存在于上层)时, 它的 seq 才会被置为 0.</p></li><li><p>因此, 当 CuckooTableBuilder 在 Add() 方法中看到一个键的 ikey.sequence == 0 时, 它可以做出一个非常可靠的推断: 这个键是经过了上述优化处理的.产生这种键的唯一途径就是一次到最底层的 Compaction (或者用户通过特殊接口直接Ingest文件到最底层).</p></li><li><p>既然文件中的一个键来自最底层, 那么可以合理地假定整个 SST 文件都是为最底层构建的.</p><p>这就是为什么一行简单的 is_last_level_file_ = ikey.sequence == 0; 背后蕴含了对整个 LSM-Tree Compaction 和版本管理机制的深刻理解. 这个判断使得 Cuckoo Table可以为最底层文件进行特殊优化, 即直接存储 user_key (因为唯一), 而不是存储完整的 InternalKey, 从而节省了 8 字节/每条记录 的空间.</p></li></ol></blockquote><h3 id="3-4-Finish-方法：将内存布局写入文件"><a href="#3-4-Finish-方法：将内存布局写入文件" class="headerlink" title="3.4 Finish() 方法：将内存布局写入文件"></a>3.4 Finish() 方法：将内存布局写入文件</h3><p><code>Finish()</code> 是将内存中的理想布局物化为物理文件的过程。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_builder.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">CuckooTableBuilder::Finish</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-comment">// ...</span>
  status_ = MakeHashTable(&amp;buckets);
  <span class="hljs-comment">// ...</span>
  <span class="hljs-comment">// Determine unused_user_key to fill empty buckets.</span>
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// Write the table.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; bucket : buckets) &#123;
    <span class="hljs-keyword">if</span> (bucket.vector_idx == kMaxVectorIdx) &#123;
      io_status_ = file_-&gt;Append(opts, Slice(unused_bucket));
    &#125; <span class="hljs-keyword">else</span> &#123;
      io_status_ = file_-&gt;Append(opts, GetKey(bucket.vector_idx));
      <span class="hljs-keyword">if</span> (io_status_.ok() &amp;&amp; value_size_ &gt; <span class="hljs-number">0</span>) &#123;
          io_status_ = file_-&gt;Append(opts, GetValue(bucket.vector_idx));
      &#125;
    &#125;
    <span class="hljs-comment">// ...</span>
  &#125;

  <span class="hljs-comment">// Write meta blocks.</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> status_;
&#125;</code></pre></div><p>该方法首先调用 <code>MakeHashTable()</code> 完成内存布局。然后，它会生成一个保证不存在的 <code>unused_bucket</code> 作为空位占位符。接着，它遍历 <code>buckets</code> 向量，如果桶是空的 (<code>vector_idx == kMaxVectorIdx</code>)，就写入占位符；否则，就通过 <code>GetKey()</code> 和 <code>GetValue()</code> 从缓冲区取出真实的键值对写入文件。最后，写入包含所有布局参数的属性块和文件尾部。</p><h3 id="3-5-MakeHashTable-：哈希放置调度"><a href="#3-5-MakeHashTable-：哈希放置调度" class="headerlink" title="3.5 MakeHashTable()：哈希放置调度"></a>3.5 MakeHashTable()：哈希放置调度</h3><p>此函数是放置所有键的调度中心，它为 <code>Add()</code> 收集的每个键寻找一个“家”。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_builder.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">CuckooTableBuilder::MakeHashTable</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;CuckooBucket&gt;* buckets)</span> </span>&#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> vector_idx = <span class="hljs-number">0</span>; vector_idx &lt; num_entries_; vector_idx++) &#123;
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 1. 尝试直接放置</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> hash_cnt = <span class="hljs-number">0</span>; hash_cnt &lt; num_hash_func_ &amp;&amp; !bucket_found; ++hash_cnt) &#123;
      <span class="hljs-comment">// ... 遍历 Cuckoo Block 寻找空位</span>
    &#125;

    <span class="hljs-comment">// 2. 处理冲突</span>
    <span class="hljs-keyword">while</span> (!bucket_found &amp;&amp;
           !MakeSpaceForKey(hash_vals, ++make_space_for_key_call_id, buckets,
                            &amp;bucket_id)) &#123;
      <span class="hljs-comment">// 3. 增加哈希函数作为最后手段</span>
      <span class="hljs-comment">// ...</span>
    &#125;

    <span class="hljs-comment">// 4. 最终放置</span>
    (*buckets)[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(bucket_id)].vector_idx = vector_idx;
  &#125;
  <span class="hljs-keyword">return</span> Status::OK();
&#125;</code></pre></div><p>它的策略是：对每个键，首先尝试最廉价的操作——直接在它的所有哈希位置（包括Cuckoo Block）中寻找空位。如果失败，则进入 <code>while</code> 循环，调用昂贵的 <code>MakeSpaceForKey()</code> 尝试“踢出”其他键。如果连“踢出”都失败了，它会采取最后的手段：为当前键增加一个新的哈希函数，赋予它一个全新的位置选择，然后再次尝试。一旦找到位置，就将键的索引 <code>vector_idx</code> 记录到目标桶中。</p><h3 id="3-6-MakeSpaceForKey-：布谷鸟“踢出”算法的精髓"><a href="#3-6-MakeSpaceForKey-：布谷鸟“踢出”算法的精髓" class="headerlink" title="3.6 MakeSpaceForKey()：布谷鸟“踢出”算法的精髓"></a>3.6 MakeSpaceForKey()：布谷鸟“踢出”算法的精髓</h3><p>这是 Cuckoo Hash 最核心、最有趣的算法，用于在没有空位时，通过移动现有元素来创造空间。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_builder.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CuckooTableBuilder::MakeSpaceForKey</span><span class="hljs-params">(</span></span>
<span class="hljs-function"><span class="hljs-params">    <span class="hljs-comment">/* ... */</span>)</span> </span>&#123;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CuckooNode</span> &#123;</span> <span class="hljs-comment">/* ... */</span> &#125;;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;CuckooNode&gt; tree;
  <span class="hljs-comment">// ... BFS 搜索逻辑 ...</span>
  <span class="hljs-keyword">while</span> (!null_found &amp;&amp; curr_pos &lt; tree.size()) &#123;
    <span class="hljs-comment">// ... 扩展节点，寻找空位 ...</span>
  &#125;

  <span class="hljs-keyword">if</span> (null_found) &#123;
    <span class="hljs-comment">// 路径找到，反向遍历 tree 进行“踢出”</span>
    <span class="hljs-keyword">uint32_t</span> bucket_to_replace_pos = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(tree.size()) - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (bucket_to_replace_pos &gt;= num_hash_func_) &#123;
      CuckooNode&amp; curr_node = tree[bucket_to_replace_pos];
      (*buckets)[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(curr_node.bucket_id)] =
          (*buckets)[<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(tree[curr_node.parent_pos].bucket_id)];
      bucket_to_replace_pos = curr_node.parent_pos;
    &#125;
    *bucket_id = tree[bucket_to_replace_pos].bucket_id;
  &#125;
  <span class="hljs-keyword">return</span> null_found;
&#125;</code></pre></div><h4 id="3-6-1-BFS-搜索树的构建与可视化"><a href="#3-6-1-BFS-搜索树的构建与可视化" class="headerlink" title="3.6.1 BFS 搜索树的构建与可视化"></a>3.6.1 BFS 搜索树的构建与可视化</h4><p>该函数通过广度优先搜索（BFS）寻找一条从某个被占用的桶到某个空桶的路径。它使用一个 <code>std::vector&lt;CuckooNode&gt; tree</code> 来模拟搜索树。树的根节点是当前要插入的键的所有候选位置。然后，它逐层扩展：对于树中的一个节点（代表一个被占用的桶），它会查找桶中那个键的备用位置，并将这些备用位置作为子节点加入树中，直到找到一个空桶为止。</p><h4 id="3-6-2-“踢出”路径的查找与替换逻辑"><a href="#3-6-2-“踢出”路径的查找与替换逻辑" class="headerlink" title="3.6.2 “踢出”路径的查找与替换逻辑"></a>3.6.2 “踢出”路径的查找与替换逻辑</h4><p>一旦 BFS 找到一个空桶，<code>if (null_found)</code> 块内的逻辑就会被触发。这里的 <code>while</code> 循环是实现“踢出”操作的关键。它从找到的空桶节点开始，沿着 <code>parent_pos</code> 指针反向回溯到根节点。在回溯的每一步，它都执行 <code>(*buckets)[child_bucket] = (*buckets)[parent_bucket];</code> 操作，即<strong>将父节点桶中的内容（键）移动到子节点桶的位置</strong>。这个连锁反应最终会使路径的起点（即最初要插入的键的某个候选位置）变为空，从而为新键腾出空间。</p><blockquote><p>假设我们有一个大小为 8 的哈希表 (hash_table_size_ = 8), 并且已经存放了一些键. 我们用 K1, K2 等来代表不同的键.</p><ul><li><p>哈希表当前状态:</p><table><thead><tr><th align="left">Bucket Index:</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th></tr></thead><tbody><tr><td align="left">Content:</td><td align="left"></td><td align="left">K1</td><td align="left">K2</td><td align="left"></td><td align="left"></td><td align="left">K3</td><td align="left"></td><td align="left"></td></tr></tbody></table></li><li><p>键的哈希位置: 假设我们有2个哈希函数 h1 和 h2.</p><ul><li>h1(K1)=1, h2(K1)=5 (K1 占用了它的主位置 1)</li><li>h1(K2)=2, h2(K2)=1 (K2 占用了它的主位置 2, 它的备用位置 1 已被 K1 占用)</li><li>h1(K3)=5, h2(K3)=7 (K3 占用了它的主位置 5, 它的备用位置 7 是空的)</li></ul></li><li><p>当前任务: 我们现在要插入一个新键 K_new, 不幸的是, 它的哈希位置是 h1(K_new)=2 和 h2(K_new)=5. 这两个位置都已经被占用了.</p><p>此时, MakeHashTable 发现无法直接放置 K_new, 于是调用 MakeSpaceForKey.</p></li></ul><hr><ol><li><p>BFS 的 tree 是什么样的?</p><p>tree 是一个用 std::vector 实现的扁平化的树, 节点之间通过 parent_pos (父节点在 vector 中的索引) 关联.</p><p><code>CuckooNode</code> 结构:</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CuckooNode</span> &#123;</span>
  <span class="hljs-keyword">uint64_t</span> bucket_id; <span class="hljs-comment">// 桶的 ID, 即在哈希表中的索引</span>
  <span class="hljs-keyword">uint32_t</span> depth;     <span class="hljs-comment">// 在 BFS 树中的深度</span>
  <span class="hljs-keyword">uint32_t</span> parent_pos;<span class="hljs-comment">// 父节点在 tree 向量中的索引</span>
  <span class="hljs-comment">// ...</span>
&#125;;</code></pre></div><p><code>MakeSpaceForKey</code> 开始执行:</p></li><li><p>Level 0 (根节点):<br>MakeSpaceForKey 首先将 K_new 的所有候选位置 (2 和 5) 作为根节点放入 tree.</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// tree 向量的内容:</span>
[
  <span class="hljs-comment">// index 0</span>
  &#123; bucket_id: <span class="hljs-number">2</span>, depth: <span class="hljs-number">0</span>, parent_pos: <span class="hljs-number">0</span> &#125;,
 <span class="hljs-comment">// index 1</span>
  &#123; bucket_id: <span class="hljs-number">5</span>, depth: <span class="hljs-number">0</span>, parent_pos: <span class="hljs-number">0</span> &#125;
]</code></pre></div></li><li><p>Level 1 (扩展子节点):<br>BFS 从 tree 的头部 (index 0) 开始处理.</p><ul><li>处理 <code>tree[0]</code> (bucket 2):<ul><li><p>桶 2 中存放的是 K2.</p></li><li><p>K2 的备用位置是 h2(K2)=1.</p></li><li><p>将备用位置 1 作为一个新的 CuckooNode 加入 tree, 它的父节点是 tree[0].</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// tree 向量的内容:</span>
[
  &#123; bucket_id: <span class="hljs-number">2</span>, depth: <span class="hljs-number">0</span>, parent_pos: <span class="hljs-number">0</span> &#125;, <span class="hljs-comment">// index 0</span>
  &#123; bucket_id: <span class="hljs-number">5</span>, depth: <span class="hljs-number">0</span>, parent_pos: <span class="hljs-number">0</span> &#125;, <span class="hljs-comment">// index 1</span>
  <span class="hljs-comment">// 新增节点, 父节点索引为 0</span>
  &#123; bucket_id: <span class="hljs-number">1</span>, depth: <span class="hljs-number">1</span>, parent_pos: <span class="hljs-number">0</span> &#125;  <span class="hljs-comment">// index 2</span>
]</code></pre></div></li></ul></li><li>处理 <code>tree[1]</code> (bucket 5):<ul><li><p>桶 5 中存放的是 K3.</p></li><li><p>K3 的备用位置是 h2(K3)=7.</p></li><li><p>将备用位置 7 作为一个新的 CuckooNode 加入 tree, 它的父节点是 tree[1].</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// tree 向量的内容:</span>
[
  &#123; bucket_id: <span class="hljs-number">2</span>, depth: <span class="hljs-number">0</span>, parent_pos: <span class="hljs-number">0</span> &#125;, <span class="hljs-comment">// index 0</span>
  &#123; bucket_id: <span class="hljs-number">5</span>, depth: <span class="hljs-number">0</span>, parent_pos: <span class="hljs-number">0</span> &#125;, <span class="hljs-comment">// index 1</span>
  &#123; bucket_id: <span class="hljs-number">1</span>, depth: <span class="hljs-number">1</span>, parent_pos: <span class="hljs-number">0</span> &#125;, <span class="hljs-comment">// index 2</span>
  <span class="hljs-comment">// 新增节点, 父节点索引为 1</span>
  &#123; bucket_id: <span class="hljs-number">7</span>, depth: <span class="hljs-number">1</span>, parent_pos: <span class="hljs-number">1</span> &#125;  <span class="hljs-comment">// index 3</span>
]</code></pre></div></li></ul></li><li>发现空位! 当把 bucket_id: 7 这个节点加入 tree 时, 代码会检查哈希表中 buckets[7] 的状态. 它发现 buckets[7] 是空的 (vector_idx == kMaxVectorIdx). BFS 搜索成功!</li></ul><p>BFS <code>tree</code> 的最终形态:<br>这个 tree 向量在逻辑上代表了这样一棵搜索树:</p></li></ol><div class="hljs"><pre><code class="hljs cpp">        (K_new)
       /       \
(Level <span class="hljs-number">0</span>)  Bucket <span class="hljs-number">2</span> (K2)   Bucket <span class="hljs-number">5</span> (K3)
             |               |
(Level <span class="hljs-number">1</span>)  Bucket <span class="hljs-number">1</span> (K1)   Bucket <span class="hljs-number">7</span> (EMPTY)  &lt;-- 成功找到路径!</code></pre></div><p> 我们找到了一条可行的”踢出路径”: 将 <code>K3</code> 从桶 5 移动到桶 7, 就能空出桶 5 给 <code>K_new</code>.</p></blockquote><h2 id="四、-CuckooTableReader：快如闪电的点查找"><a href="#四、-CuckooTableReader：快如闪电的点查找" class="headerlink" title="四、 CuckooTableReader：快如闪电的点查找"></a>四、 CuckooTableReader：快如闪电的点查找</h2><p>与 <code>Builder</code> 的复杂性形成鲜明对比，<code>Reader</code> 的设计极其简洁高效。所有复杂的布局工作都已在写入时完成，<code>Reader</code> 的任务就是以最快的方式利用这个预设好的布局。</p><h3 id="4-1-Reader-的核心思想：mmap-与直接地址计算"><a href="#4-1-Reader-的核心思想：mmap-与直接地址计算" class="headerlink" title="4.1 Reader 的核心思想：mmap 与直接地址计算"></a>4.1 Reader 的核心思想：mmap 与直接地址计算</h3><p><code>CuckooTableReader</code> 的高性能秘诀主要有两点：</p><ol><li> <strong>内存映射 (mmap)</strong>: <code>Reader</code> 通过 <code>mmap</code> 系统调用将整个 SST 文件映射到进程的虚拟地址空间。这避免了传统的 <code>read()</code> 系统调用带来的内核态/用户态切换和数据拷贝开销。后续的所有文件访问都变成了直接的内存访问，速度极快（仅在首次访问时会触发缺页中断）。</li><li> <strong>直接地址计算</strong>: 它不依赖于任何索引块。对于一个给定的键，它能通过哈希函数<strong>直接计算</strong>出键在文件（即内存）中的几个潜在位置。查找过程就是几次哈希计算和内存访问，时间复杂度接近 O(1)。</li></ol><h3 id="4-2-构造函数：加载元数据与内存映射"><a href="#4-2-构造函数：加载元数据与内存映射" class="headerlink" title="4.2 构造函数：加载元数据与内存映射"></a>4.2 构造函数：加载元数据与内存映射</h3><p><code>Reader</code> 的构造函数负责读取 <code>Builder</code> 留下的“地图”，并完成内存映射。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_reader.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp">CuckooTableReader::CuckooTableReader(
    <span class="hljs-keyword">const</span> ImmutableOptions&amp; ioptions,
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;RandomAccessFileReader&gt;&amp;&amp; file, <span class="hljs-keyword">uint64_t</span> file_size,
    <span class="hljs-comment">/* ... */</span>) &#123;
  <span class="hljs-keyword">if</span> (!ioptions.allow_mmap_reads) &#123;
    status_ = Status::InvalidArgument(<span class="hljs-string">&quot;File is not mmaped&quot;</span>);
    <span class="hljs-keyword">return</span>;
  &#125;
  
  <span class="hljs-comment">// 读取并解析 Table Properties</span>
  status_ =
      ReadTableProperties(file_.get(), file_size, kCuckooTableMagicNumber,
                          ioptions, read_options, &amp;props);
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// 从 Properties 中恢复所有布局参数</span>
  <span class="hljs-comment">// ... find and assign num_hash_func_, unused_key_, key_length_, etc. ...</span>
  bucket_length_ = key_length_ + value_length_;

  <span class="hljs-comment">// 将整个文件映射到内存</span>
  status_ = file_-&gt;Read(IOOptions(), <span class="hljs-number">0</span>, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(file_size),
                        &amp;file_data_, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
&#125;</code></pre></div><p>构造函数首先检查 <code>mmap</code> 是否被允许。然后，它通过 <code>ReadTableProperties</code> 从文件尾部读取元数据，恢复 <code>Builder</code> 保存的所有布局参数，如哈希函数数量、键值长度、空桶占位符 <code>unused_key_</code> 等。最后，它调用 <code>file_-&gt;Read()</code>（在 <code>mmap</code> 模式下）将整个文件内容映射到 <code>file_data_</code> 这个 <code>Slice</code> 中，为后续的查找做好了准备。</p><h3 id="4-3-Get-方法：从哈希到内存地址的直接转换"><a href="#4-3-Get-方法：从哈希到内存地址的直接转换" class="headerlink" title="4.3 Get() 方法：从哈希到内存地址的直接转换"></a>4.3 Get() 方法：从哈希到内存地址的直接转换</h3><p><code>Get()</code> 方法是 <code>Reader</code> 的精髓所在，完美体现了其设计思想。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_reader.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function">Status <span class="hljs-title">CuckooTableReader::Get</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ReadOptions&amp;, <span class="hljs-keyword">const</span> Slice&amp; key, GetContext* get_context, ... )</span> </span>&#123;
  Slice user_key = ExtractUserKey(key);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> hash_cnt = <span class="hljs-number">0</span>; hash_cnt &lt; num_hash_func_; ++hash_cnt) &#123;
    <span class="hljs-keyword">uint64_t</span> offset =
        bucket_length_ * CuckooHash(user_key, hash_cnt, ...);
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* bucket = &amp;file_data_.data()[offset];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> block_idx = <span class="hljs-number">0</span>; block_idx &lt; cuckoo_block_size_; ++block_idx, bucket += bucket_length_) &#123;
      <span class="hljs-keyword">if</span> (ucomp_-&gt;Equal(Slice(unused_key_.data(), user_key.size()),
                        Slice(bucket, user_key.size()))) &#123;
        <span class="hljs-keyword">return</span> Status::OK();
      &#125;
      <span class="hljs-keyword">if</span> (ucomp_-&gt;Equal(user_key, Slice(bucket, user_key.size()))) &#123;
        <span class="hljs-function">Slice <span class="hljs-title">value</span><span class="hljs-params">(bucket + key_length_, value_length_)</span></span>;
        <span class="hljs-comment">// ... 保存 value 到 get_context ...</span>
        <span class="hljs-keyword">return</span> Status::OK();
      &#125;
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> Status::OK();
&#125;</code></pre></div><p>查找过程非常直接：</p><ol><li> 对给定的 <code>user_key</code>，遍历所有哈希函数。</li><li> 对于每个哈希函数，通过 <code>CuckooHash(...)</code> 计算出哈希值，再乘以 <code>bucket_length_</code>，得到在 <code>file_data_</code> 中的**精确字节偏移量 <code>offset</code>**。</li><li> 从该 <code>offset</code> 开始，在线性探测 <code>cuckoo_block_size_</code> 个桶。</li><li> 在每个桶中，首先与 <code>unused_key_</code> 比较，如果是空桶，则说明键不在此处。然后与 <code>user_key</code> 比较，如果匹配，则从 <code>bucket + key_length_</code> 处提取值并返回。</li><li> 如果所有哈希函数对应的所有 Cuckoo Block 都检查完毕仍未找到，则键不存在。</li></ol><h3 id="4-4-Prepare-方法：利用-CPU-缓存预取"><a href="#4-4-Prepare-方法：利用-CPU-缓存预取" class="headerlink" title="4.4 Prepare() 方法：利用 CPU 缓存预取"></a>4.4 Prepare() 方法：利用 CPU 缓存预取</h3><p>这是一个可选的性能优化，用于在 <code>Get()</code> 之前“预热”CPU缓存。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_reader.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CuckooTableReader::Prepare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slice&amp; key)</span> </span>&#123;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">uint64_t</span> addr = <span class="hljs-comment">/* ... calculate address of first hash location ... */</span>;
  <span class="hljs-keyword">uint64_t</span> end_addr = addr + cuckoo_block_bytes_minus_one_;
  <span class="hljs-keyword">for</span> (addr &amp;= CACHE_LINE_MASK; addr &lt; end_addr; addr += CACHE_LINE_SIZE) &#123;
    PREFETCH(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt;(addr), <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
  &#125;
&#125;</code></pre></div><p>该方法会计算出键的第一个哈希位置对应的内存地址，然后通过 <code>PREFETCH</code> 宏（通常是编译器的 <code>__builtin_prefetch</code>）指示 CPU 提前将这块内存区域加载到高速缓存中，从而降低后续 <code>Get()</code> 时的内存访问延迟。</p><h2 id="五、-CuckooTableIterator：范围扫描的代价"><a href="#五、-CuckooTableIterator：范围扫描的代价" class="headerlink" title="五、 CuckooTableIterator：范围扫描的代价"></a>五、 CuckooTableIterator：范围扫描的代价</h2><p>Cuckoo Table 为了极致的点查找性能，牺牲了范围扫描的能力。其迭代器的实现方式清晰地反映了这一点。</p><h3 id="5-1-迭代器的核心机制：一次性全量排序"><a href="#5-1-迭代器的核心机制：一次性全量排序" class="headerlink" title="5.1 迭代器的核心机制：一次性全量排序"></a>5.1 迭代器的核心机制：一次性全量排序</h3><p>由于 SST 文件中的键是按哈希值散乱分布的，为了提供 <code>Iterator</code> 所要求的有序遍历功能，<code>CuckooTableIterator</code> 不得不采取一种直接但代价高昂的策略：在首次使用时，读取所有键并进行一次完整的排序。</p><h3 id="5-2-InitIfNeeded-：昂贵的初始化"><a href="#5-2-InitIfNeeded-：昂贵的初始化" class="headerlink" title="5.2 InitIfNeeded()：昂贵的初始化"></a>5.2 InitIfNeeded()：昂贵的初始化</h3><p>迭代器的所有魔法都发生在 <code>InitIfNeeded()</code> 中，该方法在 <code>Seek</code> 或 <code>SeekToFirst</code> 等导航方法首次被调用时执行。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_reader.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CuckooTableIterator::InitIfNeeded</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-keyword">if</span> (initialized_) &#123;
    <span class="hljs-keyword">return</span>;
  &#125;
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* bucket = reader_-&gt;file_data_.data();
  <span class="hljs-comment">// 1. 遍历所有桶, 收集所有非空桶的 ID</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> bucket_id = <span class="hljs-number">0</span>; bucket_id &lt; num_buckets; ++bucket_id) &#123;
    <span class="hljs-keyword">if</span> (Slice(bucket, reader_-&gt;key_length_) != Slice(reader_-&gt;unused_key_)) &#123;
      sorted_bucket_ids_.push_back(bucket_id);
    &#125;
    bucket += reader_-&gt;bucket_length_;
  &#125;
  
  <span class="hljs-comment">// 2. 对所有非空桶的 ID, 按照其对应的 Key 进行排序</span>
  <span class="hljs-built_in">std</span>::sort(sorted_bucket_ids_.begin(), sorted_bucket_ids_.end(),
            bucket_comparator_);
  <span class="hljs-comment">// ...</span>
&#125;</code></pre></div><ol><li> <strong>收集</strong>: 代码首先遍历整个 <code>mmap</code> 的文件内容，检查每一个桶。如果桶的内容不是 <code>unused_key_</code>，就将其 <code>bucket_id</code> 添加到一个 <code>std::vector&lt;uint32_t&gt; sorted_bucket_ids_</code> 中。</li><li> <strong>排序</strong>: 这是最昂贵的操作。它调用 <code>std::sort</code>，并传入一个自定义的 <code>BucketComparator</code>，对 <code>sorted_bucket_ids_</code> 向量进行排序。排序的依据不是桶ID的数值，而是ID对应桶中的键。</li></ol><h3 id="5-3-BucketComparator：如何比较“桶ID”"><a href="#5-3-BucketComparator：如何比较“桶ID”" class="headerlink" title="5.3 BucketComparator：如何比较“桶ID”"></a>5.3 BucketComparator：如何比较“桶ID”</h3><p>这个自定义比较器是实现排序的关键。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_reader.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BucketComparator</span> &#123;</span>
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> first, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> second)</span> <span class="hljs-keyword">const</span> </span>&#123;
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* first_bucket = <span class="hljs-comment">/* ... get key address from first id ... */</span>;
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* second_bucket = <span class="hljs-comment">/* ... get key address from second id ... */</span>;
      <span class="hljs-keyword">return</span> ucomp_-&gt;Compare(Slice(first_bucket, user_key_len_),
                             Slice(second_bucket, user_key_len_)) &lt; <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-comment">// ...</span>
  &#125;;</code></pre></div><p>它的 <code>operator()</code> 接收两个桶ID，然后根据ID从 <code>file_data_</code> 中找到对应的键，最后使用用户提供的 <code>Comparator</code> (<code>ucomp_</code>) 来比较这两个键，从而决定桶ID的顺序。</p><h3 id="5-4-Seek-Next-Prev：基于已排序索引的快速导航"><a href="#5-4-Seek-Next-Prev：基于已排序索引的快速导航" class="headerlink" title="5.4 Seek/Next/Prev：基于已排序索引的快速导航"></a>5.4 Seek/Next/Prev：基于已排序索引的快速导航</h3><p>一旦 <code>InitIfNeeded()</code> 完成了昂贵的排序，迭代器的所有导航操作就变得非常轻快。</p><p><strong>代码 (<code>table/cuckoo/cuckoo_table_reader.cc</code>):</strong></p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CuckooTableIterator::Seek</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slice&amp; target)</span> </span>&#123;
  InitIfNeeded();
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">auto</span> seek_it =
      <span class="hljs-built_in">std</span>::lower_bound(sorted_bucket_ids_.begin(), sorted_bucket_ids_.end(),
                       kInvalidIndex, seek_comparator);
  <span class="hljs-comment">// ...</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CuckooTableIterator::Next</span><span class="hljs-params">()</span> </span>&#123; ++curr_key_idx_; <span class="hljs-comment">/* ... */</span> &#125;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CuckooTableIterator::Prev</span><span class="hljs-params">()</span> </span>&#123; --curr_key_idx_; <span class="hljs-comment">/* ... */</span> &#125;</code></pre></div><ul><li> <code>Next()</code> 和 <code>Prev()</code> 只是简单地移动 <code>sorted_bucket_ids_</code> 向量的下标 <code>curr_key_idx_</code>。</li><li> <code>Seek()</code> 则是在这个已排序的ID向量上执行高效的二分查找 (<code>std::lower_bound</code>)。</li><li> 这些操作都只涉及整数向量的操作，因此一旦初始化完成，迭代本身的速度非常快。</li></ul><h2 id="六、-总结：Cuckoo-Table-的设计哲学与权衡"><a href="#六、-总结：Cuckoo-Table-的设计哲学与权衡" class="headerlink" title="六、 总结：Cuckoo Table 的设计哲学与权衡"></a>六、 总结：Cuckoo Table 的设计哲学与权衡</h2><p>通过对 <code>Factory</code>、<code>Builder</code> 和 <code>Reader</code> 的深入分析，我们可以清晰地看到 Cuckoo Table 的设计哲学：<strong>通过在写入时承担更多的复杂性，并施加更严格的约束，来换取读取时极致的性能</strong>。</p><ul><li><p><strong>优点</strong>:</p><ul><li> 无与伦比的点查找性能，这得益于其 <code>mmap</code> 友好的扁平文件结构和 O(1) 复杂度的直接哈希地址计算。</li></ul></li><li><p><strong>代价与权衡</strong>:</p><ul><li> <strong>严格的约束</strong>: 必须使用定长的键和值。</li><li> <strong>复杂的写入路径</strong>: <code>Builder</code> 需要处理复杂的哈希冲突和“踢出”逻辑，构建过程可能比 <code>BlockBasedTable</code> 更慢，CPU消耗也更高。</li><li> <strong>昂贵的范围扫描</strong>: <code>Iterator</code> 的首次使用需要进行全量扫描和排序，对于范围查询的场景是完全不适合的。</li></ul></li></ul><p>总而言之，Cuckoo Table 是 RocksDB 工具箱中一件锋利的“专科武器”，而非“万金油”。它完美地诠释了在高性能存储系统设计中，“没有最好的，只有最合适的”这一黄金法则。当你的业务场景与它的设计目标高度契合时，它能带来惊人的性能提升。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/KV%E6%95%B0%E6%8D%AE%E5%BA%93/">KV数据库</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/KV%E6%95%B0%E6%8D%AE%E5%BA%93/">KV数据库</a> <a class="hover-with-bg" href="/tags/RocksDB/">RocksDB</a></div></div><p class="note note-warning">转载请注明出处</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/2025/08/20/RocksDB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%85%A5BlockBasedTable-%E4%B8%80/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">RocksDB源码学习:深入BlockBasedTable(一)</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"> <a href="/2025/08/18/RocksDB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%9AMemTable%E5%AE%9E%E7%8E%B0%E4%B9%8BVectorRep%E3%80%81HashLinkListRep%E4%B8%8EHashSkipListRep/"><span class="hidden-mobile">RocksDB源码学习：MemTable实现之VectorRep、HashLinkListRep与HashSkipListRep</span> <span class="visible-mobile">下一篇</span><i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"> <span id="leancloud-site-pv-container" style="display:none">总访问量<span id="leancloud-site-pv"></span> 次</span> <span id="leancloud-site-uv-container" style="display:none">总访客数<span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer="defer">
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2025/08/19/RocksDB%E4%B8%ADCuckoo-Table%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E8%A7%A3%E6%9E%90/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'rGBkjlpYFYPq3Mztf0uHkwm2-gzGzoHsz'
    var app_key = 'IwuJ6qbGLXA8pB3qeHHjuDT3'
    var server_url = 'https://rgbkjlpy.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>