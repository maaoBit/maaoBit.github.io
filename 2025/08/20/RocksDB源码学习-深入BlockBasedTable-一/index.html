<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="maao"><meta name="keywords" content=""><title>RocksDB源码学习:深入BlockBasedTable(一) - MAAO的博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/darcula.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"> <a class="navbar-brand" href="/">&nbsp;<strong>maao's space</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"> <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"> <a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"> <span class="h2" id="subtitle">RocksDB源码学习:深入BlockBasedTable(一)</span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-08-20 14:18" pubdate>2025年8月20日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.6k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 42 分钟</span><span id="leancloud-post-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i><span id="leancloud-post-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">RocksDB源码学习:深入BlockBasedTable(一)</h1><div class="markdown-body" id="post-body"><p>BlockBasedTable是RocksDB中SST文件的默认格式，本文是源码学习BlockBasedTable的第一篇，主要围绕数据块（Data Block）层面，进行介绍。</p><a id="more"></a><h2 id="一、-BlockBasedTable-整体认知"><a href="#一、-BlockBasedTable-整体认知" class="headerlink" title="一、 BlockBasedTable 整体认知"></a>一、 BlockBasedTable 整体认知</h2><p>在深入研究 RocksDB 的核心存储单元之前，我们首先需要建立一个关于 <code>BlockBasedTable</code> (SST 文件格式) 的宏观视图。它是 RocksDB 默认的、用于在磁盘上持久化存储键值对的格式。</p><h3 id="1-1-SST-文件磁盘布局概览"><a href="#1-1-SST-文件磁盘布局概览" class="headerlink" title="1.1 SST 文件磁盘布局概览"></a>1.1 SST 文件磁盘布局概览</h3><p>一个 <code>BlockBasedTable</code> 格式的 SST 文件在逻辑上由多个部分组成，一个典型的 SST 文件结构如下，特别是注意其读取入口位于文件的末尾：</p><div class="hljs"><pre><code class="hljs fortran">&lt;文件起始&gt;
[数据块 <span class="hljs-number">1</span>]
[数据块 <span class="hljs-number">2</span>]
<span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span>
[数据块 N]

// --- 以下元数据块的顺序并非固定 ---

[Meta <span class="hljs-keyword">Block</span>: Filter <span class="hljs-keyword">Block</span>]
[Meta <span class="hljs-keyword">Block</span>: Properties <span class="hljs-keyword">Block</span>]
[Meta <span class="hljs-keyword">Block</span>: Compression Dictionary <span class="hljs-keyword">Block</span>]
[Meta <span class="hljs-keyword">Block</span>: <span class="hljs-built_in">Range</span> Deletion <span class="hljs-keyword">Block</span>]
<span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span> (其他元数据块) <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span>

[<span class="hljs-built_in">Index</span> <span class="hljs-keyword">Block</span>] (数据块的总索引)

[Metaindex <span class="hljs-keyword">Block</span>] (元数据块的索引)

[Footer] (固定大小的文件尾部，包含指向 <span class="hljs-built_in">Index</span> 和 Metaindex 的指针)
&lt;文件结束&gt;</code></pre></div><ul><li> <strong>Data Blocks</strong>: 存储实际的、已排序的键值对数据。</li><li> <strong>Index Block</strong>: 数据块的索引，使得可以快速定位到包含特定 key 的数据块，而无需扫描整个文件。</li><li> <strong>Meta Blocks</strong>: 存储元数据，如布隆过滤器 (<code>Filter</code>)、表属性 (<code>Properties</code>) 等。</li><li> <strong>Metaindex Block</strong>: “元数据的索引”，用于定位所有的 Meta Block。</li><li> <strong>Footer</strong>: 文件的入口点，固定大小，存储了指向 Index Block 和 Metaindex Block 的指针。RocksDB 读取一个 SST 文件时，总是先从这里开始。</li></ul><h3 id="1-2-数据块-Data-Block"><a href="#1-2-数据块-Data-Block" class="headerlink" title="1.2 数据块 (Data Block)"></a>1.2 数据块 (Data Block)</h3><p>在整个 SST 文件结构中，<strong>数据块 (Data Block)</strong> 是最基本的存储单元。所有用户的键值对数据最终都被组织在一个个数据块中。因此，理解数据块的内部格式、构建方式和读取逻辑，是掌握 <code>BlockBasedTable</code>关键第一步。</p><h2 id="二、-数据块的内部格式"><a href="#二、-数据块的内部格式" class="headerlink" title="二、 数据块的内部格式"></a>二、 数据块的内部格式</h2><p>数据块的设计目标是在保证快速查找的同时，尽可能地节省存储空间。为此，它采用了两种关键技术：<strong>前缀压缩 (Prefix Compression)</strong> 和 **重启点 (Restart Points)**。</p><h3 id="2-1-键值对条目-Entry-的存储格式"><a href="#2-1-键值对条目-Entry-的存储格式" class="headerlink" title="2.1 键值对条目 (Entry) 的存储格式"></a>2.1 键值对条目 (Entry) 的存储格式</h3><p>块内的每一个键值对（Entry）都遵循以下格式进行编码，以实现前缀压缩：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 源码: table/block_based/block_builder.cc 注释</span>
shared_bytes:   varint32  <span class="hljs-comment">// 与上一个 key 共享的前缀长度</span>
unshared_bytes: varint32  <span class="hljs-comment">// 当前 key 不共享的后缀长度</span>
value_length:   varint32  <span class="hljs-comment">// value 的长度</span>
key_delta:      <span class="hljs-keyword">char</span>[unshared_bytes] <span class="hljs-comment">// key 的非共享后缀部分</span>
value:          <span class="hljs-keyword">char</span>[value_length]   <span class="hljs-comment">// 完整的 value 数据</span></code></pre></div><h3 id="2-2-核心设计一：前缀压缩-Prefix-Compression"><a href="#2-2-核心设计一：前缀压缩-Prefix-Compression" class="headerlink" title="2.2 核心设计一：前缀压缩 (Prefix Compression)"></a>2.2 核心设计一：前缀压缩 (Prefix Compression)</h3><p>由于数据块内的 key 是有序的，相邻的 key 常常拥有共同的前缀。前缀压缩技术正是利用了这一点，对于一个 key，我们不存储它的完整内容，而是存储它与上一个 key 的共享前缀长度 (<code>shared_bytes</code>)，以及它自己独有的后缀部分 (<code>key_delta</code>)。这样，在数据密集且前缀重复度高的场景下（如 URL、文件路径等），可以节省大量存储空间。</p><h3 id="2-3-核心设计二：重启点-Restart-Points"><a href="#2-3-核心设计二：重启点-Restart-Points" class="headerlink" title="2.3 核心设计二：重启点 (Restart Points)"></a>2.3 核心设计二：重启点 (Restart Points)</h3><p>虽然前缀压缩节省了空间，但它也带来了一个问题：要解码任意一个 key，必须先解码它之前的所有 key，这是一个 O(N) 的操作。为了解决这个问题，引入了“重启点”机制。</p><p>一个重启点是一个不使用前缀压缩、完整存储 key 的条目。数据块中每隔 <code>block_restart_interval</code> 个条目（默认是16）就会设置一个重启点。这些重启点的存在，使得我们可以在块内进行二分查找，从而将查找复杂度降低到 <code>O(logR + K)</code>（R是重启点数量，K是重启点间隔），极大地提高了查找效率。</p><h3 id="2-4-块尾-Trailer-的结构"><a href="#2-4-块尾-Trailer-的结构" class="headerlink" title="2.4 块尾 (Trailer) 的结构"></a>2.4 块尾 (Trailer) 的结构</h3><p>在一个数据块所有条目存储完毕后，其尾部会附加一个 Trailer，包含两部分信息：</p><ol><li> <strong>重启点偏移量数组</strong>: 一个由 <code>uint32_t</code> 组成的数组，按顺序列出了块内所有重启点相对于块起始位置的偏移量。</li><li> <strong>重启点总数</strong>: 一个 <code>uint32_t</code> 整数，表示重启点的数量。</li></ol><p>这个 Trailer 结构为块内的高效查找提供了必要的元数据。</p><h2 id="三、-数据块的构建：BlockBuilder-的工作原理"><a href="#三、-数据块的构建：BlockBuilder-的工作原理" class="headerlink" title="三、 数据块的构建：BlockBuilder 的工作原理"></a>三、 数据块的构建：<code>BlockBuilder</code> 的工作原理</h2><p><code>BlockBuilder</code> 类负责将有序的键值对序列打包成一个遵循上述格式的数据块。</p><h3 id="3-1-BlockBuilder-的设计目标与初始化"><a href="#3-1-BlockBuilder-的设计目标与初始化" class="headerlink" title="3.1 BlockBuilder 的设计目标与初始化"></a>3.1 <code>BlockBuilder</code> 的设计目标与初始化</h3><p><code>BlockBuilder</code> 的目标就是高效地完成数据块的构建。其构造函数接收几个关键参数：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 源码: table/block_based/block_builder.h</span>
<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BlockBuilder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> block_restart_interval,</span></span>
<span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">bool</span> use_delta_encoding = <span class="hljs-literal">true</span>,</span></span>
<span class="hljs-function"><span class="hljs-params">                      ...)</span></span>;</code></pre></div><ul><li> <code>block_restart_interval</code>: 定义了重启点的间隔。</li><li> <code>use_delta_encoding</code>: 控制是否启用前缀压缩。</li></ul><h3 id="3-2-Add-方法详解：如何添加一个键值对"><a href="#3-2-Add-方法详解：如何添加一个键值对" class="headerlink" title="3.2 Add 方法详解：如何添加一个键值对"></a>3.2 <code>Add</code> 方法详解：如何添加一个键值对</h3><p><code>Add</code> 方法是 <code>BlockBuilder</code> 的核心。每当一个键值对被添加时，它会执行以下逻辑（主要在 <code>AddWithLastKeyImpl</code> 中实现）：</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 源码: table/block_based/block_builder.cc</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BlockBuilder::AddWithLastKeyImpl</span><span class="hljs-params">(...)</span> </span>&#123;
  <span class="hljs-keyword">size_t</span> shared = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 1. 检查是否需要创建重启点</span>
  <span class="hljs-keyword">if</span> (counter_ &gt;= block_restart_interval_) &#123;
    restarts_.push_back(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(buffer_.size()));
    counter_ = <span class="hljs-number">0</span>;
  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (use_delta_encoding_) &#123;
    <span class="hljs-comment">// 2. 计算共享前缀</span>
    shared = key_to_persist.difference_offset(last_key_persisted);
  &#125;

  <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> non_shared = key_to_persist.size() - shared;

  <span class="hljs-comment">// 3. 写入元数据</span>
  PutVarint32Varint32Varint32(&amp;buffer_, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(shared),
                               <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(non_shared),
                               <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(value.size()));

  <span class="hljs-comment">// 4. 写入数据</span>
  buffer_.append(key_to_persist.data() + shared, non_shared);
  buffer_.append(value.data(), value.size());

  <span class="hljs-comment">// 5. 更新状态</span>
  counter_++;
  <span class="hljs-comment">// last_key_ 会在 Add() 方法中被更新</span>
&#125;</code></pre></div><h4 id="3-2-1-前缀压缩与重启点的协同工作"><a href="#3-2-1-前缀压缩与重启点的协同工作" class="headerlink" title="3.2.1 前缀压缩与重启点的协同工作"></a>3.2.1 前缀压缩与重启点的协同工作</h4><p><code>Add</code> 方法的核心逻辑完美地展示了前缀压缩和重启点是如何协同工作的。</p><ul><li> <strong>重启点创建</strong>: 当内部计数器 <code>counter_</code> 达到 <code>block_restart_interval</code> 时，当前条目就成为一个新的重启点。此时，共享前缀长度 <code>shared</code> 为 0，完整的 key 会被写入，并且其在缓冲区中的起始偏移量会被记录在 <code>restarts_</code> 数组中。</li><li> <strong>前缀压缩</strong>: 当条目不是重启点时，代码通过 <code>key_to_persist.difference_offset(last_key_persisted)</code> 计算出与上一个 key 的共享前缀长度 <code>shared</code>。然后，只将非共享的后缀部分 (<code>key_delta</code>) 写入缓冲区，从而实现压缩。</li></ul><h4 id="3-2-2-一个具体的构建示例"><a href="#3-2-2-一个具体的构建示例" class="headerlink" title="3.2.2 一个具体的构建示例"></a>3.2.2 一个具体的构建示例</h4><p>为了更清晰地理解这个过程，我们假设 <code>block_restart_interval = 3</code>，并依次添加以下5个键（为简化，忽略值）：</p><ol><li> <code>key: &quot;apple&quot;</code></li><li> <code>key: &quot;apply&quot;</code></li><li> <code>key: &quot;apricot&quot;</code></li><li> <code>key: &quot;banana&quot;</code></li><li> <code>key: &quot;bandana&quot;</code></li></ol><p><code>BlockBuilder</code> 内部会发生以下过程：</p><hr><p><strong>Entry 1: 添加 “apple”</strong></p><ul><li> <code>counter</code> 为 0，满足重启点条件，这是一个<strong>重启点</strong>。</li><li> <code>restarts</code> 数组记录当前偏移量 <code>0</code>。</li><li> <code>shared = 0</code>, <code>non_shared = 5</code>。</li><li> 写入 buffer: <code>&lt;varint(0)&gt;&lt;varint(5)&gt;... &quot;apple&quot; ...</code></li><li> <code>last_key</code> 更新为 <code>&quot;apple&quot;</code>，<code>counter</code> 变为 1。</li></ul><hr><p><strong>Entry 2: 添加 “apply”</strong></p><ul><li> <code>counter</code> 为 1，不是重启点。</li><li> 与 <code>&quot;apple&quot;</code> 比较，共享前缀为 <code>&quot;appl&quot;</code>。</li><li> <code>shared = 4</code>, <code>non_shared = 1</code> (后缀为 “y”)。</li><li> 写入 buffer: <code>&lt;varint(4)&gt;&lt;varint(1)&gt;... &quot;y&quot; ...</code></li><li> <code>last_key</code> 更新为 <code>&quot;apply&quot;</code>，<code>counter</code> 变为 2。</li></ul><hr><p><strong>Entry 3: 添加 “apricot”</strong></p><ul><li> <code>counter</code> 为 2，不是重启点。</li><li> 与 <code>&quot;apply&quot;</code> 比较，共享前缀为 <code>&quot;ap&quot;</code>。</li><li> <code>shared = 2</code>, <code>non_shared = 5</code> (后缀为 “ricot”)。</li><li> 写入 buffer: <code>&lt;varint(2)&gt;&lt;varint(5)&gt;... &quot;ricot&quot; ...</code></li><li> <code>last_key</code> 更新为 <code>&quot;apricot&quot;</code>，<code>counter</code> 变为 3。</li></ul><hr><p><strong>Entry 4: 添加 “banana”</strong></p><ul><li> <code>counter</code> 为 3，满足重启点条件，这是一个新的<strong>重启点</strong>。</li><li> <code>restarts</code> 数组记录下当前条目的起始偏移量。</li><li> <code>shared = 0</code>, <code>non_shared = 6</code>。</li><li> 写入 buffer: <code>&lt;varint(0)&gt;&lt;varint(6)&gt;... &quot;banana&quot; ...</code></li><li> <code>last_key</code> 更新为 <code>&quot;banana&quot;</code>，<code>counter</code> 重置为 1。</li></ul><hr><p><strong>Entry 5: 添加 “bandana”</strong></p><ul><li> <code>counter</code> 为 1，不是重启点。</li><li> 与 <code>&quot;banana&quot;</code> 比较，共享前缀为 <code>&quot;ban&quot;</code>。</li><li> <code>shared = 3</code>, <code>non_shared = 4</code> (后缀为 “dana”)。</li><li> 写入 buffer: <code>&lt;varint(3)&gt;&lt;varint(4)&gt;... &quot;dana&quot; ...</code></li><li> <code>last_key</code> 更新为 <code>&quot;bandana&quot;</code>，<code>counter</code> 变为 2。</li></ul><hr><p>这个例子清晰地展示了 <code>BlockBuilder</code> 如何在节省空间（通过前缀压缩）和保证查找效率（通过重启点）之间取得平衡。</p><h3 id="3-3-Finish-方法：完成一个数据块的构建"><a href="#3-3-Finish-方法：完成一个数据块的构建" class="headerlink" title="3.3 Finish 方法：完成一个数据块的构建"></a>3.3 <code>Finish</code> 方法：完成一个数据块的构建</h3><p>当一个块的数据全部添加完毕，<code>Finish</code> 方法被调用以完成最终的打包工作。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 源码: table/block_based/block_builder.cc</span>
<span class="hljs-function">Slice <span class="hljs-title">BlockBuilder::Finish</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-comment">// 将重启点数组写入 buffer</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; restarts_.size(); i++) &#123;
    PutFixed32(&amp;buffer_, restarts_[i]);
  &#125;

  <span class="hljs-comment">// 将重启点数量和其他信息打包成 footer 并写入</span>
  <span class="hljs-keyword">uint32_t</span> num_restarts = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(restarts_.size());
  <span class="hljs-keyword">uint32_t</span> block_footer = PackIndexTypeAndNumRestarts(index_type, num_restarts);
  PutFixed32(&amp;buffer_, block_footer);
  
  finished_ = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> Slice(buffer_);
&#125;</code></pre></div><p>这个方法将之前记录的所有重启点偏移量和总数作为 Trailer 追加到数据缓冲区的末尾，形成一个完整、独立、可解析的数据块。</p><h2 id="四、-数据块的解析与迭代：Block-与-DataBlockIter"><a href="#四、-数据块的解析与迭代：Block-与-DataBlockIter" class="headerlink" title="四、 数据块的解析与迭代：Block 与 DataBlockIter"></a>四、 数据块的解析与迭代：<code>Block</code> 与 <code>DataBlockIter</code></h2><p><code>Block</code> 和 <code>DataBlockIter</code> 类执行的是与 <code>BlockBuilder</code> 相反的操作：解析数据块并提供遍历能力。</p><h3 id="4-1-Block-类的角色：块的容器"><a href="#4-1-Block-类的角色：块的容器" class="headerlink" title="4.1 Block 类的角色：块的容器"></a>4.1 <code>Block</code> 类的角色：块的容器</h3><p><code>Block</code> 类是一个轻量级的容器。它的构造函数接收一个数据块的原始二进制 <code>Slice</code>，但它<strong>只解析块尾的 Trailer</strong>，提取出重启点数组的位置和数量。它并不会立即解码所有的键值对，这是一种延迟加载（Lazy Loading）的思想，避免了不必要的计算开销。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 源码: table/block_based/block.cc</span>
Block::Block(BlockContents&amp;&amp; contents, ...) &#123;
  <span class="hljs-keyword">auto</span>&amp; size = contents_.data.size_;
  <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>)) &#123;
    size = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Error marker</span>
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 从块的末尾读取重启点的数量</span>
    num_restarts_ = NumRestarts(); 
    <span class="hljs-comment">// ... 根据块的索引类型计算重启点数组的起始偏移量</span>
    restart_offset_ = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(size) -
                      (<span class="hljs-number">1</span> + num_restarts_) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>);
    <span class="hljs-comment">// ... 其他初始化</span>
  &#125;
&#125;</code></pre></div><p><code>Block</code> 类的主要职责是作为工厂，通过 <code>NewDataIterator()</code> 方法创建一个 <code>DataBlockIter</code> 实例，并将解析好的重启点等信息传递给它。</p><h3 id="4-2-DataBlockIter：数据块的遍历者"><a href="#4-2-DataBlockIter：数据块的遍历者" class="headerlink" title="4.2 DataBlockIter：数据块的遍历者"></a>4.2 <code>DataBlockIter</code>：数据块的遍历者</h3><p><code>DataBlockIter</code> 是实现块内数据访问的核心。它是一个有状态的迭代器，在内部维护了遍历所需的所有上下文信息。</p><h4 id="4-2-1-核心状态变量"><a href="#4-2-1-核心状态变量" class="headerlink" title="4.2.1 核心状态变量"></a>4.2.1 核心状态变量</h4><p><code>DataBlockIter</code> (及其基类 <code>BlockIter</code>) 内部维护着以下关键状态：</p><ul><li> <code>data_</code>: 指向整个数据块内存的指针。</li><li> <code>restarts_</code>: 指向重启点数组在 <code>data_</code> 中的偏移量。</li><li> <code>num_restarts_</code>: 重启点总数。</li><li> <code>current_</code>: 当前正在处理的条目在 <code>data_</code> 中的偏移量。</li><li> <code>restart_index_</code>: 当前条目所属的重启点区间的索引。</li><li> <code>raw_key_</code>: 一个可复用的内部缓冲区（<code>IterKey</code> 类型），用于存放当前<strong>完整解码后</strong>的 key。</li><li> <code>value_</code>: 一个 <code>Slice</code>，直接指向 <code>data_</code> 中当前条目的 value 部分。</li></ul><h4 id="4-2-2-顺序遍历-Next-与增量解压"><a href="#4-2-2-顺序遍历-Next-与增量解压" class="headerlink" title="4.2.2 顺序遍历 (Next) 与增量解压"></a>4.2.2 顺序遍历 (<code>Next</code>) 与增量解压</h4><p>当调用迭代器的 <code>Next()</code> 方法时，其核心是 <code>ParseNextKey()</code> 函数。该函数负责从当前位置解码下一个条目，并重建出完整的 key。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 源码: table/block_based/block.cc (BlockIter::ParseNextKey)</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">// 解码元数据: shared, non_shared, value_length</span>
<span class="hljs-keyword">uint32_t</span> shared, non_shared, value_length;
p = DecodeEntryFunc()(p, limit, &amp;shared, &amp;non_shared, &amp;value_length);

<span class="hljs-keyword">if</span> (shared == <span class="hljs-number">0</span>) &#123;
    <span class="hljs-comment">// 重启点，key 是完整的。raw_key_ 直接指向这块内存。</span>
    UpdateRawKeyAndMaybePadMinTimestamp(Slice(p, non_shared));
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 增量编码的 key。</span>
    <span class="hljs-comment">// raw_key_ 需要保留前 shared 个字节，并追加新的 non_shared 部分。</span>
    raw_key_.TrimAppend(shared, p, non_shared);
&#125;
<span class="hljs-comment">// value_ 指向 value 的内存区域</span>
value_ = Slice(p + non_shared, value_length);
<span class="hljs-comment">// ...</span></code></pre></div><p>这个过程精确地反映了 <code>BlockBuilder</code> 的编码逻辑：通过 <code>shared</code> 和 <code>non_shared</code> 的信息，迭代器可以高效地从上一个 key 的状态（保存在 <code>raw_key_</code> 中）和当前条目的增量数据中重建出完整的 key。</p><h4 id="4-2-3-随机查找-Seek-与重启点的应用"><a href="#4-2-3-随机查找-Seek-与重启点的应用" class="headerlink" title="4.2.3 随机查找 (Seek) 与重启点的应用"></a>4.2.3 随机查找 (<code>Seek</code>) 与重启点的应用</h4><p><code>Seek(target_key)</code> 操作充分展现了重启点的威力。它分为两步：</p><ol><li><p><strong>二分查找重启点</strong>: 首先，在块尾部的重启点偏移量数组上进行二分查找 (<code>BinarySeek</code>)，快速找到不大于 <code>target_key</code> 的最后一个重启点。这一定位过程非常快，复杂度为 <code>O(logR)</code>。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 源码: table/block_based/block.cc, DataBlockIter::SeekImpl</span>
<span class="hljs-keyword">bool</span> ok = BinarySeek&lt;DecodeKey&gt;(seek_key, &amp;index, &amp;skip_linear_scan);</code></pre></div></li><li><p><strong>小范围线性扫描</strong>: 定位到重启点后，迭代器跳转到该重启点的内存位置，然后开始逐个解码条目并比较，直到找到第一个大于或等于 <code>target_key</code> 的条目。由于重启点间隔不长（默认为16），这个线性扫描的范围很小，开销也很低。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-comment">// 源码: table/block_based/block.cc, DataBlockIter::SeekImpl</span>
FindKeyAfterBinarySeek(seek_key, index, skip_linear_scan);</code></pre></div></li></ol><p>这个“二分查找 + 小范围线性扫描”的策略，使得在数据块内部的随机查找性能远高于纯粹的线性扫描。</p><h3 id="4-3-关键实现细节：raw-key-的状态管理"><a href="#4-3-关键实现细节：raw-key-的状态管理" class="headerlink" title="4.3 关键实现细节：raw_key_ 的状态管理"></a>4.3 关键实现细节：<code>raw_key_</code> 的状态管理</h3><p>在迭代过程中，迭代器内部的 <code>raw_key_</code> 成员变量（一个可复用的缓冲区）如何被维护，是一个体现性能优化的关键细节。</p><h4 id="4-3-1-指针引用-vs-内存拷贝"><a href="#4-3-1-指针引用-vs-内存拷贝" class="headerlink" title="4.3.1 指针引用 vs. 内存拷贝"></a>4.3.1 指针引用 vs. 内存拷贝</h4><p><code>raw_key_</code> 的更新方式有两种，取决于当前解码的条目类型：</p><table><thead><tr><th align="left">情况</th><th align="left">对应方法</th><th align="left">内存操作</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><strong>重启点的 Key</strong></td><td align="left"><code>SetKey(..., copy=false)</code></td><td align="left"><strong>指针引用</strong></td><td align="left">完整的 key 在原始数据块中是连续的，直接指向它可以避免不必要的内存拷贝，效率更高。</td></tr><tr><td align="left"><strong>增量编码的 Key</strong></td><td align="left"><code>TrimAppend(...)</code></td><td align="left"><strong>构建/拷贝</strong></td><td align="left">完整的 key 在原始数据块中不是连续存放的，必须在迭代器自己的缓冲区中通过“截断+追加”的方式重新构建出来。</td></tr></tbody></table><p>这种双模操作的设计，体现了在可能的情况下（重启点）尽量避免内存拷贝，在必要的情况下（增量编码）高效复用缓冲区的优化思想。</p><h2 id="五、-总结与展望"><a href="#五、-总结与展望" class="headerlink" title="五、 总结与展望"></a>五、 总结与展望</h2><p>通过本次学习，我们深入了解了 RocksDB 中最基本的数据单元——数据块（Data Block）的设计与实现。其核心在于<strong>前缀压缩</strong>和<strong>重启点</strong>机制。</p><ul><li> <strong>构建 (<code>BlockBuilder</code>)</strong>: 将有序的键值对通过增量编码和重启点策略，打包成紧凑的二进制块。</li><li> <strong>解析 (<code>Block</code> &amp; <code>DataBlockIter</code>)</strong>: 通过解析块尾的重启点数组，实现了块内高效的“二分查找+线性扫描”式查找，并通过状态化的迭代器缓冲区 <code>raw_key_</code> 高效地完成前缀解压。</li></ul><p>理解了单个数据块的运作原理后，我们下次学习将进入更高的层次，去探索 <code>BlockBasedTable</code> 是如何将这些数据块、索引块、过滤器块等组织成一个完整的 SST 文件，并提供高效的读写服务的。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/KV%E6%95%B0%E6%8D%AE%E5%BA%93/">KV数据库</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/KV%E6%95%B0%E6%8D%AE%E5%BA%93/">KV数据库</a> <a class="hover-with-bg" href="/tags/RocksDB/">RocksDB</a></div></div><p class="note note-warning">转载请注明出处</p><div class="post-prevnext row"><article class="post-prev col-6"><a href="/2025/08/22/RocksDB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%85%A5BlockBasedTable-%E4%BA%8C/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">RocksDB源码学习:深入BlockBasedTable(二)</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"> <a href="/2025/08/19/RocksDB%E4%B8%ADCuckoo-Table%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E8%A7%A3%E6%9E%90/"><span class="hidden-mobile">RocksDB中Cuckoo Table技术内幕解析</span> <span class="visible-mobile">下一篇</span><i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4> <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"> <span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"> <input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a><i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"> <span id="leancloud-site-pv-container" style="display:none">总访问量<span id="leancloud-site-pv"></span> 次</span> <span id="leancloud-site-uv-container" style="display:none">总访客数<span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer="defer" src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer="defer">
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2025/08/20/RocksDB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%85%A5BlockBasedTable-%E4%B8%80/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'rGBkjlpYFYPq3Mztf0uHkwm2-gzGzoHsz'
    var app_key = 'IwuJ6qbGLXA8pB3qeHHjuDT3'
    var server_url = 'https://rgbkjlpy.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>