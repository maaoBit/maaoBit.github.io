<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[笔记]Linux Socket Filtering aka Berkeley Packet Filter (BPF)</title>
    <link href="/2021/02/24/%E7%AC%94%E8%AE%B0-Linux-Socket-Filtering-aka-Berkeley-Packet-Filter-BPF/"/>
    <url>/2021/02/24/%E7%AC%94%E8%AE%B0-Linux-Socket-Filtering-aka-Berkeley-Packet-Filter-BPF/</url>
    
    <content type="html"><![CDATA[<p>本文是阅读<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">linux/Documentation/networking/filter.txt</a>文档的笔记。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>BPF(Berkeley Packet Filter)允许用户空间程序将过滤器（filter）附加到任何套接字（socket）上，来允许或禁止某些类型的数据通过套接字。可以通过<code>SO_DETACH_FILTER</code>从套接字中卸载filter，但一般使用不到，因为一旦socket关闭，其上的filter也会自动移除。</p><p>可以通过<code>SO_LOCK_FILTER</code>选项为某个filter加锁，加锁后，filter不可在更改或移除，直到socket关闭。</p><p><code>tcpdump</code>通过<code>libpcap</code>的内部编译器生成可加载的指令，通过调用<code>SO_ATTACH_FILTER</code>加载到内核中。</p><p>除socket外，BPF可附加到内核其他地方：netfilter的xt_bpf，内核qdisc层的cls_bpf。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><pre><code class="hljs rust"><span class="hljs-comment">// 在&lt;linux/filter.h&gt;中</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span></span> &#123;<span class="hljs-comment">/* Filter block */</span>__<span class="hljs-built_in">u16</span>code;   <span class="hljs-comment">/* Actual filter code */</span>__<span class="hljs-built_in">u8</span>jt;<span class="hljs-comment">/* Jump true */</span>__<span class="hljs-built_in">u8</span>jf;<span class="hljs-comment">/* Jump false */</span>__<span class="hljs-built_in">u32</span>k;      <span class="hljs-comment">/* Generic multiuse field (一般为code需要使用的value）*/</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog</span></span> &#123;<span class="hljs-comment">/* Required for SO_ATTACH_FILTER. */</span>unsigned short   len;<span class="hljs-comment">/* Number of filter blocks */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span></span> __user *filter;&#125;;</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="hljs angelscript">#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;linux/if_ether.h&gt;<span class="hljs-comment">/* ... */</span><span class="hljs-comment">/* From the example above: tcpdump -i em1 port 22 -dd */</span>struct sock_filter code[] = &#123;&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000000c</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">0x000086dd</span> &#125;,&#123; <span class="hljs-number">0x30</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000014</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000084</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000006</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0x00000011</span> &#125;,&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000036</span> &#125;,&#123; <span class="hljs-number">0x15</span>, <span class="hljs-number">14</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000016</span> &#125;,&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000038</span> &#125;,&#123; <span class="hljs-number">0x15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0x00000016</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0x00000800</span> &#125;,&#123; <span class="hljs-number">0x30</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000017</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000084</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000006</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">0x00000011</span> &#125;,&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000014</span> &#125;,&#123; <span class="hljs-number">0x45</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00001fff</span> &#125;,&#123; <span class="hljs-number">0xb1</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000000e</span> &#125;,&#123; <span class="hljs-number">0x48</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000000e</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000016</span> &#125;,&#123; <span class="hljs-number">0x48</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000010</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0x00000016</span> &#125;,&#123; <span class="hljs-number">0x06</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000ffff</span> &#125;,&#123; <span class="hljs-number">0x06</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000000</span> &#125;,&#125;;struct sock_fprog bpf = &#123;.len = ARRAY_SIZE(code),.filter = code,&#125;;  <span class="hljs-comment">/*创建PF_PACKET socket*/</span> sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));<span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">/* ... bail out ... */</span>ret = setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;bpf, sizeof(bpf));<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">/* ... bail out ... */</span><span class="hljs-comment">/* ... */</span>close(sock);</code></pre><p><code>setsockopt</code>系统调用，调用<code>SO_DETACH_FILTER</code>时无需参数，调用<code>SO_LOCK_FILTER</code>时，参数为1或0：</p><pre><code class="hljs lisp">* setsockopt(<span class="hljs-name">sockfd</span>, SOL_SOCKET, SO_ATTACH_FILTER, <span class="hljs-symbol">&amp;val</span>, sizeof(<span class="hljs-name">val</span>))<span class="hljs-comment">;</span>* setsockopt(<span class="hljs-name">sockfd</span>, SOL_SOCKET, SO_DETACH_FILTER, <span class="hljs-symbol">&amp;val</span>, sizeof(<span class="hljs-name">val</span>))<span class="hljs-comment">; </span>* setsockopt(<span class="hljs-name">sockfd</span>, SOL_SOCKET, SO_LOCK_FILTER,   <span class="hljs-symbol">&amp;val</span>, sizeof(<span class="hljs-name">val</span>))<span class="hljs-comment">;</span></code></pre><p><code>libpcap</code>覆盖了绝大多数socket filter的用例，一般直接使用<code>libpcap</code>进行开发。</p><h2 id="BPF引擎（engine）和指令集"><a href="#BPF引擎（engine）和指令集" class="headerlink" title="BPF引擎（engine）和指令集"></a>BPF引擎（engine）和指令集</h2><p><code>tool/bpf/</code>目录下的<code>bgf_asm</code>可以用来编写底层的filter。</p><p>BPF包含一个32位累加器A、32位寄存器X、16 x  32位的临时存储：</p><pre><code class="hljs lsl">Element          DescriptionA                <span class="hljs-number">32</span> bit wide accumulatorX                <span class="hljs-number">32</span> bit wide X registerM[]              <span class="hljs-number">16</span> x <span class="hljs-number">32</span> bit wide misc registers aka <span class="hljs-string">&quot;scratch memory</span><span class="hljs-string">                 store&quot;</span>, addressable from <span class="hljs-number">0</span> to <span class="hljs-number">15</span></code></pre><p><code>bpf_asm</code>转换生成的程序是一个如下结构的数组。</p><pre><code class="hljs angelscript">op:<span class="hljs-number">16</span>, jt:<span class="hljs-number">8</span>, jf:<span class="hljs-number">8</span>, k:<span class="hljs-number">32</span></code></pre><ul><li><code>op</code> ： 16位的指令</li><li><code>jt</code> <code>jf</code>:  jump if true, jump if false</li><li><code>k</code>：参数</li></ul><p>在<code> linux/filter.h</code>下的指令以及相应的寻址方式：</p><pre><code class="hljs angelscript">Instruction      Addressing mode      Description  ld               <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>       Load word <span class="hljs-built_in">int</span>o A  ldi              <span class="hljs-number">4</span>                    Load word <span class="hljs-built_in">int</span>o A  ldh              <span class="hljs-number">1</span>, <span class="hljs-number">2</span>                 Load half-word <span class="hljs-built_in">int</span>o A  ldb              <span class="hljs-number">1</span>, <span class="hljs-number">2</span>                 Load byte <span class="hljs-built_in">int</span>o A  ldx              <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">12</span>          Load word <span class="hljs-built_in">int</span>o X  ldxi             <span class="hljs-number">4</span>                    Load word <span class="hljs-built_in">int</span>o X  ldxb             <span class="hljs-number">5</span>                    Load byte <span class="hljs-built_in">int</span>o X  st               <span class="hljs-number">3</span>                    Store A <span class="hljs-built_in">int</span>o M[]  stx              <span class="hljs-number">3</span>                    Store X <span class="hljs-built_in">int</span>o M[]  jmp              <span class="hljs-number">6</span>                    Jump to label  ja               <span class="hljs-number">6</span>                    Jump to label  jeq              <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>          Jump on A == &lt;x&gt;  jneq             <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                Jump on A != &lt;x&gt;  jne              <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                Jump on A != &lt;x&gt;  jlt              <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                Jump on A &lt;  &lt;x&gt;  jle              <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                Jump on A &lt;= &lt;x&gt;  jgt              <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>          Jump on A &gt;  &lt;x&gt;  jge              <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>          Jump on A &gt;= &lt;x&gt;  jset             <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>          Jump on A &amp;  &lt;x&gt;  add              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A + &lt;x&gt;  sub              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A - &lt;x&gt;  mul              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A * &lt;x&gt;  div              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A / &lt;x&gt;  mod              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A % &lt;x&gt;  neg                                   !A  <span class="hljs-keyword">and</span>              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A &amp; &lt;x&gt;  <span class="hljs-keyword">or</span>               <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A | &lt;x&gt;  <span class="hljs-keyword">xor</span>              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A ^ &lt;x&gt;  lsh              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A &lt;&lt; &lt;x&gt;  rsh              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A &gt;&gt; &lt;x&gt;  tax                                   Copy A <span class="hljs-built_in">int</span>o X  txa                                   Copy X <span class="hljs-built_in">int</span>o A  ret              <span class="hljs-number">4</span>, <span class="hljs-number">11</span>                Return</code></pre><pre><code class="hljs angelscript">Addressing mode  Syntax               Description <span class="hljs-number">0</span>               x/%x                 Register X <span class="hljs-number">1</span>               [k]                  BHW at byte offset k <span class="hljs-keyword">in</span> the packet（BHW,二进制半字，<span class="hljs-number">32</span>位） <span class="hljs-number">2</span>               [x + k]              BHW at the offset X + k <span class="hljs-keyword">in</span> the packet <span class="hljs-number">3</span>               M[k]                 Word at offset k <span class="hljs-keyword">in</span> M[] <span class="hljs-number">4</span>               #k                   Literal value stored <span class="hljs-keyword">in</span> k <span class="hljs-number">5</span>               <span class="hljs-number">4</span>*([k]&amp;<span class="hljs-number">0xf</span>)          Lower nibble * <span class="hljs-number">4</span> at byte offset k <span class="hljs-keyword">in</span> the packet <span class="hljs-number">6</span>               L                    Jump label L <span class="hljs-number">7</span>               #k,Lt,Lf             Jump to Lt <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>, otherwise jump to Lf <span class="hljs-number">8</span>               x/%x,Lt,Lf           Jump to Lt <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>, otherwise jump to Lf <span class="hljs-number">9</span>               #k,Lt                Jump to Lt <span class="hljs-keyword">if</span> predicate <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span><span class="hljs-number">10</span>               x/%x,Lt              Jump to Lt <span class="hljs-keyword">if</span> predicate <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span><span class="hljs-number">11</span>               a/%a                 Accumulator A<span class="hljs-number">12</span>               extension            BPF extension</code></pre><p>BPF extension寻址配合load指令使用，将查询的结果放到累加器A中。可能的BPF extension包括：</p><pre><code class="hljs routeros">Extension                             Descriptionlen                                   skb-&gt;lenproto                                 skb-&gt;protocoltype                                  skb-&gt;pkt_typepoff                                  Payload start offsetifidx                                 skb-&gt;dev-&gt;ifindexnla                                   Netlink attribute of<span class="hljs-built_in"> type </span>X with offset Anlan                                  Nested Netlink attribute of<span class="hljs-built_in"> type </span>X with offset Amark                                  skb-&gt;markqueue                                 skb-&gt;queue_mappinghatype                                skb-&gt;dev-&gt;typerxhash                                skb-&gt;hashcpu                                   raw_smp_processor_id()vlan_tci                              skb_vlan_tag_get(skb)vlan_avail                            skb_vlan_tag_present(skb)vlan_tpid                             skb-&gt;vlan_protorand                                  prandom_u32()</code></pre><p>一些例子：</p><pre><code class="hljs avrasm">** ARP packets:  ldh [<span class="hljs-number">12</span>]          <span class="hljs-comment">/*以太网首部跳过12byte，load half-word，也就是2byte，是以太网的类型字段*/</span>  jne <span class="hljs-meta">#0x806, drop  /* 不等于0x806则跳转 */</span>  <span class="hljs-keyword">ret</span> <span class="hljs-meta">#-1</span>  drop: <span class="hljs-keyword">ret</span> <span class="hljs-meta">#0</span>** IPv4 TCP packets:  ldh [<span class="hljs-number">12</span>]  jne <span class="hljs-meta">#0x800, drop</span>  ldb [<span class="hljs-number">23</span>] <span class="hljs-comment">/*以太网frame跳过14byte的首部，在到9byte（1byte是8bit）的ip首部，load 1byte，是IP数据包的协议类型*/</span>  jneq <span class="hljs-meta">#6, drop</span>  <span class="hljs-keyword">ret</span> <span class="hljs-meta">#-1</span>  drop: <span class="hljs-keyword">ret</span> <span class="hljs-meta">#0</span>** (Accelerated) VLAN w/ id <span class="hljs-number">10</span>:  <span class="hljs-keyword">ld</span> vlan_tci  <span class="hljs-comment">/*这里用的是extensions的寻址，skb_vlan_tag_get(skb)*/</span>  jneq <span class="hljs-meta">#10, drop</span>  <span class="hljs-keyword">ret</span> <span class="hljs-meta">#-1</span>  drop: <span class="hljs-keyword">ret</span> <span class="hljs-meta">#0</span></code></pre><p>上面的代码可以由<code>bpf_asm</code>进行转换，生成<code>xt_bpf</code>和<code>cls_bpf</code>可以直接加载的code</p><pre><code class="hljs angelscript">$ ./bpf_asm foo<span class="hljs-number">4</span>,<span class="hljs-number">40</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">12</span>,<span class="hljs-number">21</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2054</span>,<span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">4294967295</span>,<span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>,In copy <span class="hljs-keyword">and</span> paste C-like output:$ ./bpf_asm -c foo&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000000c</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0x00000806</span> &#125;,&#123; <span class="hljs-number">0x06</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0xffffffff</span> &#125;,&#123; <span class="hljs-number">0x06</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0000000000</span> &#125;,</code></pre><p><code>tools/bpf/bpf_dbg</code>可以使用pcap文件来调试bpf程序。</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core<span class="hljs-regexp">/bpf_jit_enable  /</span>*启动*/echo <span class="hljs-number">2</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core<span class="hljs-regexp">/bpf_jit_enable  /</span>*编译的opcode会输入到内核日志中*/</code></pre><p>当开启<code>CONFIG_BPF_JIT_ALWAYS_ON</code>时，<code>bpf_jit_enable</code>始终为1。</p><p><code>tools/bpf/</code>下的<code>bpf_jit_disasm</code>可以将内核日志中的十六进制转换成反汇编。</p><pre><code class="hljs angelscript"># ./bpf_jit_disasm -o<span class="hljs-number">70</span> bytes emitted <span class="hljs-keyword">from</span> JIT compiler (pass:<span class="hljs-number">3</span>, flen:<span class="hljs-number">6</span>)ffffffffa0069c8f + &lt;x&gt;:   <span class="hljs-number">0</span>:push   %rbp<span class="hljs-number">55</span>   <span class="hljs-number">1</span>:mov    %rsp,%rbp<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5   <span class="hljs-number">4</span>:sub    $<span class="hljs-number">0x60</span>,%rsp<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">60</span>   <span class="hljs-number">8</span>:mov    %rbx,<span class="hljs-number">-0x8</span>(%rbp)<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">5</span>d f8   c:mov    <span class="hljs-number">0x68</span>(%rdi),%r9d<span class="hljs-number">44</span> <span class="hljs-number">8</span>b <span class="hljs-number">4f</span> <span class="hljs-number">68</span>  <span class="hljs-number">10</span>:sub    <span class="hljs-number">0x6c</span>(%rdi),%r9d<span class="hljs-number">44</span> <span class="hljs-number">2</span>b <span class="hljs-number">4f</span> <span class="hljs-number">6</span>c  <span class="hljs-number">14</span>:mov    <span class="hljs-number">0xd8</span>(%rdi),%r8<span class="hljs-number">4</span>c <span class="hljs-number">8</span>b <span class="hljs-number">87</span> d8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">1</span>b:mov    $<span class="hljs-number">0xc</span>,%esibe <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">20</span>:callq  <span class="hljs-number">0xffffffffe0ff9442</span>e8 <span class="hljs-number">1</span>d <span class="hljs-number">94</span> ff e0  <span class="hljs-number">25</span>:cmp    $<span class="hljs-number">0x800</span>,%eax<span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">2</span>a:jne    <span class="hljs-number">0x0000000000000042</span><span class="hljs-number">75</span> <span class="hljs-number">16</span>  <span class="hljs-number">2</span>c:mov    $<span class="hljs-number">0x17</span>,%esibe <span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">31</span>:callq  <span class="hljs-number">0xffffffffe0ff945e</span>e8 <span class="hljs-number">28</span> <span class="hljs-number">94</span> ff e0  <span class="hljs-number">36</span>:cmp    $<span class="hljs-number">0x1</span>,%eax<span class="hljs-number">83</span> f8 <span class="hljs-number">01</span>  <span class="hljs-number">39</span>:jne    <span class="hljs-number">0x0000000000000042</span><span class="hljs-number">75</span> <span class="hljs-number">07</span>  <span class="hljs-number">3</span>b:mov    $<span class="hljs-number">0xffff</span>,%eaxb8 ff ff <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">40</span>:jmp    <span class="hljs-number">0x0000000000000044</span>eb <span class="hljs-number">02</span>  <span class="hljs-number">42</span>:<span class="hljs-keyword">xor</span>    %eax,%eax<span class="hljs-number">31</span> c0  <span class="hljs-number">44</span>:leaveqc9  <span class="hljs-number">45</span>:retqc3</code></pre><h2 id="BPF内核实现"><a href="#BPF内核实现" class="headerlink" title="BPF内核实现"></a>BPF内核实现</h2><p>内核中解释器使用的指令和上面描述的BPF指令集不同，更接近底层架构，以便获得更高的性能，被称为eBPF或internal BPF。新指令集可以通过“受限C语言”编写程序，并通过GCC/LLVM编译为eBPF，<strong>C -&gt; eBPF -&gt; native code</strong></p><p>内核调用<code>bpf_prog_create()</code>和<code>bpf_prog_destroy()</code>来创建和销毁filter，调用<code>BPG_PROG_RUN(filter,ctx)</code>宏进行解释与运行，这些都是透明的。参数filter为<code>bpf_prog</code>结构体，由<code>bpf_prog_create()</code>返回，ctx为给定的上下文，例如skb的指针。<code>bpf_check_classic()</code>的所有约束和限制会在转换之前执行。</p><p>eBPF的主要变化：</p><ul><li><p>寄存器数量由2变为10</p><ul><li>R0：保存eBPF或辅助函数的返回值</li><li>R1-R5：存储调用辅助函数需要传递的参数</li><li>R6-R9：用于存储中间值，辅助函数将保持这些寄存器不改变</li><li>R10：只读寄存器，包含访问BPF stack的指针</li></ul><p>只有一个主eBPF程序，它只能调用其他辅助函数，而非其他BPF程序（注：现在应该支持BPF之间的调用）</p></li><li><p>寄存器由32位变为64位</p><ul><li>仍然保留了32位的ALU操作语义，使用64位寄存器的32位子寄存器保存</li></ul></li><li><p>条件jt/jf替换为jt/fall-through</p></li><li><p>引入<code>bpf_call</code>和寄存器传递约定</p><ul><li><p>调用辅助函数前，根据辅助函数规定，将参数存储至R1-R5上。R1-R5寄存器映射到CPU的寄存器上，调用无性能损耗。</p></li><li><p>调用辅助函数后，R1-R5不可读，R0存储返回的值，R6-R9正在调用期间不会改变。eBPF程序只有1一个<code>ctx</code>，保存在R1上。</p></li></ul><pre><code class="hljs armasm"><span class="hljs-symbol">u64</span> <span class="hljs-built_in">f1</span>() &#123; return (*_<span class="hljs-built_in">f2</span>)(<span class="hljs-number">1</span>)<span class="hljs-comment">; &#125;</span><span class="hljs-symbol">u64</span> <span class="hljs-built_in">f2</span>(u64 a) &#123; return <span class="hljs-built_in">f3</span>(a + <span class="hljs-number">1</span>, a)<span class="hljs-comment">; &#125;</span><span class="hljs-symbol">u64</span> <span class="hljs-built_in">f3</span>(u64 a, u64 b) &#123; return a - b<span class="hljs-comment">; &#125;</span><span class="hljs-comment">// f2的eBPF看起来类似</span><span class="hljs-symbol"> f2:</span>  bpf_mov <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R1</span>  bpf_add <span class="hljs-built_in">R1</span>, <span class="hljs-number">1</span>  bpf_call <span class="hljs-built_in">f3</span>  bpf_exit</code></pre></li></ul><p>x86_64中，64位寄存器与HW寄存器的对应：</p><pre><code class="hljs x86asm"><span class="hljs-built_in">R0</span> - <span class="hljs-built_in">rax</span><span class="hljs-built_in">R1</span> - <span class="hljs-built_in">rdi</span><span class="hljs-built_in">R2</span> - <span class="hljs-built_in">rsi</span><span class="hljs-built_in">R3</span> - <span class="hljs-built_in">rdx</span><span class="hljs-built_in">R4</span> - <span class="hljs-built_in">rcx</span><span class="hljs-built_in">R5</span> - <span class="hljs-built_in">r8</span><span class="hljs-built_in">R6</span> - <span class="hljs-built_in">rbx</span><span class="hljs-built_in">R7</span> - <span class="hljs-built_in">r13</span><span class="hljs-built_in">R8</span> - <span class="hljs-built_in">r14</span><span class="hljs-built_in">R9</span> - <span class="hljs-built_in">r15</span><span class="hljs-built_in">R10</span> - <span class="hljs-built_in">rbp</span></code></pre><p>x86_64下，C语言</p><pre><code class="hljs angelscript">u64 bpf_filter(u64 ctx)&#123;    <span class="hljs-keyword">return</span> foo(ctx, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) + bar(ctx, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);&#125;</code></pre><p>对应的BPF</p><pre><code class="hljs apache"><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">6</span>, R<span class="hljs-number">1</span> /* save ctx */<span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">2</span>, <span class="hljs-number">2</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">3</span>, <span class="hljs-number">3</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">4</span>, <span class="hljs-number">4</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">5</span>, <span class="hljs-number">5</span><span class="hljs-attribute">bpf_call</span> foo<span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">7</span>, R<span class="hljs-number">0</span> /* save foo() return value */<span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">1</span>, R<span class="hljs-number">6</span> /* restore ctx for next call */<span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">2</span>, <span class="hljs-number">6</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">3</span>, <span class="hljs-number">7</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">4</span>, <span class="hljs-number">8</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">5</span>, <span class="hljs-number">9</span><span class="hljs-attribute">bpf_call</span> bar<span class="hljs-attribute">bpf_add</span> R<span class="hljs-number">0</span>, R<span class="hljs-number">7</span><span class="hljs-attribute">bpf_exit</span></code></pre><p>对应的JIT编译结果</p><pre><code class="hljs mel">push %rbpmov %rsp,%rbpsub $0x228,%rspmov %rbx,<span class="hljs-number">-0x228</span>(%rbp)mov %r13,<span class="hljs-number">-0x220</span>(%rbp)mov %rdi,%rbxmov $0x2,%esimov $0x3,%edxmov $0x4,%ecxmov $0x5,%r8dcallq foomov %rax,%r13mov %rbx,%rdimov $0x6,%esimov $0x7,%edxmov $0x8,%ecxmov $0x9,%r8dcallq baradd %r13,%raxmov <span class="hljs-number">-0x228</span>(%rbp),%rbxmov <span class="hljs-number">-0x220</span>(%rbp),%r13leaveqretq</code></pre><p>为了保证eBPF程序迅速停止，eBPF程序限制只能有4096条指令。（注：现在限制扩到了100W）</p><p>根据不同用例，ctx中的内容不同。对于seccomp，R1指向<code>seccomp_data</code>；对于BPF filters，R1指向<code>skb</code>。</p><blockquote><p>注：Seccomp(全称：secure computing mode)在2.6.12版本中引入linux内核，作为一种安全机制，主要用于限制用户态程序对系统调用的滥用。由于限制太强，后引入seccomp-bpf，借助bpf规则来过滤系统调用。</p></blockquote><p>指令的转换：</p><pre><code class="hljs apache"><span class="hljs-attribute">op</span>:<span class="hljs-number">16</span>, jt:<span class="hljs-number">8</span>, jf:<span class="hljs-number">8</span>, k:<span class="hljs-number">32</span>    ==&gt;    op:<span class="hljs-number">8</span>, dst_reg:<span class="hljs-number">4</span>, src_reg:<span class="hljs-number">4</span>, <span class="hljs-literal">off</span>:<span class="hljs-number">16</span>, imm:<span class="hljs-number">32</span></code></pre><ul><li>目前内部BPF（eBPF）指令已有87条。</li><li>内部BPF是一个通用的RISC指令集。复杂的过滤器可能耗尽寄存器，需要使用到堆栈。</li><li>程序的安全性通过两个步骤确定：深度优先搜索，禁止循环，并进行其他CFG验证；从第一个指令开始，探测所有可能的路径，观察寄存器和堆栈的状态变化。</li></ul><h2 id="eBPF-opcode"><a href="#eBPF-opcode" class="headerlink" title="eBPF opcode"></a>eBPF opcode</h2><h3 id="对于arithmetic-和jump指令"><a href="#对于arithmetic-和jump指令" class="headerlink" title="对于arithmetic 和jump指令"></a>对于arithmetic 和jump指令</h3><pre><code class="hljs asciidoc"><span class="hljs-code">+----------------+</span>--------<span class="hljs-code">+--------------------+</span>|   4 bits       |  1 bit |   3 bits           || operation code | source | instruction class  |<span class="hljs-code">+----------------+</span>--------<span class="hljs-code">+--------------------+</span>(MSB)                                      (LSB)</code></pre><p>最后3bit的LSB存储指令类别：</p><pre><code class="hljs apache"><span class="hljs-attribute">Classic</span> BPF classes:    eBPF classes: <span class="hljs-attribute">BPF_LD</span>    <span class="hljs-number">0</span>x<span class="hljs-number">00</span>          BPF_LD    <span class="hljs-number">0</span>x<span class="hljs-number">00</span> <span class="hljs-attribute">BPF_LDX</span>   <span class="hljs-number">0</span>x<span class="hljs-number">01</span>          BPF_LDX   <span class="hljs-number">0</span>x<span class="hljs-number">01</span> <span class="hljs-attribute">BPF_ST</span>    <span class="hljs-number">0</span>x<span class="hljs-number">02</span>          BPF_ST    <span class="hljs-number">0</span>x<span class="hljs-number">02</span> <span class="hljs-attribute">BPF_STX</span>   <span class="hljs-number">0</span>x<span class="hljs-number">03</span>          BPF_STX   <span class="hljs-number">0</span>x<span class="hljs-number">03</span> <span class="hljs-attribute">BPF_ALU</span>   <span class="hljs-number">0</span>x<span class="hljs-number">04</span>          BPF_ALU   <span class="hljs-number">0</span>x<span class="hljs-number">04</span> <span class="hljs-attribute">BPF_JMP</span>   <span class="hljs-number">0</span>x<span class="hljs-number">05</span>          BPF_JMP   <span class="hljs-number">0</span>x<span class="hljs-number">05</span> <span class="hljs-attribute">BPF_RET</span>   <span class="hljs-number">0</span>x<span class="hljs-number">06</span>          BPF_JMP<span class="hljs-number">32</span> <span class="hljs-number">0</span>x<span class="hljs-number">06</span> <span class="hljs-attribute">BPF_MISC</span>  <span class="hljs-number">0</span>x<span class="hljs-number">07</span>          BPF_ALU<span class="hljs-number">64</span> <span class="hljs-number">0</span>x<span class="hljs-number">07</span></code></pre><ul><li>当PF_CLASS(code) == BPF_ALU或BPF_JMP时，第四位（source部分）可以为</li></ul><pre><code class="hljs mipsasm"><span class="hljs-keyword">BPF_K </span>    <span class="hljs-number">0x00</span> <span class="hljs-keyword">BPF_X </span>    <span class="hljs-number">0x08</span>* in classic <span class="hljs-keyword">BPF, </span>this means: <span class="hljs-keyword">BPF_SRC(code) </span>== <span class="hljs-keyword">BPF_X </span>- use register X as source operand <span class="hljs-keyword">BPF_SRC(code) </span>== <span class="hljs-keyword">BPF_K </span>- use <span class="hljs-number">32</span>-<span class="hljs-keyword">bit </span>immediate as source operand* in eBPF, this means: <span class="hljs-keyword">BPF_SRC(code) </span>== <span class="hljs-keyword">BPF_X </span>- use <span class="hljs-string">&#x27;src_reg&#x27;</span> register as source operand <span class="hljs-keyword">BPF_SRC(code) </span>== <span class="hljs-keyword">BPF_K </span>- use <span class="hljs-number">32</span>-<span class="hljs-keyword">bit </span>immediate as source operand</code></pre><ul><li>当BPF_CLASS(code) == BPF_ALU或BPF_ALU64 ，前四位BPF_OP(code)可以为：</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">BPF_ADD</span>   <span class="hljs-number">0</span>x<span class="hljs-number">00</span><span class="hljs-attribute">BPF_SUB</span>   <span class="hljs-number">0</span>x<span class="hljs-number">10</span><span class="hljs-attribute">BPF_MUL</span>   <span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-attribute">BPF_DIV</span>   <span class="hljs-number">0</span>x<span class="hljs-number">30</span><span class="hljs-attribute">BPF_OR</span>    <span class="hljs-number">0</span>x<span class="hljs-number">40</span><span class="hljs-attribute">BPF_AND</span>   <span class="hljs-number">0</span>x<span class="hljs-number">50</span><span class="hljs-attribute">BPF_LSH</span>   <span class="hljs-number">0</span>x<span class="hljs-number">60</span><span class="hljs-attribute">BPF_RSH</span>   <span class="hljs-number">0</span>x<span class="hljs-number">70</span><span class="hljs-attribute">BPF_NEG</span>   <span class="hljs-number">0</span>x<span class="hljs-number">80</span><span class="hljs-attribute">BPF_MOD</span>   <span class="hljs-number">0</span>x<span class="hljs-number">90</span><span class="hljs-attribute">BPF_XOR</span>   <span class="hljs-number">0</span>xa<span class="hljs-number">0</span><span class="hljs-attribute">BPF_MOV</span>   <span class="hljs-number">0</span>xb<span class="hljs-number">0</span>  /* eBPF only: mov reg to reg */<span class="hljs-attribute">BPF_ARSH</span>  <span class="hljs-number">0</span>xc<span class="hljs-number">0</span>  /* eBPF only: sign extending shift right */<span class="hljs-attribute">BPF_END</span>   <span class="hljs-number">0</span>xd<span class="hljs-number">0</span>  /* eBPF only: endianness conversion */</code></pre><p>当BPF_CLASS(code) == BPF_JMP或BPF_JMP32，前四位BPF_OP(code)可以为：</p><pre><code class="hljs apache"><span class="hljs-attribute">BPF_JA</span>    <span class="hljs-number">0</span>x<span class="hljs-number">00</span>  /* BPF_JMP only */<span class="hljs-attribute">BPF_JEQ</span>   <span class="hljs-number">0</span>x<span class="hljs-number">10</span><span class="hljs-attribute">BPF_JGT</span>   <span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-attribute">BPF_JGE</span>   <span class="hljs-number">0</span>x<span class="hljs-number">30</span><span class="hljs-attribute">BPF_JSET</span>  <span class="hljs-number">0</span>x<span class="hljs-number">40</span><span class="hljs-attribute">BPF_JNE</span>   <span class="hljs-number">0</span>x<span class="hljs-number">50</span>  /* eBPF only: jump != */<span class="hljs-attribute">BPF_JSGT</span>  <span class="hljs-number">0</span>x<span class="hljs-number">60</span>  /* eBPF only: signed &#x27;&gt;&#x27; */<span class="hljs-attribute">BPF_JSGE</span>  <span class="hljs-number">0</span>x<span class="hljs-number">70</span>  /* eBPF only: signed &#x27;&gt;=&#x27; */<span class="hljs-attribute">BPF_CALL</span>  <span class="hljs-number">0</span>x<span class="hljs-number">80</span>  /* eBPF BPF_JMP only: function call */<span class="hljs-attribute">BPF_EXIT</span>  <span class="hljs-number">0</span>x<span class="hljs-number">90</span>  /* eBPF BPF_JMP only: function return */<span class="hljs-attribute">BPF_JLT</span>   <span class="hljs-number">0</span>xa<span class="hljs-number">0</span>  /* eBPF only: unsigned &#x27;&lt;&#x27; */<span class="hljs-attribute">BPF_JLE</span>   <span class="hljs-number">0</span>xb<span class="hljs-number">0</span>  /* eBPF only: unsigned &#x27;&lt;=&#x27; */<span class="hljs-attribute">BPF_JSLT</span>  <span class="hljs-number">0</span>xc<span class="hljs-number">0</span>  /* eBPF only: signed &#x27;&lt;&#x27; */<span class="hljs-attribute">BPF_JSLE</span>  <span class="hljs-number">0</span>xd<span class="hljs-number">0</span>  /* eBPF only: signed &#x27;&lt;=&#x27; */</code></pre><ul><li><code>BPF_XOR | BPF_K | BPF_ALU </code>在cBPF中表示<code>A^=imm32</code>，在eBPF中表示<code>src_reg = (u32) src_reg ^ (u32) imm32</code>（这段看代码，应该是<code>dst_reg = (u32) dst_reg ^ (u32) imm32</code>?） BPF_JMP | BPF_EXIT表示直接退出。</li></ul><h3 id="对于load和store指令"><a href="#对于load和store指令" class="headerlink" title="对于load和store指令"></a>对于load和store指令</h3><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+-------------------+</span>| 3 bits | 2 bits |   3 bits          ||  mode  |  size  | instruction class |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+-------------------+</span>(MSB)                             (LSB)</code></pre><p>size部分</p><pre><code class="hljs mipsasm"> <span class="hljs-keyword">BPF_W </span>  <span class="hljs-number">0x00</span>    <span class="hljs-comment">/* word */</span> <span class="hljs-keyword">BPF_H </span>  <span class="hljs-number">0x08</span>    <span class="hljs-comment">/* half word */</span> <span class="hljs-keyword">BPF_B </span>  <span class="hljs-number">0x10</span>    <span class="hljs-comment">/* byte */</span> <span class="hljs-keyword">BPF_DW </span> <span class="hljs-number">0x18</span>    <span class="hljs-comment">/* eBPF only, double word */</span> <span class="hljs-keyword">B </span> - <span class="hljs-number">1</span> <span class="hljs-keyword">byte</span><span class="hljs-keyword">H </span> - <span class="hljs-number">2</span> <span class="hljs-keyword">byte</span><span class="hljs-keyword">W </span> - <span class="hljs-number">4</span> <span class="hljs-keyword">byte</span><span class="hljs-keyword">DW </span>- <span class="hljs-number">8</span> <span class="hljs-keyword">byte </span>(eBPF only)</code></pre><p>mode部分</p><pre><code class="hljs apache"><span class="hljs-attribute">BPF_IMM</span>  <span class="hljs-number">0</span>x<span class="hljs-number">00</span>  /* used for <span class="hljs-number">32</span>-bit mov in classic BPF and <span class="hljs-number">64</span>-bit in eBPF */<span class="hljs-attribute">BPF_ABS</span>  <span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-attribute">BPF_IND</span>  <span class="hljs-number">0</span>x<span class="hljs-number">40</span><span class="hljs-attribute">BPF_MEM</span>  <span class="hljs-number">0</span>x<span class="hljs-number">60</span><span class="hljs-attribute">BPF_LEN</span>  <span class="hljs-number">0</span>x<span class="hljs-number">80</span>  /* classic BPF only, reserved in eBPF */<span class="hljs-attribute">BPF_MSH</span>  <span class="hljs-number">0</span>xa<span class="hljs-number">0</span>  /* classic BPF only, reserved in eBPF */<span class="hljs-attribute">BPF_XADD</span> <span class="hljs-number">0</span>xc<span class="hljs-number">0</span>  /* eBPF only, exclusive add */</code></pre><p>两个非通用指令<code>BPF_ABS | &lt;size&gt; | BPF_LD</code>和<code>BPF_IND | &lt;size&gt; | BPF_LD</code>，用于访问数据包中的字段。使用条件：</p><p>1）ctx是指向<code>sk_buff</code>的指针</p><p>2）R0-R6规定为：R0保存获取的结果，R6保存<code>sk_buff</code>指针，R1-R5为暂存器，不可存储需要跨指令的数据（即执行完指令后R1-R5中的数据不可用）</p><p>3）访问超出<code>sk_buff-&gt;data</code>范围 ，自动跳出</p><pre><code class="hljs armasm"><span class="hljs-symbol">BPF_IND</span> <span class="hljs-title">| BPF_W |</span> BPF_LD means:  <span class="hljs-built_in">R0</span> = ntohl(*(u32 *) (((struct sk_buff *) <span class="hljs-built_in">R6</span>)-&gt;<span class="hljs-meta">data</span> + src_reg + imm32))  <span class="hljs-keyword">and</span> <span class="hljs-built_in">R1</span> - <span class="hljs-built_in">R5</span> were scratched.</code></pre><p>其他的一些例子</p><pre><code class="hljs gcode">BPF_MEM | &lt;size&gt; | BPF_STX:  *<span class="hljs-comment">(size *)</span> <span class="hljs-comment">(dst_reg + off)</span> = src_regBPF_MEM | &lt;size&gt; | BPF_ST:   *<span class="hljs-comment">(size *)</span> <span class="hljs-comment">(dst_reg + off)</span> = im<span class="hljs-name">m32</span>BPF_MEM | &lt;size&gt; | BPF_LDX:  dst_reg = *<span class="hljs-comment">(size *)</span> <span class="hljs-comment">(src_reg + off)</span>BPF_XADD | BPF_W  | BPF_STX: lock xadd *<span class="hljs-comment">(u32 *)</span><span class="hljs-comment">(dst_reg + off16)</span> += src_regBPF_XADD | BPF_DW | BPF_STX: lock xadd *<span class="hljs-comment">(u64 *)</span><span class="hljs-comment">(dst_reg + off16)</span> += src_reg</code></pre><blockquote><p>注：在<a href="https://elixir.bootlin.com/linux/v5.8.7/source/include/linux/filter.h#L265">linux/filter.h</a>下都有。ST是从dst到src，LD是从src到dst</p></blockquote><p>BPF_LD | BPF_DW | BPF_IMM（获取一个8字节的立即数）会跨两个指令。</p><pre><code class="hljs livescript"><span class="hljs-comment">#define BPF_LD_IMM64_RAW(DST, SRC, IMM)\</span>((struct bpf_insn) &#123;<span class="hljs-string">\</span>.code  = BPF_LD | BPF_DW | BPF_IMM,<span class="hljs-string">\</span>.dst_reg = DST,<span class="hljs-string">\</span>.src_reg = SRC,<span class="hljs-string">\</span>.<span class="hljs-literal">off</span>   = <span class="hljs-number">0</span>,<span class="hljs-string">\</span>.imm   = (__u32) (IMM) &#125;),<span class="hljs-string">\</span>((struct bpf_insn) &#123;<span class="hljs-string">\</span>.code  = <span class="hljs-number">0</span>, <span class="hljs-comment">/* zero is reserved opcode */</span><span class="hljs-string">\</span>.dst_reg = <span class="hljs-number">0</span>,<span class="hljs-string">\</span>.src_reg = <span class="hljs-number">0</span>,<span class="hljs-string">\</span>.<span class="hljs-literal">off</span>   = <span class="hljs-number">0</span>,<span class="hljs-string">\</span>.imm   = ((__u64) (IMM)) &gt;&gt; <span class="hljs-number">32</span> &#125;)</code></pre><h2 id="eBPF验证器"><a href="#eBPF验证器" class="headerlink" title="eBPF验证器"></a>eBPF验证器</h2><p>两步：</p><p>1）做DAG（有向无环图）检测，确保无循环以及CFG（控制流保护）</p><p>2）从第一条指令开始，模拟执行所有可能的指令路径，观察寄存器和堆栈状态</p><p>一些检测规则：</p><p>1）不允许指针相加</p><p>2）不允许读未初始化的寄存器</p><p>3）辅助函数调用后R1-R5为不可读状态</p><p>4）load/store指令需要相应的寄存器类型为<code>PTR_TO_CTX</code>、 <code>PTR_TO_MAP</code>、<code>PTR_TO_STACK</code>是才有效 （比如不能是标量），并且会有边界和对齐检测</p><p>5）程序开始时，R1类型为<code>PTR_TO_CTX</code>（ctx指针）。可以通过<code>is_valid_access()</code>回调函数，自定义验证方式，来进行边界与对齐检测。另外类型为<code>PTR_TO_STACK</code>（堆栈指针）时，访问边界为[-MAX_BPF_STACK, 0)</p><p>6）堆栈只有在写入才能读取（对应<code>PTR_TO_STACK</code>类型寄存器的操作）</p><p>7）<code>bpf_verifier_ops-&gt;get_func_proto()</code>可以用来自定义“函数调用”时的“参数检测”（检测寄存器），返回值保存在R0</p><p>8）eBPF对seccomp与socket filter的验证方式是相同的，而cBPF对于seccomp，需要先进行<code>seccomp verifier</code>，在进行其他的验证。</p><p>详细代码<code>kernel/bpf/verifier.c</code></p><h2 id="寄存器值追踪"><a href="#寄存器值追踪" class="headerlink" title="寄存器值追踪"></a>寄存器值追踪</h2><p>验证器追踪寄存器中的值，检测值可能的范围。追踪由<code>include/linux/bpf_verifier.h</code>下的<code>struct bpf_reg_state</code>完成，寄存器值可能的类型：<code>NOT_INIT</code>、<code>SCALAR_VALUE</code>、<code>point</code>。<code>point</code>由分为：</p><pre><code class="hljs livecodeserver">PTR_TO_CTX          Pointer <span class="hljs-built_in">to</span> bpf_context. CONST_PTR_TO_MAP    Pointer <span class="hljs-built_in">to</span> struct bpf_map.  <span class="hljs-string">&quot;Const&quot;</span> because arithmetic                     <span class="hljs-keyword">on</span> <span class="hljs-title">these</span> <span class="hljs-title">pointers</span> <span class="hljs-title">is</span> <span class="hljs-title">forbidden</span>. PTR_TO_MAP_VALUE    Pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">value</span> stored <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> map <span class="hljs-keyword">element</span>. PTR_TO_MAP_VALUE_OR_NULL                     Either <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> map <span class="hljs-built_in">value</span>, <span class="hljs-keyword">or</span> <span class="hljs-literal">NULL</span>; map accesses                     (see section <span class="hljs-string">&#x27;eBPF maps&#x27;</span>, below) <span class="hljs-literal">return</span> this type,                     which becomes <span class="hljs-keyword">a</span> PTR_TO_MAP_VALUE when checked != <span class="hljs-literal">NULL</span>.                     Arithmetic <span class="hljs-keyword">on</span> <span class="hljs-title">these</span> <span class="hljs-title">pointers</span> <span class="hljs-title">is</span> <span class="hljs-title">forbidden</span>. PTR_TO_STACK        Frame pointer. PTR_TO_PACKET       skb-&gt;data. PTR_TO_PACKET_END   skb-&gt;data + headlen; arithmetic forbidden. PTR_TO_SOCKET       Pointer <span class="hljs-built_in">to</span> struct bpf_sock_ops, implicitly refcounted. PTR_TO_SOCKET_OR_NULL                     Either <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">socket</span>, <span class="hljs-keyword">or</span> <span class="hljs-literal">NULL</span>; <span class="hljs-built_in">socket</span> lookup                     returns this type, which becomes <span class="hljs-keyword">a</span> PTR_TO_SOCKET when                     checked != <span class="hljs-literal">NULL</span>. PTR_TO_SOCKET is reference-counted,                     so programs must release <span class="hljs-keyword">the</span> reference through <span class="hljs-keyword">the</span>                     <span class="hljs-built_in">socket</span> release <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">before</span> <span class="hljs-title">the</span> <span class="hljs-title">end</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">program</span>.</span>                     Arithmetic <span class="hljs-keyword">on</span> <span class="hljs-title">these</span> <span class="hljs-title">pointers</span> <span class="hljs-title">is</span> <span class="hljs-title">forbidden</span>.</code></pre><blockquote><p>对于PTR_TO_SOCKET和PTR_TO_SOCKET_OR_NULL，在程序结束前需要使用socket release方法，释放引用</p></blockquote><p>对于指针偏移的验证：</p><p>1）分<code>fixed offset</code>和<code>variable offset</code></p><p>2）验证器对<code>vaiable offset</code>需要记录的状态：</p><pre><code class="hljs angelscript">* minimum <span class="hljs-keyword">and</span> maximum values as unsigned* minimum <span class="hljs-keyword">and</span> maximum values as signed* 一个<span class="hljs-string">&#x27;tnum&#x27;</span>值，由两个u64组成，第一个为value，是具体的值；第二个为mask，用<span class="hljs-number">1</span>标记未知的位。比如知道寄存器前<span class="hljs-number">56</span>位为<span class="hljs-number">0</span>，后<span class="hljs-number">8</span>位不知道，则表示为tnum(<span class="hljs-number">0x0</span>,<span class="hljs-number">0xff</span>)，表示省略了高位的<span class="hljs-number">0</span></code></pre><ul><li>状态可以通过逻辑运算更新，例如上的<code>tnum(0x0,0xff)</code>寄存器与<code>0x40</code>取或，则变为<code>tnum(0x40,0xbf)</code></li><li>状态可以根据条件分支判断，例如在<code>SCALAR_VALUE</code>(offset)大于8为true的分支，寄存器的<code>umin_value</code>为9</li><li>对<code>PTR_TO_PACKET</code>类型的寄存器，使用id标识某个偏移量。例如寄存器A拷贝到寄存器B，两者有相同偏移量，因此offset id相同，一次验证即可。</li><li><code>PTR_TO_MAP_VALUE_OR_NULL</code>类寄存器（存储bgp  map中查询返回的指针），也使用id标识，一旦验证某个id标识非NULL，其他副本也相同。除此外，可以做对齐验证。</li><li><code>PTR_TO_SOCKET</code>和<code>PTR_TO_SOCKET_OR_NULL</code>类寄存器（存储socket中查询返回的指针）也使用id标识，与<code>PTR_TO_MAP_VALUE_OR_NULL</code>类似。另外，对非NULL的id，可将其副本调用socket release方法。</li></ul><h2 id="数据包的直接访问"><a href="#数据包的直接访问" class="headerlink" title="数据包的直接访问"></a>数据包的直接访问</h2><p>对于<code>cls_bpf</code>与<code>act_bpf</code>，允许通过<code>skb-&gt;date</code>和<code>skb-&gt;data_end</code>直接访问数据包。</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span>:  r<span class="hljs-number">4</span> = *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">80</span>)  /* load skb-&gt;data_end */<span class="hljs-attribute">2</span>:  r<span class="hljs-number">3</span> = *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">76</span>)  /* load skb-&gt;data */<span class="hljs-attribute">3</span>:  r<span class="hljs-number">5</span> = r<span class="hljs-number">3</span><span class="hljs-attribute">4</span>:  r<span class="hljs-number">5</span> += <span class="hljs-number">14</span><span class="hljs-attribute">5</span>:  if r<span class="hljs-number">5</span> &gt; r<span class="hljs-number">4</span> goto pc+<span class="hljs-number">16</span><span class="hljs-attribute">R1</span>=ctx R<span class="hljs-number">3</span>=pkt(id=<span class="hljs-number">0</span>,<span class="hljs-literal">off</span>=<span class="hljs-number">0</span>,r=<span class="hljs-number">14</span>) R<span class="hljs-number">4</span>=pkt_end R<span class="hljs-number">5</span>=pkt(id=<span class="hljs-number">0</span>,<span class="hljs-literal">off</span>=<span class="hljs-number">14</span>,r=<span class="hljs-number">14</span>) R<span class="hljs-number">10</span>=fp<span class="hljs-attribute">6</span>:  r<span class="hljs-number">0</span> = *(u<span class="hljs-number">16</span> *)(r<span class="hljs-number">3</span> +<span class="hljs-number">12</span>) /* access <span class="hljs-number">12</span> and <span class="hljs-number">13</span> bytes of the packet */</code></pre><p>根据第5行的判断，验证器可以标记R3为<code>pkg(id=0,off=0,r=14)</code>，其中id=0表示未向寄存器添加<code>variablle offset</code>，off=0表示未向寄存器添加<code>fixed  offset</code>，r=14表示安全访问范围为[R3,R3+14]。同理R5标记为<code>pkt(id=0,off=14,r=14)</code></p><h2 id="eBPF-maps"><a href="#eBPF-maps" class="headerlink" title="eBPF maps"></a>eBPF maps</h2><p><code>map</code>用于内核和用户空间之间共享不同类型的数据。<code>map</code>存储使用BPF系统调用：</p><pre><code class="hljs sql">- <span class="hljs-keyword">create</span> a <span class="hljs-keyword">map</span> <span class="hljs-keyword">with</span> given <span class="hljs-keyword">type</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">attributes</span>  map_fd = bpf(BPF_MAP_CREATE, <span class="hljs-keyword">union</span> bpf_attr *<span class="hljs-keyword">attr</span>, u32 <span class="hljs-keyword">size</span>)  <span class="hljs-keyword">using</span> <span class="hljs-keyword">attr</span>-&gt;map_type, <span class="hljs-keyword">attr</span>-&gt;key_size, <span class="hljs-keyword">attr</span>-&gt;value_size, <span class="hljs-keyword">attr</span>-&gt;max_entries  <span class="hljs-keyword">returns</span> process-<span class="hljs-keyword">local</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">descriptor</span> <span class="hljs-keyword">or</span> negative <span class="hljs-keyword">error</span>- lookup <span class="hljs-keyword">key</span> <span class="hljs-keyword">in</span> a given <span class="hljs-keyword">map</span>  err = bpf(BPF_MAP_LOOKUP_ELEM, <span class="hljs-keyword">union</span> bpf_attr *<span class="hljs-keyword">attr</span>, u32 <span class="hljs-keyword">size</span>)  <span class="hljs-keyword">using</span> <span class="hljs-keyword">attr</span>-&gt;map_fd, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">key</span>, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">value</span>  <span class="hljs-keyword">returns</span> zero <span class="hljs-keyword">and</span> stores <span class="hljs-keyword">found</span> elem <span class="hljs-keyword">into</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">or</span> negative <span class="hljs-keyword">error</span>- <span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">key</span>/<span class="hljs-keyword">value</span> pair <span class="hljs-keyword">in</span> a given <span class="hljs-keyword">map</span>  err = bpf(BPF_MAP_UPDATE_ELEM, <span class="hljs-keyword">union</span> bpf_attr *<span class="hljs-keyword">attr</span>, u32 <span class="hljs-keyword">size</span>)  <span class="hljs-keyword">using</span> <span class="hljs-keyword">attr</span>-&gt;map_fd, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">key</span>, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">value</span>  <span class="hljs-keyword">returns</span> zero <span class="hljs-keyword">or</span> negative <span class="hljs-keyword">error</span>- find <span class="hljs-keyword">and</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">element</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">in</span> a given <span class="hljs-keyword">map</span>  err = bpf(BPF_MAP_DELETE_ELEM, <span class="hljs-keyword">union</span> bpf_attr *<span class="hljs-keyword">attr</span>, u32 <span class="hljs-keyword">size</span>)  <span class="hljs-keyword">using</span> <span class="hljs-keyword">attr</span>-&gt;map_fd, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">key</span>- <span class="hljs-keyword">to</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">map</span>: <span class="hljs-keyword">close</span>(fd)  Exiting process will <span class="hljs-keyword">delete</span> maps automatically</code></pre><p><code>map</code>类型：hash、array、bloom  filter、redix-tree等；<code>map</code>定义：</p><pre><code class="hljs routeros">. type. max number of elements. key size <span class="hljs-keyword">in</span> bytes. value size <span class="hljs-keyword">in</span> bytes</code></pre><h2 id="修剪（pruning）"><a href="#修剪（pruning）" class="headerlink" title="修剪（pruning）"></a>修剪（pruning）</h2><p>验证器（verifier）在对新分支进行分析时，会比较当前指令之前检测过的状态，如果当前（寄存器）状态属于之前检测过的状态，这个分支就被认为可信，被修剪。</p><h2 id="理解验证器的日志"><a href="#理解验证器的日志" class="headerlink" title="理解验证器的日志"></a>理解验证器的日志</h2><ul><li><p>不可达指令</p><pre><code class="hljs mipsasm">static struct <span class="hljs-keyword">bpf_insn </span>prog[] = &#123;   <span class="hljs-keyword">BPF_EXIT_INSN(),</span><span class="hljs-keyword"> </span>  <span class="hljs-keyword">BPF_EXIT_INSN(),</span><span class="hljs-keyword"> </span>&#125;;<span class="hljs-symbol"> Error:</span>   unreachable <span class="hljs-keyword">insn </span><span class="hljs-number">1</span></code></pre></li><li><p>读取未初始化的寄存器</p><pre><code class="hljs subunit">  BPF_MOV64_REG(BPF_REG_0, BPF_REG_2),  BPF_EXIT_INSN(),Error:  0: (bf) r0 = r2  R2 !read_ok</code></pre></li><li><p>结束程序前未初始化寄存器</p><pre><code class="hljs awk">  BPF_MOV64_REG(BPF_REG_2, BPF_REG_1),  BPF_EXIT_INSN(),Error:  <span class="hljs-number">0</span>: (bf) r2 = r1  <span class="hljs-number">1</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span>  R0 !read_ok</code></pre></li><li><p>越界访问堆栈</p><pre><code class="hljs apache">  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> +<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">invalid</span> stack <span class="hljs-literal">off</span>=<span class="hljs-number">8</span> size=<span class="hljs-number">8</span></code></pre></li><li><p>未初始化堆栈（<code>map_lookup_elem</code>调用，R1为文件描述符，R2为key，读取了R2指向的未初始化堆栈）</p><pre><code class="hljs apache"><span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),<span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),<span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),<span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:<span class="hljs-attribute">0</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span><span class="hljs-attribute">1</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span><span class="hljs-attribute">2</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0</span><span class="hljs-attribute">3</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span><span class="hljs-attribute">invalid</span> indirect read from stack <span class="hljs-literal">off</span> -<span class="hljs-number">8</span>+<span class="hljs-number">0</span> size <span class="hljs-number">8</span></code></pre></li><li><p>无效的<code>map_fd</code>（R1中的0x0）</p><pre><code class="hljs apache"> <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">2</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">3</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0</span>  <span class="hljs-attribute">4</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span>  <span class="hljs-attribute">fd</span> <span class="hljs-number">0</span> is not pointing to valid bpf_map</code></pre></li><li><p><code>map_lookup_elem</code>的返回值未进行验证（保存在R0）</p><pre><code class="hljs apache"><span class="hljs-attribute">map</span> element:  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">2</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">3</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0</span>  <span class="hljs-attribute">4</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span>  <span class="hljs-attribute">5</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">R0</span> invalid mem access &#x27;map_value_or_null&#x27;</code></pre></li><li><p><code>BPF_ST_MEM</code>以错误的对齐方式进行访问</p><pre><code class="hljs apache"><span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),  <span class="hljs-attribute">BPF_JMP_IMM</span>(BPF_JEQ, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">2</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">3</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <span class="hljs-attribute">4</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span>  <span class="hljs-attribute">5</span>: (<span class="hljs-number">15</span>) if r<span class="hljs-number">0</span> == <span class="hljs-number">0</span>x<span class="hljs-number">0</span> goto pc+<span class="hljs-number">1</span>   <span class="hljs-attribute">R0</span>=map_ptr R<span class="hljs-number">10</span>=fp  <span class="hljs-attribute">6</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">4</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">misaligned</span> access <span class="hljs-literal">off</span> <span class="hljs-number">4</span> size <span class="hljs-number">8</span></code></pre></li><li><p><code>map_lookup_elem</code>结果R0为NULL，pc+2，执行指令8，会出现错误</p><pre><code class="hljs apache"> <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),  <span class="hljs-attribute">BPF_JMP_IMM</span>(BPF_JEQ, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>),  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">2</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">3</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <span class="hljs-attribute">4</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span>  <span class="hljs-attribute">5</span>: (<span class="hljs-number">15</span>) if r<span class="hljs-number">0</span> == <span class="hljs-number">0</span>x<span class="hljs-number">0</span> goto pc+<span class="hljs-number">2</span>   <span class="hljs-attribute">R0</span>=map_ptr R<span class="hljs-number">10</span>=fp  <span class="hljs-attribute">6</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">7</span>: (<span class="hljs-number">95</span>) exit  <span class="hljs-attribute">from</span> <span class="hljs-number">5</span> to <span class="hljs-number">8</span>: R<span class="hljs-number">0</span>=imm<span class="hljs-number">0</span> R<span class="hljs-number">10</span>=fp  <span class="hljs-attribute">8</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">0</span>) = <span class="hljs-number">1</span>  <span class="hljs-attribute">R0</span> invalid mem access &#x27;imm&#x27;</code></pre></li><li><p><code>bpf_sk_lookup_tcp</code>三个参数<code>R1=ptr_to_ctx;R2=ptr_to_mem</code>，将R0置NULL前未检测、未释放引用</p><pre><code class="hljs apache">  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">2</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_STX_MEM</span>(BPF_W, BPF_REG_<span class="hljs-number">10</span>, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">4</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">5</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EMIT_CALL</span>(BPF_FUNC_sk_lookup_tcp),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">2</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = r<span class="hljs-number">2</span>  <span class="hljs-attribute">2</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">3</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">4</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">3</span> = <span class="hljs-number">4</span>  <span class="hljs-attribute">5</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">4</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">6</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">5</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">7</span>: (<span class="hljs-number">85</span>) call bpf_sk_lookup_tcp#<span class="hljs-number">65</span>  <span class="hljs-attribute">8</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">9</span>: (<span class="hljs-number">95</span>) exit  <span class="hljs-attribute">Unreleased</span> reference id=<span class="hljs-number">1</span>, alloc_insn=<span class="hljs-number">7</span></code></pre></li><li><p>R0未检测是否为NULL就返回了</p><pre><code class="hljs apache">  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">2</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_STX_MEM</span>(BPF_W, BPF_REG_<span class="hljs-number">10</span>, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">4</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">5</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EMIT_CALL</span>(BPF_FUNC_sk_lookup_tcp),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">2</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = r<span class="hljs-number">2</span>  <span class="hljs-attribute">2</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">3</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">4</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">3</span> = <span class="hljs-number">4</span>  <span class="hljs-attribute">5</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">4</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">6</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">5</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">7</span>: (<span class="hljs-number">85</span>) call bpf_sk_lookup_tcp#<span class="hljs-number">65</span>  <span class="hljs-attribute">8</span>: (<span class="hljs-number">95</span>) exit  <span class="hljs-attribute">Unreleased</span> reference id=<span class="hljs-number">1</span>, alloc_insn=<span class="hljs-number">7</span></code></pre></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>内核附带测试模块，包含用于cBPF和eBPF的各种测试，在<code>lib/test_bpf.c</code>中 ，通过<code>Kconfig</code>启动：</p><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_TEST_BPF</span>=m</code></pre><p>编译安装测试模块后，可以通过<code>insmod</code>与<code>modprobe</code>执行测试。结果在内核日志（dmesg）中可以找到。</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p><img src="/img/bpf-2021022401.jpg"></p><p><img src="/img/bpf-2021022402.jpg"></p><p><img src="/img/bpf-2021022403.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>BPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calico BGP功能介绍：实现</title>
    <link href="/2021/02/23/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/02/23/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>Calico作为一种常用的Kubernetes网络插件，使用BGP协议对各节点的容器网络进行路由交换。本文是《Calico BGP功能介绍》系列的第二篇，介绍Calico中BGP功能的实现。所使用的Calico版本为v3.17.3。</p><a id="more"></a><h2 id="Calico-BGP功能"><a href="#Calico-BGP功能" class="headerlink" title="Calico BGP功能"></a>Calico BGP功能</h2><h3 id="BGP-Peer"><a href="#BGP-Peer" class="headerlink" title="BGP Peer"></a>BGP Peer</h3><p>Calico中通过定义BGP Peer对象，来建立BGP连接。BGP Peer对象的主要参数如下：</p><table><thead><tr><th align="left">参数</th><th>描述</th></tr></thead><tbody><tr><td align="left">node</td><td>指定BGP Peer应用在哪个node上。如果指定此字段，则为node级别，否则为global级别。</td></tr><tr><td align="left">peerIP</td><td>指定远端的Peer地址，可以是IP加端口的形式，端口可选。支持IPV4和IPV6。</td></tr><tr><td align="left">asNumber</td><td>远端Peer的AS号。</td></tr><tr><td align="left">nodeSelector</td><td>用于通过标签来选择一组node，作为BGP Peer应用的节点，注意这里的node为Calico中的node，而非K8s中的node。如果指定了此字段，则node应该为空。</td></tr><tr><td align="left">peerSelector</td><td>用于通过标签来选择一组node（同样为Calico中的node），作为远端Peer的节点。如果指定了此字段，则peerIP和asNumber都应该为空。</td></tr><tr><td align="left">keepOriginalNextHop</td><td>对于EBGP，保持并转发原始的next hop，不将自身加入到Path中。</td></tr><tr><td align="left">password</td><td>BGP会话的身份验证。</td></tr></tbody></table><p>在过去的版本，Calico中包含了<code>BGP Peer</code>对象和<code>Global BGP Peer</code>对象，目前已统一为<code>BGP Peer</code>对象，根据是指定<code>node</code>参数还是<code>nodeSelector</code>参数来区分。</p><h3 id="BGP-Configuration"><a href="#BGP-Configuration" class="headerlink" title="BGP Configuration"></a>BGP Configuration</h3><p>除了BGP Peer外，Calico通过BGP Configuration对象来控制全局的BGP行为。主要参数包括：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>nodeToNodeMeshEnabled</td><td>开启Calico节点之间的node-to-node mesh。</td><td>true</td></tr><tr><td>asNumber</td><td>Calico node默认的节点AS。</td><td>64512</td></tr><tr><td>serviceClusterIPs</td><td>Calico需要对外BGP的service ClusterIP地址段。</td><td></td></tr><tr><td>serviceExternalIPs</td><td>Calico需要对外BGP的service ExternalIPs地址段。</td><td></td></tr><tr><td>communities</td><td>用于定义BGP community，由name和value组成，value支持标准community以及large community。</td><td></td></tr><tr><td>prefixAdvertisements</td><td>指定网段与community的隶属关系，可以通过communities中的name指定，也可以通过community value直接指定。</td><td></td></tr></tbody></table><p>默认情况下，Calico所有节点通过IBGP来交换各个节点的workload（容器）路由信息，由于从IBGP Peer中学习到的路由不会被再次转发，因此需要使用node-to-node mesh的方式两两互连。</p><p><code>serviceClusterIPs</code>和<code>serviceExternalIPs</code>字段的功能类似于MetalLB的BGP模式，可以将K8s Service的访问地址（ClusterIP和ExternalIP）BGP到集群外的设备（例如TOR）。结合ECMP，可以将外部访问K8s Service的流量负载到K8s节点上，由Kube-proxy转发到真正的容器后端。</p><p><code>communities</code>与<code>prefixAdvertisements</code>可以控制Calico BGP路由的community字段，支持<a href="http://www.rfc-editor.org/info/rfc1997">RFC 1997</a>中的<code>well-known communities</code>。使用样例如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">communities:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">bgp-large-community</span>  <span class="hljs-attr">value:</span> <span class="hljs-number">63400</span><span class="hljs-string">:300:100</span><span class="hljs-attr">prefixAdvertisements:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">cidr:</span> <span class="hljs-number">172.218</span><span class="hljs-number">.4</span><span class="hljs-number">.0</span><span class="hljs-string">/26</span>  <span class="hljs-attr">communities:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">bgp-large-community</span>  <span class="hljs-bullet">-</span> <span class="hljs-number">63400</span><span class="hljs-string">:120</span></code></pre><h2 id="Calico-BGP-功能实现"><a href="#Calico-BGP-功能实现" class="headerlink" title="Calico BGP 功能实现"></a>Calico BGP 功能实现</h2><p>简单来说，Calico是通过confd组件来渲染bird的配置文件，动态配置bird，从而实现BGP功能。其中，为了使confd支持Calico后端存储，在原生的confd上，添加了类型为Calico的backend，主要逻辑是watch后端BGPPeer、BGPConfiguration、Node资源（由libcalico-go中的<code>bgpsyncer</code>实现），缓存到内存中，供confd渲染使用。</p><p><img src="/img/calico-bgp1.png"></p><p>可以看到，主要的配置文件分为6个，其中IPv4和IPv6各3个。以IPv4为例，IPv6类似，bird.cfg为bird的主要配置文件，包括几个主要部分：</p><p>1）全局的配置：包括route id、debug属性、listen bgp port，这一部分主要由node、bgp configuration中的字段产生。</p><p>2）固定的协议配置：包括kernel、device、direct；其功能在上一篇<a href="https://maao.cloud/2021/01/26/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9ABIRD%E7%AE%80%E4%BB%8B/">Calico BGP功能介绍：BIRD简介</a>中有详细介绍。</p><pre><code class="hljs nim"><span class="hljs-comment"># Configure synchronization between routing tables and kernel.</span>protocol kernel &#123;  learn;             <span class="hljs-comment"># Learn all alien routes from the kernel</span>  persist;           <span class="hljs-comment"># Don&#x27;t remove routes on bird shutdown</span>  scan time <span class="hljs-number">2</span>;       <span class="hljs-comment"># Scan kernel routing table every 2 seconds</span>  <span class="hljs-keyword">import</span> all;  <span class="hljs-keyword">export</span> filter calico_kernel_programming; <span class="hljs-comment"># Default is export none</span>  graceful restart;  <span class="hljs-comment"># Turn on graceful restart to reduce potential flaps in</span>                     <span class="hljs-comment"># routes when reloading BIRD configuration.  With a full</span>                     <span class="hljs-comment"># automatic mesh, there is no way to prevent BGP from</span>                     <span class="hljs-comment"># flapping since multiple nodes update their BGP</span>                     <span class="hljs-comment"># configuration at the same time, GR is not guaranteed to</span>                     <span class="hljs-comment"># work correctly in this scenario.</span>  merge paths on;    <span class="hljs-comment"># Allow export multipath routes (ECMP)</span>&#125;<span class="hljs-comment"># Watch interface up/down events.</span>protocol device &#123;&#123;&#123;- <span class="hljs-keyword">template</span> <span class="hljs-string">&quot;LOGGING&quot;</span>&#125;&#125;  scan time <span class="hljs-number">2</span>;    <span class="hljs-comment"># Scan interfaces every 2 seconds</span>&#125;protocol direct &#123;&#123;&#123;- <span class="hljs-keyword">template</span> <span class="hljs-string">&quot;LOGGING&quot;</span>&#125;&#125;  <span class="hljs-keyword">interface</span> -<span class="hljs-string">&quot;cali*&quot;</span>, -<span class="hljs-string">&quot;kube-ipvs*&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>; <span class="hljs-comment"># Exclude cali* and kube-ipvs* but</span>                                          <span class="hljs-comment"># include everything else.  In</span>                                          <span class="hljs-comment"># IPVS-mode, kube-proxy creates a</span>                                          <span class="hljs-comment"># kube-ipvs0 interface. We exclude</span>                                          <span class="hljs-comment"># kube-ipvs0 because this interface</span>                                          <span class="hljs-comment"># gets an address for every in use</span>                                          <span class="hljs-comment"># cluster IP. We use static routes</span>                                          <span class="hljs-comment"># for when we legitimately want to</span>                                          <span class="hljs-comment"># export cluster IPs.</span>&#125;</code></pre><p>kernel中export用到了filter <code>calico_kernel_programming</code>，其定义在bird_ipam.cfg.template中。主要分两部分：</p><p>一是获取<code>/calico/rejectcidrs</code>的值，对属于此cidr范围内的路由reject。<code>/calico/rejectcidrs</code>的值是由confd的<code>calico backend</code>写入，其值为BGP Configuration中设置的<code>serviceClusterIPs</code>和<code>serviceExternalIPs</code>。在开启了Calico的<a href="https://docs.projectcalico.org/networking/advertise-service-ips">advertise service</a>功能后（通过配置BGP Configuration的<code>serviceClusterIPs</code>和<code>serviceClusterIPs</code>），可以避免将其他节点发送过来的Service路由写入kernel路由表中。</p><p>二是对于属于Calico IPPool的路由，根据Calico IPPool设置的模式（VXLAN或IPIP），来判断是否需要写入kernel路由表。对于VXLAN模式，由felix负责数据包的路由，不再写入kernel中；对于IPIP，根据Calico IPPool的IPIP配置（Always、Cross-subnet）以及BGP协议的bgp_next_hop属性（判断是否跨网段），决定是生成IPIP的路由，还是非IPIP路由。这里使用到的bird参数<code>krt_tunnel</code>来传递IPIP设备，<code>krt_tunnel</code>并非原生bird所提供的参数，而是由Calico添加的，以实现bird支持IPIP协议。</p><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$network_key</span> <span class="hljs-attr">:</span>= printf <span class="hljs-string">&quot;/bgp/v1/host/%s/network_v4&quot;</span> (<span class="hljs-name">getenv</span> <span class="hljs-string">&quot;NODENAME&quot;</span>)&#125;&#125;</span><span class="xml">filter calico_kernel_programming &#123;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $reject_key <span class="hljs-attr">:</span>= <span class="hljs-string">&quot;/rejectcidrs&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if ls $reject_key&#125;&#125;</span><span class="xml">  # Don&#x27;t program static routes into kernel.</span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> range ls $reject_key&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $parts <span class="hljs-attr">:</span>= split . <span class="hljs-string">&quot;-&quot;</span>&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $cidr <span class="hljs-attr">:</span>= join $parts <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;</span><span class="xml">  if ( net ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$cidr</span>&#125;&#125;</span><span class="xml"> ) then &#123; reject; &#125;</span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if exists $network_key&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$network</span> <span class="hljs-attr">:</span>= getv $network_key&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">range</span> ls <span class="hljs-string">&quot;/v1/ipam/v4/pool&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data</span> <span class="hljs-attr">:</span>= json (<span class="hljs-name">getv</span> (<span class="hljs-name">printf</span> <span class="hljs-string">&quot;/v1/ipam/v4/pool/%s&quot;</span> .))&#125;&#125;</span><span class="xml">  if ( net ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.cidr</span>&#125;&#125;</span><span class="xml"> ) then &#123;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if $data.vxlan_mode&#125;&#125;</span><span class="xml">    # Don&#x27;t program VXLAN routes into the kernel - these are handled by Felix.</span><span class="xml">    reject;</span><span class="xml">  &#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> else if $data.ipip_mode&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> eq $data.ipip_mode <span class="hljs-string">&quot;cross-subnet&quot;</span>&#125;&#125;</span><span class="xml">    if defined(bgp_next_hop) &amp;&amp; ( bgp_next_hop ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$network</span>&#125;&#125;</span><span class="xml"> ) then</span><span class="xml">      krt_tunnel = &quot;&quot;;                     </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination in ipPool, mode is cross sub-net, route from-host on subnet, do not use IPIP */&#125;&#125;</span><span class="xml">    else</span><span class="xml">      krt_tunnel = &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.ipip</span>&#125;&#125;</span><span class="xml">&quot;;       </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination in ipPool, mode is cross sub-net, route from-host off subnet, set the tunnel (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> IPIP not enabled, value will be <span class="hljs-string">&quot;&quot;</span>) */&#125;&#125;</span><span class="xml">    accept;</span><span class="xml">  &#125; </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> else&#125;&#125;</span><span class="xml">    krt_tunnel = &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.ipip</span>&#125;&#125;</span><span class="xml">&quot;;         </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination in ipPool, mode not cross sub-net, set the tunnel (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> IPIP not enabled, value will be <span class="hljs-string">&quot;&quot;</span>) */&#125;&#125;</span><span class="xml">    accept;</span><span class="xml">  &#125; </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> else&#125;&#125;</span><span class="xml">    krt_tunnel = &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.ipip</span>&#125;&#125;</span><span class="xml">&quot;;         </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination in ipPool, mode field is not present, set the tunnel (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> IPIP not enabled, value will be <span class="hljs-string">&quot;&quot;</span>) */&#125;&#125;</span><span class="xml">    accept;</span><span class="xml">  &#125; </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">end</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-tag">&#123;&#123;/* <span class="hljs-name">End</span> <span class="hljs-name">of</span> <span class="hljs-name">&#x27;exists $network_key&#x27;</span> *<span class="hljs-name">/</span>&#125;&#125;</span><span class="xml">  accept;                                  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination is not in any ipPool, accept  */&#125;&#125;</span><span class="xml">&#125;</span></code></pre><p>3）BGP协议部分。</p><p>BGP协议部分是最主要的部分，使用了bird的template，template中export方向使用filter <code>calico_export_to_bgp_peers</code>过滤，其定义在bird_ipam.cfg.template中，主要功能是：先调用bird.cfg.template中的<code>apply_communities()</code>方法（根据BGP Configuration中的<code>communities</code>和<code>prefixAdvertisements</code>字段），为发送的BGP路由添加community参数；调用bird_aggr.cfg.template中的<code>calico_aggr()</code>方法，确保宣告的BGP路由的目标地址段为完整的block；最后，判断路由的目标地址是否在<code>/calico/staticroutes</code>或Calico IPPool所指定的地址范围内，若在，则accept，其他的reject。</p><blockquote><p>Calico中block是容器IP资源池最小的分配单位，最初Calico会为每个节点分配一个block，当某个节点block使用完，则会再次为节点分配一个block</p></blockquote><pre><code class="hljs handlebars"><span class="xml">filter calico_export_to_bgp_peers &#123;</span><span class="xml">  # filter code terminates when it calls `accept;` or `reject;`, call apply_communities() before calico_aggr()</span><span class="xml">  apply_communities();</span><span class="xml">  calico_aggr();</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $static_key <span class="hljs-attr">:</span>= <span class="hljs-string">&quot;/staticroutes&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if ls $static_key&#125;&#125;</span><span class="xml">  # Export static routes.</span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> range ls $static_key&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $parts <span class="hljs-attr">:</span>= split . <span class="hljs-string">&quot;-&quot;</span>&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $cidr <span class="hljs-attr">:</span>= join $parts <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;</span><span class="xml">  if ( net ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$cidr</span>&#125;&#125;</span><span class="xml"> ) then &#123; accept; &#125;</span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">range</span> ls <span class="hljs-string">&quot;/v1/ipam/v4/pool&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data</span> <span class="hljs-attr">:</span>= json (<span class="hljs-name">getv</span> (<span class="hljs-name">printf</span> <span class="hljs-string">&quot;/v1/ipam/v4/pool/%s&quot;</span> .))&#125;&#125;</span><span class="xml">  if ( net ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.cidr</span>&#125;&#125;</span><span class="xml"> ) then &#123;</span><span class="xml">    accept;</span><span class="xml">  &#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="xml">  reject;</span><span class="xml">&#125;</span></code></pre><p><code>/calico/staticroutes</code>中的值也是由confd的<code>calico backend</code>写入，其值主要包含两部分：BGP Configuration中设置的<code>serviceClusterIPs</code>和<code>serviceExternalIPs</code>；<code>externalTrafficPolicy=Local</code>的Service地址。因此filter <code>calico_export_to_bgp_peers</code>保证了Calico只对容器网络相关的路由进行BGP，对于手动配置或从其他EBGP学习到的非容器网络相关的路由，则不会进行BGP。</p><p>BGP协议部分主要分三部分：node-to-node mesh的配置、global peers的配置、node-specific peers的配置，都是使用上面的template完成。</p><p>其中node-to-node mesh配置部分，会判断两个node ip，当远端peer的node ip“较大”时，开启<code>passive</code>，也就是说，始终由“较大”IP的node发起BGP连接，保证mesh是单向的。</p><p>global peers配置和node-specific peers配置部分基本相同，会根据BGP Peer中的<code>keepOriginalNextHop</code>、<code>password</code>配置协议的<code>next hop keep</code>以及<code>password</code>属性，另外会根据本节点是否配置route reflector clusterID，决定是否开启<code>rr client</code>（用于Calico route reflector模式）。</p><p>4）static协议部分在bird_aggr.cfg.template中，主要是将本机的block和<code>/calico/staticroutes</code>中的值配置为Blackhole路由。这样一来，即可通过“bird路由表”，由BGP协议将本机的容器网络和Service网络的路由信息发送出去。而根据上面<code>/calico/staticroutes</code>的介绍，对于<code>externalTrafficPolicy=Cluster</code>的Service是以整个ServiceCIRD（BGP Configuration中设置的<code>serviceClusterIPs</code>和<code>serviceExternalIPs</code>）作为目标地址进行BGP的，对于<code>externalTrafficPolicy=Local</code>的Service，则会判断本节点上是否有相应的workloadEndpoint，如果有，则以单个地址（子网掩码/32或/128）作为目标地址进行BGP。以此，Calico实现了对Service externalTrafficPolicy属性的支持。</p><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $block_key <span class="hljs-attr">:</span>= printf <span class="hljs-string">&quot;/calico/ipam/v2/host/%s/ipv4/block&quot;</span> (<span class="hljs-name">getenv</span> <span class="hljs-string">&quot;NODENAME&quot;</span>)&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $static_key <span class="hljs-attr">:</span>= <span class="hljs-string">&quot;/calico/staticroutes&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> or (<span class="hljs-name">ls</span> $block_key) (<span class="hljs-name">ls</span> $static_key)&#125;&#125;</span><span class="xml">protocol static &#123;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if ls $block_key&#125;&#125;</span><span class="xml">   # IP blocks for this host.</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> range ls $block_key&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $parts <span class="hljs-attr">:</span>= split . <span class="hljs-string">&quot;-&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $cidr <span class="hljs-attr">:</span>= join $parts <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;</span><span class="xml">   route </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$cidr</span>&#125;&#125;</span><span class="xml"> blackhole;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if ls $static_key&#125;&#125;</span><span class="xml">   # Static routes.</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> range ls $static_key&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $parts <span class="hljs-attr">:</span>= split . <span class="hljs-string">&quot;-&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $cidr <span class="hljs-attr">:</span>= join $parts <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;</span><span class="xml">   route </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$cidr</span>&#125;&#125;</span><span class="xml"> blackhole;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="xml">&#125;</span><span class="hljs-template-tag">&#123;&#123;<span class="hljs-keyword">else</span>&#125;&#125;</span><span class="xml"># No IP blocks or static routes for this host.</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">end</span>&#125;&#125;</span></code></pre><p>这里有个问题，由于kernel中的export filter过滤了目标地址属于BGP Configuration的<code>serviceClusterIPs</code>和<code>serviceClusterIPs</code>的路由，实际上static协议中的<code>/calico/staticroutes</code>部分的Blackhole是无法配置到节点的路由表上的（<code>externalTrafficPolicy=Cluster</code>的Service地址也在这个范围内）。这会导致在使用Calico与TOR进行BGP的场景中，在开启了advertise service后，容器访问某个属于ServiceCIDR范围内，但并未分配给任何Service的地址时，数据包会根据默认路由发送到TOR，再由TOR发送回集群的某个节点，如此反复直至TTL消耗完。而如果尝试将ServiceCIDR对应的Blackhole路由写入系统的路由表中，可以解决这个问题，但又会导致宿主机对Service无法访问，流量直接被丢弃。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/projectcalico/confd/pull/322">https://github.com/projectcalico/confd/pull/322</a></p><p><a href="https://github.com/projectcalico/confd">https://github.com/projectcalico/confd</a></p><p><a href="https://github.com/projectcalico/calico/issues/3689">https://github.com/projectcalico/calico/issues/3689</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>calico</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>廉价的K8S LB方案--MetalLB</title>
    <link href="/2021/02/09/%E5%BB%89%E4%BB%B7%E7%9A%84K8S-LB%E6%96%B9%E6%A1%88-MetalLB/"/>
    <url>/2021/02/09/%E5%BB%89%E4%BB%B7%E7%9A%84K8S-LB%E6%96%B9%E6%A1%88-MetalLB/</url>
    
    <content type="html"><![CDATA[<p>MetalLB为本地运行的Kubernetes集群提供了LoadBalance功能，使用户像在公有云环境一样，使用K8S的LoadBalancer Service。</p><a id="more"></a><p>在Kubernetes中部署MetalLB后，会有两个部分，一部分是负责监听K8S Service资源变化的Controller，以Deployment的方式部署在整个集群上，另一部分是各个节点上的代理组件Speaker，以DaemonSet方式部署，负责ARP Reply或是BGP的宣告。</p><p>MetalLB有两种模式，一种是二层网络模式，一种是BGP模式。</p><h2 id="二层网络模式"><a href="#二层网络模式" class="headerlink" title="二层网络模式"></a>二层网络模式</h2><p><img src="/img/metallb1.png"></p><p>二层网络模式，顾名思义，所有的流量都在一个二层网络中。此模式下MetalLB其实并未进行负载均衡，而是借助其他组件例如Kube-proxy，来实现负载均衡。具体的，如上图所示，MetalLB将Service External IP（由MetalLB的Controller根据预先设定好的IP段，配置在LoadBalance类型的Service上）配置在K8S集群节点的local网卡上（比如kube-ipvs0），当Client访问Service External IP时，由于在同一个二层，会广播ARP请求，MetalLB会使用某个节点进行ARP Reply（IPv6通过NDP协议），从而Client请求流量会发送到此节点，然后由节点上的Kube-proxy进行负载，转到真正的Pod地址。</p><p>需要说明的是：</p><p>1）Service External IP地址需要与Client在同一网段。</p><p>2）为了使其他节点不对local网卡上的Service External IP进行ARP Reply，节点需要设置<code>arp_ignore=1</code>以及<code>arp_announce=2</code>，或者是设置Kube-proxy的<code>--ipvs-strict-arp</code>参数。</p><p>3）MetalLB对于每个Service会选一个节点，始终由这个节点进行ARP Reply。节点的选择方式是：先过滤出Service后端Pod所在的节点，然后以Service Name、Service Namespace、NodeIP等计算hash值，排序hash值取第一个。</p><p>3）由于上面的选择方式，MetalLB对ExternalTrafficPolicy=Local的Service是支持的，但会导致只用到部分后端Pod实例。</p><p>4）Kube-proxy会同时进行DNAT与SNAT，回包并不是如LVS DR模式，而是原路返回。</p><p>5）Kube-proxy也可以使用其他组件代替，比如Cilium的Kube-proxy replace方案。</p><p>二层网络模式在生产环境中使用有限，原因有二：</p><p>1）扩展性有限。受ARP协议和NDP协议的限制，每个Service都只有一个真正的“入口”，因此这个节点很可能会成为网络瓶颈的所在。</p><p>2）故障转移依赖客户端。MetalLB使用<a href="https://github.com/hashicorp/memberlist">memberlist</a>做为分布式节点的管理，如果当前使用的节点出现故障时，MetalLB会在新的memberlist中（已删除故障节点）再次选择某个节点进行替换。接着MetalLB会给客户端发送一个“额外的二层包”，告知客户端OS需要更新他们的MAC缓存，而在客户端OS更新缓存前，流量仍会转发到故障节点。因此从某种程度来说，故障转移的时间，就依赖于客户端OS更新MAC缓存的速度。</p><p>3）选节点的hash并非一致性，添加节点有一定概率导致Service的节点发生变化。</p><h2 id="BGP模式"><a href="#BGP模式" class="headerlink" title="BGP模式"></a>BGP模式</h2><p><img src="/img/metallb2.png"></p><p>BGP模式不限于一个二层网络里，各个节点都会与交换机建立BGP Peer，宣告Service External IP的下一跳为自身，这样通过ECMP实现了一层负载。客户端请求通过交换机负载到后端某个节点后，再由Kube-proxy进行转发。</p><p>对于<code>externalTrafficPolicy=Local</code>的Service，只有本机存在服务Pod时，才会进行Service External IP的BGP路由宣告。</p><p><img src="/img/MetalLB3.png"></p><p>可以看到这种方式实际上是经过了两层的转发，当Service ExternalTrafficPolicy为Cluster时，每次转发的概率其实是均等的，但当Service ExternalTrafficPolicy为Local时，虽然转发到每个节点的概率是一致的，但每个节点上服务Pod数量不一致，导致每个Pod上的流量其实并不均等。</p><p>在这种模式中，我们希望对于客户端请求的转发遵循会话保持，否则会出现数据包的乱序或丢弃。一般在硬件上，通过对数据包的3元组（源地址、目标地址、协议）或是五元组（三元组加上源端口、目标端口）进行hash，来实现同一会话转发到相同的后端。但需要注意，这种hash一般不是一致性hash，这就导致当后端某个节点的失效后，会对其他连接也会参数影响，扩大了故障的“爆炸半径”。</p><p>官方给了一些缓解的办法，比如在MetalLB和Service后端之间，加入一层有状态的负载——ingress Controller。</p><p>另外 ，BGP模式下，MetalLB提供了部分参数，来实现对BGP协议的控制，比如BGP community、localpref等。</p><pre><code class="hljs routeros">apiVersion: v1kind: ConfigMapmetadata:  namespace: metallb-system  name: configdata:  config: |    peers:    - peer-address: 10.0.0.1      peer-asn: 64501      my-asn: 64500    address-pools:    - name: default      protocol: bgp      addresses:      - 198.51.100.0/24      bgp-advertisements:      - aggregation-length: 32        localpref: 100        communities:        - no-advertise      - aggregation-length: 24    bgp-communities:      no-advertise: 65535:65282</code></pre><h3 id="类比Calico对Service的BGP"><a href="#类比Calico对Service的BGP" class="headerlink" title="类比Calico对Service的BGP"></a>类比Calico对Service的BGP</h3><p>从Calico v3.4开始，Calico支持对K8S的Service地址进行BGP，其逻辑和MetalLB BGP逻辑基本相同。有几点区别：</p><p>1）默认的情况下，MetalLB是对单个IP进行BGP的，子网掩码是32，但对Calico配置的是一个CIDR，Calico对外BGP的是整个网络段的路由，只有在externalTrafficPolicy为Local时，才会对单个IP进行BGP。</p><p>2）Calico不仅会BGP Service External IP，还可以BGP Service ClusterIP，两者的转发过程是类似的，都是将流量负载到某个K8S节点后，进行SNAT与DNAT。</p><p>3）Calico不负责LoadBalancer Service IP的分配。</p><h2 id="IP地址共享"><a href="#IP地址共享" class="headerlink" title="IP地址共享"></a>IP地址共享</h2><p>默认情况下，MetalLB只会将一个IP地址分配到一个LoadBalancer Service上，用户可以通过<code>spec.loadBalancerIP</code>来指定自己想用的IP，如果用户指定了已被分配了的IP会，则会报错。但MetalLB也提供了方式去支持多个Service共享相同的IP，主要为了解决：K8S不支持对LoadBalancer Service中的Port指定多协议；有限的IP地址资源。</p><p>具体的方式是：创建两个Service，并加上<code>metallb.universe.tf/allow-shared-ip</code>为Key的<code>annotation</code>，表明Service能容忍使用共享的LoadBalancerIP；然后通过<code>spec.loadBalancerIP</code>给两个Service指定共享的IP。</p><p>IP地址共享也有限制：</p><p>1）两个Service的<code>metallb.universe.tf/allow-shared-ip</code>值是一样的。</p><p>2）两个Service的“端口”（带协议）不同，比如<code>tcp/53</code>和<code>udp/53</code>是属于不同的“端口”。</p><p>3）两个Service对应的后端Pod要一致，如果不一致，那么他们的externalTrafficPolicy需要都是Cluster，不然会无法进行正确的BGP。</p><p>目前K8S已经开始支持<a href="https://github.com/kubernetes/kubernetes/pull/94028">对LoadBalancer Service指定多协议</a>，因此除了MetalLB提供的IP地址共享的方式，也可以使用原生的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://metallb.universe.tf/">https://metallb.universe.tf/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>metalLB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calico BGP功能介绍：BIRD简介</title>
    <link href="/2021/01/26/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9ABIRD%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/01/26/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9ABIRD%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>Calico作为一种常用的Kubernetes网络插件，使用BGP协议对各节点的容器网络进行路由交换。本文是《Calico BGP功能介绍》系列的第一篇，介绍Calico所使用的BGP软件路由器——BIRD。</p><a id="more"></a><blockquote><p>关于BGP协议，网上资料众多，在这里不再做介绍。另外，推荐《BGP in the datacenter》作为BGP应用的进阶阅读，另有<a href="https://cshihong.github.io/2020/04/18/BGP-in-the-datacenter-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%9A%84BGP-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84-Clos%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/">中文翻译版本</a></p></blockquote><h2 id="BIRD"><a href="#BIRD" class="headerlink" title="BIRD"></a>BIRD</h2><p>BIRD实际上是BIRD Internet Routing Daemon的缩写（禁止套娃），是一款可运行在Linux和其他类Unix系统上的路由软件，它实现了多种路由协议，比如BGP、OSPF、RIP等。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>BIRD会在内存中维护许多<strong>路由表</strong>，路由表根据不同的<strong>协议</strong>，通过与各种“其他事物”交换路由信息，来更新路由规则。这里说的“其他事物”可能是其他的路由表，也可能是外部的路由器，还可以是内核的某些API。</p><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>路由表（Routing tables）是BIRD的核心，一个路由表是内存中一组路由规则的集合，BIRD根据网络类型的不同会有多种路由表。默认情况下，BIRD有<code>master4</code>和<code>master6</code>两个默认的路由表，分别保存IPv4和IPv6路由规则。除此外，你也可以创建其他的路由表，比如在配置文件<code>bird.conf</code>中添加如下配置，创建一个IPv4的路由表<code>my_table</code>。</p><pre><code class="hljs text">ipv4 table my_table;</code></pre><p>要注意的是，BIRD的路由表仅仅是一个表，并没有转发的功能，真正的转发控制，是内核的FIB（Forwarding Information Base）。而BIRD的<code>kernel</code>协议，可以将BIRD路由表与FIB进行同步，后面会介绍。</p><p>路由规则中包含了各种<strong>路由属性</strong>（Route attributes），网络类型不同的路由表，其路由属性也不太一样，比如常见的IPv4和IPv6的路由表，会包括两个路由属性：</p><ul><li>路由目的地</li><li>路由下一跳</li></ul><p>而VPN路由表还会包含路由属性：路由标识符（Route distinguisher）。</p><p>BIRD的每种表都会将一个或一组路由属性作为<strong>主键</strong>，类似于SQL数据库。当多个来源都提供了相同主键的路由条目时，BIRD会根据一定的规则选择最优路由。例如IPv4和IPv6类型的路由表，将“路由目的地”作为主键。</p><h3 id="协议与通道"><a href="#协议与通道" class="headerlink" title="协议与通道"></a>协议与通道</h3><p>协议（Protocols）将路由表和“其他事物”连接起来。“其他事物”可以是一个Socket对象，连接了外部的路由器，例如BGP路由协议；也可以是修改FIB的内核API，例如<code>kernel</code>协议；也可以是空，比如静态路由<code>static</code>协议。一个协议可以实例化为多个对象，例如创建多个BGP协议的实例，以表示多个BGP邻居。</p><p>协议也会提供一些路由属性，根据协议的不同路由属性也不同，比如使用BGP协议时，会有<code>bgp_path</code>属性。</p><p>协议可能包含一些<strong>通道</strong>（Channels），通道是在协议和路由表之间，配置了路由规则在导入（import)）、导出（export）两个方向上的行为，导入导出是针对路由表来说的，路由规则经过通道后，或是被接收（Accept），或是被拒绝（Reject），或是被修改。不同的协议可拥有的通道也不一样，例如BGP协议可以同时拥有<code>IPv4</code>和<code>IPv6</code>通道，RIP只能拥有IPv4或IPv6一种协议，而BFD则没有通道。</p><p>下面是根据官网样例修改而来的配置，实例化了一个名为<code>peer_one</code>的BGP协议，并且设置了<code>ipv4</code>和<code>ipv6</code>两个通道，两个通道都未指明连接的路由表，则使用默认的<code>master4</code>与<code>master6</code>路由表。其中在<code>ipv4</code> 通道中，导入方向配置为全部接收，导出方向上只导出静态路由，同时还会对路由规则的BGP信息进行修改：修改bgp  community，修改bgp  path；在<code>ipv6</code>通道上，则直接使用默认配置。</p><pre><code class="hljs json">protocol bgp peer_one &#123;        local 198.51.100.14 as 65000;        # Use a private AS number        neighbor 198.51.100.130 as 64496;    # Our neighbor ...        ipv4 &#123;                export filter &#123;                      # We use non-trivial export rules                        if source = RTS_STATIC then &#123; # Export only static routes                                # Assign our community                                bgp_community.add((65000,64501));                                # Artificially increase path length                                # by advertising local AS number twice                                if bgp_path ~ [= 65000 =] then                                        bgp_path.prepend(65000);                                accept;                        &#125;                        reject;                &#125;;                import all;        &#125;;        ipv6;&#125;</code></pre><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>在BIRD中，可以定义<strong>模板</strong>（template），通过模板来创建一个协议的多个实例。模板在使用BGP协议时非常好用，因为BGP通常都会设置多个BGP Peer。例如下面配置，通过模板提取出共用的配置，然后利用模板创建多个BGP邻居。</p><pre><code class="hljs json">template bgp foo &#123;        local 198.51.100.14 as 65000;        ipv4 &#123;                table mytable4;                import filter &#123; ... &#125;;                export none;        &#125;;        ipv6 &#123;                table mytable6;                import filter &#123; ... &#125;;                export none;        &#125;;&#125;protocol bgp bgp1 from foo &#123;        neighbor 198.51.100.130 as 64496;&#125;protocol bgp bgp2 from foo &#123;        neighbor 198.51.100.131 as 64496;&#125;</code></pre><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p><strong>过滤器</strong>（Filters）在上面的用例中已经出现了多次，通过在通道中添加过滤器，可以灵活地控制路由规则的交换。在过滤器中，你可以像访问变量一样直接使用各种路由属性，来编写各种判断条件，以决定对路由规则是ACCEPT还是REJECT，或是直接对路由属性进行修改。</p><p>为了便于复用，还可以以函数的形式定义一个过滤器，使用时在相应的通道中直接调用。需要注意的是，编写过滤器需要使用BIRD提供的专门的编程语言，它提供了一些例如<code>if</code>、<code>switch</code>的简单控制结构，但不允许有循环出现。同时，除了<code>int</code>、<code>string</code>这些基础的数据结构外，它还提供了例如<code>bgppatch</code>、<code>bgpmask</code>等这种表示路由规则中某些信息的数据结构。例如下面定义了一个名为<code>not_too_far</code>的过滤器，丢弃掉<code>rip_metric</code>大于10的路由规则，可以通过<code>import filter not_too_far</code>直接调用此函数。</p><pre><code class="hljs C">filter not_too_far<span class="hljs-keyword">int</span> var;&#123;        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">defined</span><span class="hljs-params">( rip_metric )</span> then</span><span class="hljs-function">                var </span>= rip_metric;        <span class="hljs-keyword">else</span> &#123;                var = <span class="hljs-number">1</span>;                rip_metric = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> rip_metric &gt; <span class="hljs-number">10</span> then                reject <span class="hljs-string">&quot;RIP metric is too big&quot;</span>;        <span class="hljs-keyword">else</span>                accept <span class="hljs-string">&quot;ok&quot;</span>;&#125;</code></pre><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><p>这里只介绍Calico中使用到的几种协议，以及用到的协议属性。</p><h3 id="device"><a href="#device" class="headerlink" title="device"></a>device</h3><p>准确来说，<code>device</code>并不算是一个协议，它不产生任何路由，也不支持通道，而是被用来从内核中获取网卡设备的信息。每个<code>bird.conf</code>的配置文件中，都应定义一个<code>device</code>。</p><pre><code class="hljs json">protocol device &#123;        scan time 10;           # Scan the interfaces often        interface &quot;eth0&quot; &#123;                preferred 192.168.1.1;                preferred 2001:db8:1:10::1;        &#125;;&#125;</code></pre><p>上面配置定义了BIRD每10s扫描一遍<code>eth0</code>网卡，同时定义了首选的IP地址。</p><h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><p><code>kernel</code>也不算真正的协议，它负责同步路由表与内核。如果内核支持多个内核路由表，那么可以创建多个<code>kernel</code>实例，否则只需要创建一个<code>kernel</code>实例。<code>kernel</code>协议有两个限制：</p><ul><li>不能将多个<code>kernel</code>实例都连接到同一个路由表上</li><li>不能修改导出（export）路由规则的目标地址</li></ul><p>一些主要的参数包括：</p><ul><li><code>learn switch</code>，开启后路由表可以从内核中学习到非内核生成（其他方式添加）的路由。“内核生成的路由”指的是由于本机网络的配置而产生的路由，比如<code>eth0</code>在被分配<code>192.168.1.2/24</code>后，会自动产生一条目的地为<code>192.168.1.0/24</code>，下一跳为<code>eth0</code>的路由。需要注意的是，即使是开启<code>learn</code>，<code>kernel</code>也不会将这些路由从内核导入（import）路由表，这种路由的传递需要使用到<code>direct</code>协议。（<code>switch</code>表示<code>on</code>和<code>off</code>两种值，下面相同）</li><li><code>persist switch</code>，BIRD退出时，在内核保留同步的路由（即不会进行clean up操作）。</li><li><code>scan time number</code>，同步间隔，单位秒</li></ul><pre><code class="hljs json"># 同步master4、master6路由表与主FIB，并在退出后保持同步的路由protocol kernel &#123;    learn;    persist;&#125;</code></pre><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>如上面所述，<code>direct</code>用于将内核生成的路由规则从内核导入到BIRD路由表中，可用的参数包括：</p><ul><li><code>interface pattern [, ...]</code>，用于指定传递由哪些网卡生成的路由规则，默认是全部网卡</li><li><code>check link switch</code>，开启后会考虑link的状态，当link状态为up时，传递路由，否则，撤销传递的路由</li></ul><pre><code class="hljs json"># 同步除了eth0以外的其他网卡protocol direct &#123;  interface -&quot;eth0&quot;, &quot;*&quot;; &#125;</code></pre><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>每一个BGP协议的实例，代表了一个BGP Peer连接。需要注意的是，部分参数的默认值对IBGP与EBGP并不相同，例如<code>aigp</code>默认在IBGP中是开启的，默认在EBGP是关闭的。协议的主要参数包括：</p><ul><li><code>local [ip] [port number] [as number]</code>，可以用来指定BGP的源IP地址以及本地的AS。</li><li><code>multihop [number]</code>，表示多跳的BGP，后面的<code>number</code>可以用来设置<code>TTL</code>的值，IBGP默认开启；相反的，还有个参数为<code>direct</code>，表示与BGP邻居直连，EBGP默认开启。</li><li><code>source address ip</code>，用来指定本端使用的BGP源地址。</li><li><code>add paths switch|rx|tx</code>，开启时，会将 BGP 配置为向同一目标通告多个路径，否则 BGP 仅通告活动路径。</li><li><code>password string</code> ，使用设置的密码进行BGP的身份验证。</li><li><code>rr client</code>，开启RR模式（Route Reflector）。</li><li><code>rr cluster id IPv4 address</code>，设置RR的<code>cluster id</code>，以防止路由环路。默认情况下，会直接使用BGP的<code>router id</code>（一般是ipv4地址）作为<code>cluster id</code>，当有多个RR时，需要使用此参数设置相同的<code>cluster id</code>。</li><li><code>bfd switch|graceful</code>，使用BFD作为BGP协议心跳机制。</li><li><code>passive switch</code>，被动模式，不主动初始化连接，而是等待其他BGP邻居发起连接。</li></ul><p>以上是协议一层的配置参数，在BGP协议中，通道也会有额外的参数，例如：</p><ul><li><code>gateway direct|recursive</code>，用来控制如何计算路由的gw属性。当设置为<code>direct</code>时，如果路由中的<code>bgp_next_hop</code>是和本机中的某个地址同一子网（同一个二层），则gw直接为<code>bgp_next_hop</code>，否则为对端BGP Peer的IP地址；当设置为<code>recursive</code>时，会从IGP路由表中查询<code>bgp_next_hop</code>来作为gw。</li><li><code>next hop keep switch|ibgp|ebgp</code>，开启后，BGP不再将<code>next hop</code>属性修改为自身，而是直接通告原始的<code>next hop</code>，这个参数在多跳的EBGP场景或BGP路由反射中会使用到。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://bird.network.cz/?get_doc&v=20&f=bird.html#toc5">BIRD官方手册</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>calico</tag>
      
      <tag>BGP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入kube-proxy ipvs模式的conn_reuse_mode问题</title>
    <link href="/2021/01/15/%E6%B7%B1%E5%85%A5kube-proxy%20ipvs%E6%A8%A1%E5%BC%8F%E7%9A%84conn_reuse_mode%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/15/%E6%B7%B1%E5%85%A5kube-proxy%20ipvs%E6%A8%A1%E5%BC%8F%E7%9A%84conn_reuse_mode%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在高并发、短连接的场景下，kube-proxy ipvs存在rs删除失败或是延迟高的问题，社区也有不少Issue反馈，比如<a href="https://github.com/kubernetes/kubernetes/issues/81775">kube-proxy ipvs conn_reuse_mode setting causes errors with high load from single client</a>。文本对这些问题进行了梳理，试图介绍产生这些问题的内部原因。由于能力有限，其中涉及内核部分，只能浅尝辄止。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="端口重用"><a href="#端口重用" class="headerlink" title="端口重用"></a>端口重用</h3><p>一切问题来源于端口重用。在TCP四次挥手中有个<code>TIME_WAIT</code>的状态，作为先发送<code>FIN</code>包的一端，在接收到对端发送的<code>FIN</code>包后进入<code>TIME_WAIT</code>，在经过<code>2MSL</code>后才会真正关闭连接。<code>TIME_WAIT</code>状态的存在，一来可以避免将之前连接的延迟报文，作为当前连接的报文处理；二是可以处理最后一个ACK丢失带来的问题。</p><p><img src="/img/2021-01-15-TCP.png"></p><p>而在短连接、高并发的场景下，会出现大量的<code>TIME-WAIT</code>连接，导致资源无法及时释放。Linux中内核参数<code>net.ipv4.tcp_tw_reuse</code>提供了一种减少<code>TIME-WAIT</code>连接的方式，可以将<code>TIME-WAIT</code>连接的端口分配给新的TCP连接，来复用端口。</p><pre><code class="hljs text">tcp_tw_reuse - BOOLEANAllow to reuse TIME-WAIT sockets for new connections when it issafe from protocol viewpoint. Default value is 0.It should not be changed without advice/request of technicalexperts.</code></pre><h3 id="ipvs如何处理端口重用？"><a href="#ipvs如何处理端口重用？" class="headerlink" title="ipvs如何处理端口重用？"></a>ipvs如何处理端口重用？</h3><p>ipvs对端口的复用策略主要由内核参数<code>net.ipv4.vs.conn_reuse_mode</code>决定</p><pre><code class="hljs text">conn_reuse_mode - INTEGER1 - defaultControls how ipvs will deal with connections that are detectedport reuse. It is a bitmap, with the values being:0: disable any special handling on port reuse. The newconnection will be delivered to the same real server that wasservicing the previous connection. This will effectivelydisable expire_nodest_conn.bit 1: enable rescheduling of new connections when it is safe.That is, whenever expire_nodest_conn and for TCP sockets, whenthe connection is in TIME_WAIT state (which is only possible ifyou use NAT mode).bit 2: it is bit 1 plus, for TCP connections, when connectionsare in FIN_WAIT state, as this is the last state seen by loadbalancer in Direct Routing mode. This bit helps on adding newreal servers to a very busy cluster.</code></pre><p>当<code>net.ipv4.vs.conn_reuse_mode=0</code>时，ipvs不会对新连接进行重新负载，而是复用之前的负载结果，将新连接转发到原来的rs上；当<code>net.ipv4.vs.conn_reuse_mode=1</code>时，ipvs则会对新连接进行重新调度。</p><p>相关的，还有一个内核参数<code>net.ipv4.vs.expire_nodest_conn</code>，用于控制连接的rs不可用时的处理。在开启时，如果后端rs不可用，会立即结束掉该连接，使客户端重新发起新的连接请求；否则将数据包<strong>silently drop</strong>，也就是DROP掉数据包但不结束连接，等待客户端的重试。</p><p>另外，关于<strong>destination 不可用</strong>的判断，是在ipvs执行删除<code>vs</code>（在<code>__ip_vs_del_service()</code>中实现）或删除<code>rs</code>（在<code>ip_vs_del_dest()</code>中实现）时，会调用<code>__ip_vs_unlink_dest()</code>方法，将相应的destination置为不可用。</p><pre><code class="hljs text">expire_nodest_conn - BOOLEAN        0 - disabled (default)        not 0 - enabled        The default value is 0, the load balancer will silently drop        packets when its destination server is not available. It may        be useful, when user-space monitoring program deletes the        destination server (because of server overload or wrong        detection) and add back the server later, and the connections        to the server can continue.        If this feature is enabled, the load balancer will expire the        connection immediately when a packet arrives and its        destination server is not available, then the client program        will be notified that the connection is closed. This is        equivalent to the feature some people requires to flush        connections when its destination is not available.</code></pre><p>  关于ipvs如何处理端口复用的连接，这块主要实现逻辑在<code>net/netfilter/ipvs/ip_vs_core.c</code>的<code>ip_vs_in()</code>方法中：</p><pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Check if the packet belongs to an existing connection entry</span><span class="hljs-comment"> */</span>cp = pp-&gt;conn_in_get(ipvs, af, skb, &amp;iph);  <span class="hljs-comment">//找是属于某个已有的connection</span>conn_reuse_mode = sysctl_conn_reuse_mode(ipvs);<span class="hljs-comment">//当conn_reuse_mode开启，同时出现端口复用（例如收到TCP的SYN包，并且也属于已有的connection），进行处理</span><span class="hljs-keyword">if</span> (conn_reuse_mode &amp;&amp; !iph.fragoffs &amp;&amp; is_new_conn(skb, &amp;iph) &amp;&amp; cp) &#123; <span class="hljs-keyword">bool</span> uses_ct = <span class="hljs-literal">false</span>, resched = <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果开启了expire_nodest_conn、目标rs的weight为0</span><span class="hljs-keyword">if</span> (unlikely(sysctl_expire_nodest_conn(ipvs)) &amp;&amp; cp-&gt;dest &amp;&amp;    unlikely(!atomic_read(&amp;cp-&gt;dest-&gt;weight))) &#123;resched = <span class="hljs-literal">true</span>;<span class="hljs-comment">//查询是否用到了conntrack</span>uses_ct = ip_vs_conn_uses_conntrack(cp, skb);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_new_conn_expected(cp, conn_reuse_mode)) &#123;<span class="hljs-comment">//连接是expected的情况，比如FTP</span>uses_ct = ip_vs_conn_uses_conntrack(cp, skb);<span class="hljs-keyword">if</span> (!atomic_read(&amp;cp-&gt;n_control)) &#123;resched = <span class="hljs-literal">true</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* Do not reschedule controlling connection</span><span class="hljs-comment"> * that uses conntrack while it is still</span><span class="hljs-comment"> * referenced by controlled connection(s).</span><span class="hljs-comment"> */</span>resched = !uses_ct;&#125;&#125;<span class="hljs-comment">//如果expire_nodest_conn未开启，并且也非期望连接，实际上直接跳出了</span><span class="hljs-keyword">if</span> (resched) &#123;<span class="hljs-keyword">if</span> (!atomic_read(&amp;cp-&gt;n_control))ip_vs_conn_expire_now(cp);__ip_vs_conn_put(cp);<span class="hljs-comment">//当开启了net.ipv4.vs.conntrack，SYN数据包会直接丢弃，等待客户端重新发送SYN</span><span class="hljs-keyword">if</span> (uses_ct)<span class="hljs-keyword">return</span> NF_DROP;<span class="hljs-comment">//未开启conntrack时，会进入下面ip_vs_try_to_schedule的流程</span>cp = <span class="hljs-literal">NULL</span>;&#125;&#125;<span class="hljs-keyword">if</span> (unlikely(!cp)) &#123;<span class="hljs-keyword">int</span> v;<span class="hljs-keyword">if</span> (!ip_vs_try_to_schedule(ipvs, af, skb, pd, &amp;v, &amp;cp, &amp;iph))<span class="hljs-keyword">return</span> v;&#125;IP_VS_DBG_PKT(<span class="hljs-number">11</span>, af, pp, skb, iph.off, <span class="hljs-string">&quot;Incoming packet&quot;</span>);<span class="hljs-comment">/* Check the server status */</span><span class="hljs-keyword">if</span> (cp-&gt;dest &amp;&amp; !(cp-&gt;dest-&gt;flags &amp; IP_VS_DEST_F_AVAILABLE)) &#123;<span class="hljs-comment">/* the destination server is not available */</span>__u32 flags = cp-&gt;flags;<span class="hljs-comment">/* when timer already started, silently drop the packet.*/</span><span class="hljs-keyword">if</span> (timer_pending(&amp;cp-&gt;timer))__ip_vs_conn_put(cp);<span class="hljs-keyword">else</span>ip_vs_conn_put(cp);<span class="hljs-keyword">if</span> (sysctl_expire_nodest_conn(ipvs) &amp;&amp;    !(flags &amp; IP_VS_CONN_F_ONE_PACKET)) &#123;<span class="hljs-comment">/* try to expire the connection immediately */</span>ip_vs_conn_expire_now(cp);&#125;<span class="hljs-keyword">return</span> NF_DROP;&#125;</code></pre><h3 id="kube-proxy-ipvs模式下的优雅删除"><a href="#kube-proxy-ipvs模式下的优雅删除" class="headerlink" title="kube-proxy ipvs模式下的优雅删除"></a>kube-proxy ipvs模式下的优雅删除</h3><p>Kubernetes提供了Pod优雅删除机制。当我们决定干掉一个Pod时，我们可以通过<code>PreStop Hook</code>来做一些服务下线前的处理，同时Kubernetes也有个<code>grace period</code>，超过这个时间但未完成删除的Pod会被强制删除。</p><p>而在Kubernetes 1.13之前，kube-proxy ipvs模式并不支持优雅删除，当Endpoint被删除时，kube-proxy会直接移除掉ipvs中对应的rs，这样会导致后续的数据包被丢掉。</p><p>在1.13版本后，Kubernetes添加了<a href="https://github.com/kubernetes/kubernetes/pull/66012">IPVS优雅删除</a>的逻辑，主要是两点：</p><ul><li>当Pod被删除时，kube-proxy会先将rs的<code>weight</code>置为0，以防止新连接的请求发送到此rs，由于不再直接删除rs，旧连接仍能与rs正常通信；</li><li>当rs的<code>ActiveConn</code>数量为0（后面版本已改为<code>ActiveConn+InactiveConn==0</code>)，即不再有连接转发到此rs时，此rs才会真正被移除。</li></ul><h2 id="kube-proxy-ipvs模式下的问题"><a href="#kube-proxy-ipvs模式下的问题" class="headerlink" title="kube-proxy ipvs模式下的问题"></a>kube-proxy ipvs模式下的问题</h2><p>看上去kube-proxy ipvs的删除是优雅了，但当优雅删除正巧碰到端口重用，那问题就来了。</p><p>首先，kube-proxy希望通过设置<code>weight</code>为0，来避免新连接转发到此rs。但当<code>net.ipv4.vs.conn_reuse_mode=0</code>时，对于端口复用的连接，ipvs不会主动进行新的调度（调用<code>ip_vs_try_to_schedule</code>方法）；同时，只是将<code>weight</code>置为0，也并不会触发由<code>expire_nodest_conn</code>控制的结束连接或DROP操作，就这样，新连接的数据包当做什么都没发生一样，发送给了正在删除的Pod。这样一来，只要不断的有端口复用的连接请求发来，rs就不会被kube-proxy删除，上面提到的优雅删除的两点均无法实现。</p><p>而当<code>net.ipv4.vs.conn_reuse_mode=1</code>时，根据<code>ip_vs_in()</code>的处理逻辑，当开启了<code>net.ipv4.vs.conntrack</code>时，会DROP掉第一个SYN包，导致SYN的重传，有1S延迟。而Kube-proxy在IPVS模式下，使用了iptables进行<code>MASQUERADE</code>，也正好开启了<code>net.ipv4.vs.conntrack</code>。</p><pre><code class="hljs text">conntrack - BOOLEAN0 - disabled (default)not 0 - enabledIf set, maintain connection tracking entries forconnections handled by IPVS.This should be enabled if connections handled by IPVS are to bealso handled by stateful firewall rules. That is, iptables rulesthat make use of connection tracking.  It is a performanceoptimisation to disable this setting otherwise.Connections handled by the IPVS FTP application modulewill have connection tracking entries regardless of this setting.Only available when IPVS is compiled with CONFIG_IP_VS_NFCT enabled.</code></pre><p>这样看来，目前的情况似乎是，如果你需要实现优雅删除中的“保持旧连接不变，调度新连接”能力，那就要付出1s的延迟代价；如果你要好的性能，那么就不能重新调度。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>从Kubernetes角度来说，Kube-proxy需要在保证性能的前提下，找到一种能让新连接重新调度的方式。但目前从内核代码中可以看到，需要将参数设置如下</p><pre><code class="hljs text">net.ipv4.vs.conntrack=0net.ipv4.vs.conn_reuse_mode=1net.ipv4.vs.expire_nodest_conn=1</code></pre><p>但Kube-proxy ipvs模式目前无法摆脱iptables来完成k8s service的转发。此外，Kube-proxy只有在<code>ActiveConn+InactiveConn==0</code>时才会删除rs，除此之外，在新的Endpoint和<code>GracefulTerminationList</code>（保存了<code>weight</code>为0，但暂未删除的rs）中的rs冲突时，才会立即删除rs。这种逻辑似乎并不合理。目前Pod已有优雅删除的逻辑，而kube-proxy应基于Pod的优雅删除，在网络层面做好rs的优雅删除，因此在kubelet完全删除Pod后，Kube-proxy是否也应该考虑同时删除相应的rs？</p><p>另外，从内核角度来说，ipvs需要提供一种方式，能在端口复用、同时使用conntrack的场景下，可以对新连接直接重新调度。</p><h2 id="即将到来"><a href="#即将到来" class="headerlink" title="即将到来"></a>即将到来</h2><p>这个问题在社区讨论一段时间后，目前出现的几个相关的解决如下：<br><strong>内核两个Patch</strong></p><ul><li><a href="http://patchwork.ozlabs.org/project/netfilter-devel/patch/20200701151719.4751-1-ja@ssi.bg/">ipvs: allow connection reuse for unconfirmed conntrack</a><br>修改了<code>ip_vs_conn_uses_conntrack()</code>方法的逻辑，当使用<code>unconfirmed conntrack</code>时，返回false，这种修改针对了TIME_WAIT的conntrack。</li><li><a href="http://patchwork.ozlabs.org/project/netfilter-devel/patch/20200708161638.13584-1-kim.andrewsy@gmail.com/"> ipvs: queue delayed work to expire no destination connections if expire_nodest_conn=1</a><br>提前了<code>expire  connection</code>的操作，在destination被删除后，便开始将<code>expire  connection</code>操作入队列。而不是等到数据包真正发过来时，才做<code>expire  connection</code>，以此来减少数据包的丢失。</li></ul><p><strong>Kubernetes</strong><br><a href="https://github.com/kubernetes/enhancements/pull/1607">Graceful Termination for External Traffic Policy Local</a><br><a href="https://github.com/kubernetes/kubernetes/pull/92968">Add Terminating Condition to EndpointSlice</a><br>正如前面所说的，Kube-proxy需要能够感知到Pod的优雅删除过程，来同步进行rs的删除。目前，已有一个相应的KEP在进行中，通过在<code>Endpoint.EndpointConditions</code>中添加<code>terminating</code>字段，来为kube-proxy提供感知方式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kube-proxy</tag>
      
      <tag>ipvs</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
