<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>K8S GPUDirect RDMA实践之拓扑优化</title>
    <link href="/2023/07/18/K8S-GPUDirect-RDMA%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%8B%93%E6%89%91%E4%BC%98%E5%8C%96/"/>
    <url>/2023/07/18/K8S-GPUDirect-RDMA%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%8B%93%E6%89%91%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>NVIDIA GPUDirect RDMA(gdr)是一种能让第三方PCI Express设备通过bypass CPU直接访问GPU的技术，NVIDIA有一个在Kubernetes上使用GPUDirect RDMA技术的方案，但由于拓扑原因，做不到最优的性能。<br>目前没有找到可以直接使用的方案，记录下调研的结果。</p><a id="more"></a><h2 id="K8S中使用gdr"><a href="#K8S中使用gdr" class="headerlink" title="K8S中使用gdr"></a>K8S中使用gdr</h2><p>官方文档如下，就不细说了：</p><ul><li><a href="https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/latest/gpu-operator-rdma.html">GPUDirect RDMA and GPUDirect Storage</a></li><li><a href="https://developer.nvidia.com/blog/deploying-gpudirect-rdma-on-egx-stack-with-the-network-operator/">Deploying GPUDirect RDMA on the EGX Stack with the NVIDIA Network Operator</a></li></ul><p>主要是使用官方的GPU Operator与Network Operator，为容器分配GPU与RDMA网卡，依赖NVIDIA peer memory driver、MOFED driver，实现在Pod中使用gdr。</p><p>但是在<a href="https://developer.nvidia.com/blog/deploying-gpudirect-rdma-on-egx-stack-with-the-network-operator/">Deploying GPUDirect RDMA on the EGX Stack with the NVIDIA Network Operator</a> 文章中有这么一段话：</p><blockquote><p>The RDMA sample Pods do not enforce NUMA alignment between the GPU, network controller, and the Pod CPU socket. Performance can vary across runs, depending on which resources are presented to the Pod.</p></blockquote><p>也就是说gdr的性能依赖于Pod所分配的GPU、RDMA网卡、CPU的物理拓扑，比如是不是一个NUMA。</p><h2 id="拓扑与性能"><a href="#拓扑与性能" class="headerlink" title="拓扑与性能"></a>拓扑与性能</h2><p>关于具体的拓扑与性能关系的介绍，在官方文档<a href="https://docs.nvidia.com/cuda/gpudirect-rdma/index.html">GPUDirect RDMA</a>中有描述：</p><blockquote><p>Even though the only theoretical requirement for GPUDirect RDMA to work between a third-party device and an NVIDIA GPU is that they share the same root complex, there exist bugs (mostly in chipsets) causing it to perform badly, or not work at all in certain setups.</p><p>We can distinguish between three situations, depending on what is on the path between the GPU and the third-party device:</p><ul><li>PCIe switches only</li><li>single CPU/IOH</li><li>CPU/IOH &lt;-&gt; QPI/HT &lt;-&gt; CPU/IOH</li></ul><p>The first situation, where there are only PCIe switches on the path, is optimal and yields the best performance. The second one, where a single CPU/IOH is involved, works, but yields worse performance ( especially peer-to-peer read bandwidth has been shown to be severely limited on some processor architectures ). Finally, the third situation, where the path traverses a QPI/HT link, may be extremely performance-limited or even not work reliably.</p></blockquote><p>可知，当只经过PCIe Switch的时候，性能最好；如果经过CPU，性能较差；如果跨NUMA的时候，性能最差，甚至不可用。</p><p>从<a href="https://github.com/NVIDIA/nccl">NVIDIA/nccl</a>库中也可以看出这一点。nccl判断设备路径是否支持gdr的函数为<code>ncclTopoCheckGdr()</code>，除了判断GPU与NIC是否支持gdr外，还需要两者之间距离不能大于<code>PATH_PXB</code>，而<code>PATH_PXB</code>在nccl建立的拓扑中，表示路径最多经过了多个PCIe Switch。</p><pre><code class="hljs c"><span class="hljs-function">ncclResult_t <span class="hljs-title">ncclTopoCheckGdr</span><span class="hljs-params">(struct ncclTopoSystem* system, <span class="hljs-keyword">int64_t</span> busId, <span class="hljs-keyword">int</span> netDev, <span class="hljs-keyword">int</span> read, <span class="hljs-keyword">int</span>* useGdr)</span> </span>&#123;  *useGdr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Get GPU and NET</span>  <span class="hljs-keyword">int</span> n, g;  NCCLCHECK(ncclTopoIdToIndex(system, NET, netDev, &amp;n));  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ncclTopoNode</span>* <span class="hljs-title">net</span> = <span class="hljs-title">system</span>-&gt;<span class="hljs-title">nodes</span>[<span class="hljs-title">NET</span>].<span class="hljs-title">nodes</span>+<span class="hljs-title">n</span>;</span>  NCCLCHECK(ncclTopoIdToIndex(system, GPU, busId, &amp;g));  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ncclTopoNode</span>* <span class="hljs-title">gpu</span> = <span class="hljs-title">system</span>-&gt;<span class="hljs-title">nodes</span>[<span class="hljs-title">GPU</span>].<span class="hljs-title">nodes</span>+<span class="hljs-title">g</span>;</span>  <span class="hljs-comment">// Check that both the NIC and GPUs support it</span>  <span class="hljs-comment">// 先检测net、gpu支持gdr</span>  <span class="hljs-keyword">if</span> (net-&gt;net.gdrSupport == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ncclSuccess;  <span class="hljs-keyword">if</span> (gpu-&gt;gpu.gdrSupport == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ncclSuccess;  <span class="hljs-keyword">if</span> (read) &#123; <span class="hljs-comment">// For reads (sends) only enable under certain conditions</span>    <span class="hljs-keyword">int</span> gdrReadParam = ncclParamNetGdrRead();    <span class="hljs-keyword">if</span> (gdrReadParam == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ncclSuccess;    <span class="hljs-keyword">if</span> (gdrReadParam &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">int</span> nvlink = <span class="hljs-number">0</span>;      <span class="hljs-comment">// Since we don&#x27;t know whether there are other communicators,</span>      <span class="hljs-comment">// it&#x27;s better to keep things local if we have a single GPU.</span>      <span class="hljs-keyword">if</span> (system-&gt;nodes[GPU].count == <span class="hljs-number">1</span>) nvlink = <span class="hljs-number">1</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;system-&gt;nodes[GPU].count; i++) &#123;        <span class="hljs-keyword">if</span> (i == g) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (gpu-&gt;paths[GPU][i].type == PATH_NVL) &#123;          nvlink = <span class="hljs-number">1</span>;          <span class="hljs-keyword">break</span>;        &#125;      &#125;      <span class="hljs-keyword">if</span> (!nvlink) <span class="hljs-keyword">return</span> ncclSuccess;    &#125;  &#125;  <span class="hljs-comment">// Check if we are close enough that it makes sense to enable GDR</span>  <span class="hljs-keyword">int</span> netGdrLevel = PATH_PXB;  NCCLCHECK(ncclGetLevel(&amp;ncclTopoUserGdrLevel, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;NCCL_NET_GDR_LEVEL&quot;</span>));  <span class="hljs-keyword">if</span> (ncclTopoUserGdrLevel != <span class="hljs-number">-2</span>) netGdrLevel = ncclTopoUserGdrLevel;  <span class="hljs-keyword">int</span> distance = gpu-&gt;paths[NET][n].type;  <span class="hljs-keyword">if</span> (distance == PATH_PXN) &#123;    <span class="hljs-comment">// In case of PXN, use the intermediate GPU distance instead</span>    <span class="hljs-keyword">int</span> proxyRank, g;    NCCLCHECK(ncclTopoGetIntermediateRank(system, gpu-&gt;gpu.rank, netDev, &amp;proxyRank));    NCCLCHECK(ncclTopoRankToIndex(system, proxyRank, &amp;g));    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ncclTopoNode</span>* <span class="hljs-title">proxyGpu</span> = <span class="hljs-title">system</span>-&gt;<span class="hljs-title">nodes</span>[<span class="hljs-title">GPU</span>].<span class="hljs-title">nodes</span>+<span class="hljs-title">g</span>;</span>    distance = proxyGpu-&gt;paths[NET][n].type;  &#125;  <span class="hljs-comment">// 还需要路径上不超过PATH_PXB</span>  <span class="hljs-keyword">if</span> (distance &gt; netGdrLevel) &#123;    INFO(NCCL_NET,<span class="hljs-string">&quot;GPU Direct RDMA Disabled for GPU %lx / HCA %d (distance %d &gt; %d)&quot;</span>, busId, netDev, distance, netGdrLevel);    <span class="hljs-keyword">return</span> ncclSuccess;  &#125;  *useGdr = <span class="hljs-number">1</span>;  INFO(NCCL_NET,<span class="hljs-string">&quot;GPU Direct RDMA Enabled for GPU %lx / HCA %d (distance %d &lt;= %d), read %d&quot;</span>, busId, netDev, distance, netGdrLevel, read);  <span class="hljs-keyword">return</span> ncclSuccess;&#125;</code></pre><p>nccl里拓扑的路径类型：</p><pre><code class="hljs c"><span class="hljs-comment">// Local (myself)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_LOC 0</span><span class="hljs-comment">// Connection traversing NVLink</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_NVL 1</span><span class="hljs-comment">// Connection through NVLink using an intermediate GPU</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_NVB 2</span><span class="hljs-comment">// Connection traversing at most a single PCIe bridge</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_PIX 3</span><span class="hljs-comment">// Connection traversing multiple PCIe bridges (without traversing the PCIe Host Bridge)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_PXB 4</span><span class="hljs-comment">// Connection between a GPU and a NIC using an intermediate GPU. Used to enable rail-local, aggregated network send/recv operations.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_PXN 5</span><span class="hljs-comment">// Connection traversing PCIe as well as a PCIe Host Bridge (typically the CPU)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_PHB 6</span><span class="hljs-comment">// Connection traversing PCIe as well as the SMP interconnect between NUMA nodes (e.g., QPI/UPI)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_SYS 7</span><span class="hljs-comment">// Connection through the network</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_NET 8</span><span class="hljs-comment">// Disconnected</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PATH_DIS 9</span></code></pre><p>由此可见，在给Pod分配RDMA网卡与GPU时，最好的情况是RDMA网卡与GPU只经过多个或一个PCIe Switch。</p><h2 id="Kubelet-TopologyManager"><a href="#Kubelet-TopologyManager" class="headerlink" title="Kubelet TopologyManager"></a>Kubelet TopologyManager</h2><p>NVIDIA的GPU Operator与Network Operator都是通过部署Device Plugin来管理、分配设备的，两个Operator分别会部署NVIDIA的k8s device plugin（管理GPU）以及RDMA share device plugin（管理RDMA网卡，和部署模式有关，也有可能是SR-IOV device plugin）。</p><p>在K8s中，通过Kubelet TopologyManager来实现NUMA对齐，目前Kubelet TopologyManager包含CPUManager、DeviceManager、MemoryManager，能实现Device资源、CPU、Memory分配在同一个NUMA下。</p><p>具体的，Kubelet会先通过Device Plugin的<code>ListAndWatch()</code>获取设备列表，返回的<code>Device</code>中，会有<code>Topology</code>字段用于设置设备的拓扑，Kubelet在为Pod分配资源时，会根据设定的策略，强制或尽量地选择与CPU相同NUMA的Device。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Device <span class="hljs-keyword">struct</span> &#123;...<span class="hljs-comment">// Topology for device</span>Topology             *TopologyInfo <span class="hljs-string">`protobuf:&quot;bytes,3,opt,name=topology,proto3&quot; json:&quot;topology,omitempty&quot;`</span>...&#125;<span class="hljs-keyword">type</span> TopologyInfo <span class="hljs-keyword">struct</span> &#123;Nodes                []*NUMANode...&#125;</code></pre><p>除此外，Device Plugin还可以实现<code>GetPreferredAllocation()</code>接口，在Kubelet选出与CPU相同NUMA的多个device后，Kubelet会调用Device Plugin的<code>GetPreferredAllocation()</code>接口，让Device Plugin进行进一步的优选。</p><p>而在NVIDIA方案中的几个Device Plugin，都没有实现<code>GetPreferredAllocation()</code>接口，也就是说在NVIDIA的K8s GPUDirect RDMA方案中，最多只能通过Kubelet的TopologyManager来保证NUMA的对齐，但无法保证能达到推荐的<code>PCIe switches only</code>的性能。</p><h2 id="Device-Plugin机制的问题"><a href="#Device-Plugin机制的问题" class="headerlink" title="Device Plugin机制的问题"></a>Device Plugin机制的问题</h2><p>实际上，无法单独通过一类资源的<code>GetPreferredAllocation()</code>方法，做到多种资源的亲和性分配。比如当GPU Device Plugin收到kubelet的<code>GetPreferredAllocation()</code>调用后，GPU Device Plugin并不知道它在为哪个Pod分配GPU（<code>Allocate()</code>与<code>GetPreferredAllocation()</code>都只传递DeviceID），也就不知道请求GPU的Pod是否也同时需要分配RDMA，以及RDMA网卡的分配结果了，做不到亲和性分配。</p><p>除此之外，在调度层面不会考虑devices资源的亲和性，仅仅是看节点的device资源数量上是否满足，device的分配都是由kubelet完成的，kubelet只能在本节点层面选择，而有些节点可能无法满足<code>PCIe switches only</code>的分配。</p><h2 id="可能的方案"><a href="#可能的方案" class="headerlink" title="可能的方案"></a>可能的方案</h2><p><a href="https://developer.aliyun.com/article/1180698">Container Runtime CDI与NRI介绍</a> 这篇文章里介绍了两种方法：<br>1）将Device Plugin的<code>Allocate()</code>功能推到<code>PreStartContainer()</code>里实现，利用CDI可以越过Kubelet device plugin，进行设备的分配。<br>2）通过Kubernetes Schduler Extender实现全局的device资源调度，通过NRI替代device plugin，对容器进行设备的分配、配置。</p><p>第一种方式算是Device Plugin机制的一种另类用法，第二种方式不再依赖Device Plugin机制，而是通过NRI，在容器创建的时候从Pod annotation中获取设备信息（可以由kube-scheduler在调度时写入），Device Plugin在方案中唯一的用处可能只是上报资源状态到Node资源上，在kube-scheduler调度时使用。</p><p>除此外，<a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/3063-dynamic-resource-allocation">kep: dynamic resource allocation</a> （下面简称DRA），也提供了一种方式（目前还是alpha），可以实现全局的资源调度、分配时能找到对应的pod。</p><p>整体逻辑如下所示，Resource Driver是用户实现资源管理逻辑，包含两部分：resource device controller负责同步<code>ResourceClaim</code>、<code>ResourceClass</code>、<code>Pod</code>等CRD资源，同时与kube-scheduler交互，进行全局的资源调度；resource kubelet plugin负责与kubelet交互，为调度到本节点Pod准备resource。</p><p><img src="/img/dynamic-resource-allocation.png"></p><p>DRA借鉴了存储中SC、PVC的设计理念，对应的API为<code>ResourceClass</code>、<code>ResourceClaim</code>。其中<code>ResouceClass</code>巧妙的应用了CRD Ref，开发者可以定义一个CRD作为resource driver的参数配置，这样一来，一套resource driver可以服务多种<code>ResourceClass</code>。而在存储中，作为分配结果的PV，在DRA被省略，分配的结果将被记录在<code>ResourceClaimStatus</code>中。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ResourceClass <span class="hljs-keyword">struct</span> &#123;...<span class="hljs-comment">// ParametersRef references an arbitrary separate object that may hold</span><span class="hljs-comment">// parameters that will be used by the driver when allocating a</span><span class="hljs-comment">// resource that uses this class. A dynamic resource driver can</span><span class="hljs-comment">// distinguish between parameters stored here and and those stored in</span><span class="hljs-comment">// ResourceClaimSpec.</span><span class="hljs-comment">// +optional</span>ParametersRef *ResourceClassParametersReference...&#125;</code></pre><p>dynamic resource alloncation有两种分配模式：WaitForFirstConsumer与Immediate。前者属于延迟分配，kube-scheduler先调度pod，device driver在分配资源；后者属于立即分配，先由device driver分配资源，再由kube-scheduler根据分配的结果，进行pod调度。</p><p>WaitForFirstConsumer模式下，kube-scheduler通过<code>PodSchedulingContext</code> CRD与resource driver controller进行协同调度。具体的：</p><ul><li>kube-scheduler会将Filter阶段的结果写到<code>PodSchedulingContextSpec.PotentialNodes</code>上</li><li>resource driver过滤<code>PodSchedulingContextSpec.PotentialNodes</code>，将不适合的node写到<code>ResourceClaimSchedulingStatus.UnsuitableNodes</code>上</li><li>kube-scheduler有了这些信息后，会进行<strong>尝试</strong>，将尝试的node写到<code>PodSchedulingContextSpec.SelectedNode</code>上</li><li>resource driver获取<code>PodSchedulingContextSpec.SelectedNode</code>。如果节点可以，则分配resource，将结果写入到<code>ResourceClaim</code>上，后续kube-scheduler完成调度；如果节点不可以，则更新<code>ResourceClaimSchedulingStatus.UnsuitableNodes</code>，待kube-scheduler重新尝试</li></ul><pre><code class="hljs go"><span class="hljs-comment">// PodSchedulingContextSpec describes where resources for the Pod are needed.</span><span class="hljs-keyword">type</span> PodSchedulingContextSpec <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// SelectedNode is the node for which allocation of ResourceClaims that</span><span class="hljs-comment">// are referenced by the Pod and that use &quot;WaitForFirstConsumer&quot;</span><span class="hljs-comment">// allocation is to be attempted.</span>SelectedNode <span class="hljs-keyword">string</span><span class="hljs-comment">// PotentialNodes lists nodes where the Pod might be able to run.</span><span class="hljs-comment">//</span><span class="hljs-comment">// The size of this field is limited to 128. This is large enough for</span><span class="hljs-comment">// many clusters. Larger clusters may need more attempts to find a node</span><span class="hljs-comment">// that suits all pending resources. This may get increased in the</span><span class="hljs-comment">// future, but not reduced.</span><span class="hljs-comment">// +optional</span>PotentialNodes []<span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">type</span> ResourceClaimSchedulingStatus <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">// Name matches the pod.spec.resourceClaims[*].Name field.// +optional  </span>Name <span class="hljs-keyword">string</span>   <span class="hljs-comment">// UnsuitableNodes lists nodes that the ResourceClaim cannot be// allocated for.  </span><span class="hljs-comment">//  </span><span class="hljs-comment">// The size of this field is limited to 128, the same as for  </span><span class="hljs-comment">// PodSchedulingSpec.PotentialNodes. This may get increased in the  </span><span class="hljs-comment">// future, but not reduced.  </span><span class="hljs-comment">//  </span><span class="hljs-comment">// +listType=set  </span><span class="hljs-comment">// +optional  </span>UnsuitableNodes []<span class="hljs-keyword">string</span>  &#125;</code></pre><p>感觉整个调度过程还是相当麻烦的。至于resource driver的实现，<a href="https://github.com/kubernetes-sigs/dra-example-driver">kubernetes-sigs/dra-example-driver</a>打了个样，需要分别实现k8s.io/kubelet/pkg/apis/dra/v1alpha2里的<a href="https://github.com/kubernetes/kubernetes/blob/v1.27.3/staging/src/k8s.io/kubelet/pkg/apis/dra/v1alpha2/api.pb.go#L367">NodeServer</a>，以及k8s.io/dynamic-resource-allocation/controller里的<a href="https://github.com/kubernetes/dynamic-resource-allocation/blob/release-1.27/controller/controller.go#L56">Driver</a>。</p><p>按照DRA的方式，我们可以在Driver的<code>UnsuitableNodes()</code>里，对节点是否满足<code>PCIe switches only</code>（可以参考nccl的拓扑创建与路径判断逻辑），然后在Driver的<code>Allocate()</code>里进行RDMA与GPU的同时分配（<code>Allocate()</code>传递的参数为<code>claims []*ClaimAllocation</code>，可以进行多个分配）。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查询RDMA网卡逻辑Port与物理设备映射的几种方式</title>
    <link href="/2023/06/12/%E6%9F%A5%E8%AF%A2RDMA%E7%BD%91%E5%8D%A1%E9%80%BB%E8%BE%91Port%E4%B8%8E%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E6%98%A0%E5%B0%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/06/12/%E6%9F%A5%E8%AF%A2RDMA%E7%BD%91%E5%8D%A1%E9%80%BB%E8%BE%91Port%E4%B8%8E%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E6%98%A0%E5%B0%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>通过<code>ibv_devices</code>或<code>ibv_devinfo</code>输出的device，例如<code>mlx4_0</code>，对应的是RDMA网卡上的某个Port。<code>mlx4_0</code>具体对应主机上的哪个网卡（例如<code>eth0</code>）、对应哪个PCIe设备，可以通过以下方式查询。</p><a id="more"></a><h2 id="逻辑Port与主机网卡的映射"><a href="#逻辑Port与主机网卡的映射" class="headerlink" title="逻辑Port与主机网卡的映射"></a>逻辑Port与主机网卡的映射</h2><p>1、如果安装了<code>MLNX_OFED</code>，可以通过<code>ibdev2netdev</code>命令查询。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ibdev2netdev  </span>mlx4_0 port 1 ==&gt; eth2 (Up)  mlx4_0 port 2 ==&gt; ib0 (Down)</code></pre><p>2、如果按照了<code>MST (Mellanox Software Tools)</code>，可以通过<code>mst</code>命令查询</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mst start  </span>Starting MST (Mellanox Software Tools) driver set  Loading MST PCI module - Success  Loading MST PCI configuration module - Success  Create devices  <span class="hljs-meta">#</span><span class="bash"> mst status -v  </span>MST modules:  ------------      MST PCI module loaded      MST PCI configuration module loaded  PCI devices:  ------------  DEVICE_TYPE             MST                           PCI       RDMA    NET                       NUMA  ConnectX3(rev:1)        /dev/mst/mt4099_pciconf0  ConnectX3(rev:1)        /dev/mst/mt4099_pci_cr0       0a:00.0   **mlx4_0**  net-**ib0**,net-**eth2**          0</code></pre><p>3、如果使用<code>Inbox Driver</code>，可以通过如下命令查询，其中<code>eth0</code>可以换成其他网卡，例如<code>eth2</code>、<code>ib0</code>等</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> cat /sys/class/net/eth0/device/infiniband_verbs/uverbs0/ibdev</span>mlx4_0</code></pre><h2 id="逻辑Port与PCI设备的映射"><a href="#逻辑Port与PCI设备的映射" class="headerlink" title="逻辑Port与PCI设备的映射"></a>逻辑Port与PCI设备的映射</h2><p>在找到逻辑Port对应的主机网卡后，通过<code>ethtool -i</code>就可以查询到网卡具体的PCI ID，然后通过<code>lspci</code>找到具体的PCI设备。例如：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> cat /sys/class/net/enp129s0f1/device/infiniband_verbs/uverbs1/ibdev</span>qedr1<span class="hljs-meta">#</span><span class="bash"> ethtool -i enp129s0f1</span>driver: qedeversion: 8.33.0.20firmware-version: mfw 8.23.11.0 storm 8.37.2.0expansion-rom-version:bus-info: 0000:81:00.1supports-statistics: yessupports-test: yessupports-eeprom-access: nosupports-register-dump: yessupports-priv-flags: yes<span class="hljs-meta">#</span><span class="bash"> lspci -v | grep 81:00.1</span>81:00.1 Ethernet controller: QLogic Corp. FastLinQ QL41000 Series 10/25/40/50GbE Controller (rev 02)</code></pre>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RDMA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Pod支持RDMA网卡的几种方式</title>
    <link href="/2023/06/05/Kubernetes-Pod%E6%94%AF%E6%8C%81RDMA%E7%BD%91%E5%8D%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/06/05/Kubernetes-Pod%E6%94%AF%E6%8C%81RDMA%E7%BD%91%E5%8D%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>最近调研了几种实现Kubernetes Pod支持RDMA网卡的库，粗略的记录下。</p><a id="more"></a><h2 id="FreeFlow"><a href="#FreeFlow" class="headerlink" title="FreeFlow"></a>FreeFlow</h2><p><a href="https://github.com/Microsoft/Freeflow">FreeFlow</a>是微软提出的一种RDMA技术，主要用于将RDMA应用在容器中。FreeFlow整体方案由三部分组成：</p><ul><li>FreeFlow network library（FFL），主要实现了Verbs，提供给应用程序调用。</li><li>FreeFlow software路由器（FFR），为主机上的多个容器进行RDMA流量路由。</li><li>FreeFlow network orchestrator（FFO），根据策略（Policies）、网络状态（Stats）控制FFR的行为。<br>FreeFlow架构如下，灰色部分为FreeFlow组件。</li></ul><p><img src="/img/rdma-freeflow-1.png"></p><p><strong>FreeFlow的原理</strong>：一般应用程序利用RDMA API直接向硬件NIC发送命令，以实现控制和数据路径功能。FreeFlow拦截应用程序和物理网卡之间的通信，并通过软件的FreeFlow Router进行容器之间的路由，通过FreeFlow Netlib实现应用程序向硬件NIC的控制，从而实现控制平面和数据平面策略。FreeFlow实现了Verbs，因此对应用程序与硬件NIC来说，都是透明的。</p><p><strong>FreeFlow的缺点</strong>：</p><ul><li>FreeFlow提供了两种模式：Fastpath和LowCPU。Fastpath能提供接近于Host RDMA的传输性能，但为了实现零拷贝，需要绑核进行轮询，耗费大量CPU资源。而LowCPU模式，传输性能明显下降。<br><img src="/img/rdma-freeflow-2.png"><br><img src="/img/rdma-freeflow-3.png"></li></ul><h2 id="rit-k8s-rdma"><a href="#rit-k8s-rdma" class="headerlink" title="rit-k8s-rdma"></a>rit-k8s-rdma</h2><p><a href="https://rit-k8s-rdma.github.io/">rit-k8s-rdma</a>通过CNI的方式给Kubernetes分配RDMA网卡，其主要由三部分构成：<br><img src="/img/rdmt-rit-k8s-rdma-1.png"></p><ul><li>Scheduler Extension： 基于Kubernetes Scheduler的扩展架构开发，用于将Pod调度到具有足够RDMA资源的节点上。</li><li>RDMA Hardware Daemon Set：部署在每个节点上，一是用于初始化节点上的RDMA  SR-IOV设备，二是用于提供RESTful接口，提供关于PF、VF的元数据。</li><li>CNI Plugin：用于给Pod分配RDMA网卡的CNI插件。基于<a href="https://github.com/Mellanox/sriov-cni">Mellanox CNI</a>开发，Mellanox CNI可以为每个Pod分配一个RDMA VF接口，而rit-k8s-rdma cni plugin能为Pod分配多个RDMA VF接口，并且为每个RDMA VF接口配置带宽预留或限制。</li><li>Dummy Device Plugin：部署在每个节点上。由于使用RDMA的Pod一般需要访问<code>/dev/infiniband</code>目录，为了不使用特权Pod，通过Kubernetes Device Plugin机制将此Device通过<code>Dummy Device Plugin</code>返回给Kubelet，作为Pod的特权目录。</li></ul><p><strong>rit-k8s-rdma的优点</strong>：rit-k8s-rdma本质上是在Mellanox-network-operator的SR-IOV模式下添加了更加合理的调度、一个Pod分配多个RDMA VF接口、带宽限制等功能，通过在整体集群视角下的调度，以及节点层面的带宽限制，能更加合理的利用RDMA资源。</p><p><strong>rit-k8s-rdma的缺点</strong>：</p><ul><li>调度的算法过于简单。仅考虑到RDMA资源数量上是否满足Pod的需要，未考虑的RDMA资源的拓扑信息，进行优选调度。例如根据RDMA设备与GPU在节点上的拓扑，为Pod选取满足GPU与RDMA在同一PCIe设备上的节点；或是针对大模型训练任务中，考虑整体集群的流量拓扑，避免某些节点之间通信过于繁忙，导致拥塞。</li></ul><h2 id="Mellanox-network-operator"><a href="#Mellanox-network-operator" class="headerlink" title="Mellanox-network-operator"></a>Mellanox-network-operator</h2><p><a href="https://github.com/Mellanox/network-operator">Mellanox-network-operator</a>也被叫NVIDA Network Operator，是NVIDA开源的一套RDMA与Kubernetes集成方案，利用Kubernetes CRDs与Operator SDK来管理RDMA网络，为Pod支持RDMA网卡与GPUDirect特性。Mellanox-network-operator更像是一组RDMA集成方案的集合，例如通过Macvlan的方式添加RDMA网卡，或是SR-IOV的方式添加RDMA网卡，亦或是使用Share RDMA的方式，将RDMA网卡设备添加到多个Pod中共同使用。用户通过设置helm value或是修改CRD，来使用某一种RDMA集成方案。</p><p>Mellanox-network-operator主要组件包括：</p><ul><li>Mellanox drivers：Mellanox网卡驱动。</li><li>nvidia-peermem：基于Mellanox IB的HCAs，提供对NVIDIA GPU显存的点对点读写。</li><li>k8s device plugin：用于管理RDMA网卡的Kubernetes Device Plugin。</li><li>SR-IOV Operator：用于部署SR-IOV容器网络。</li><li>Kubernetes CNI：包括用于容器分配多网络的Mutlus CNI、分配RDMA网络的Mellanox CNI.</li></ul><h3 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h3><p>Mellanox-network-operator定义了四个CRD，用于配置部署。</p><p><strong>NICClusterPolicy CRD</strong></p><p>用于配置全局的部署参数，operator只会使用名为“nic-cluster-policy”的实例，忽略其他的实例。参数包括：</p><ul><li>配置容器化的mellanox OFED Driver的<code>ofedDriver</code>。</li><li>配置rdma share模式下device plugin的<code>rdmaSharedDevicePlugin</code>。</li><li>配置sr-iov模式下sr-iov device plugin的<code>sriovDevicePlugin</code>。</li><li>配置GPUDirect特性下nvidia peermem的<code>nvPeerDriver</code></li><li>用于配置InfiniBand Kubernetes的<code>ibKubernetes</code>，InfiniBand Kubernetes能配合IOV CNI与Intel Multus CNI工作，目前只用于NVIDIA UFM（Unified Fabric Manager）的Guid生成，配置到Pod的annotation上。</li><li>用于配置第二张Pod网卡的<code>SecondaryNetwork</code>，第二网络可以是</li></ul><p>官方的样例：</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">mellanox.com/v1alpha1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">NicClusterPolicy</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">nic-cluster-policy</span>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nvidia-network-operator</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ofedDriver:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">mofed</span>    <span class="hljs-attr">repository:</span> <span class="hljs-string">nvcr.io/nvidia/mellanox</span>    <span class="hljs-attr">version:</span> <span class="hljs-number">5.9</span><span class="hljs-number">-0.5</span><span class="hljs-number">.6</span><span class="hljs-number">.0</span>    <span class="hljs-attr">startupProbe:</span>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span>    <span class="hljs-attr">livenessProbe:</span>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">30</span>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">30</span>    <span class="hljs-attr">readinessProbe:</span>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">30</span>  <span class="hljs-attr">rdmaSharedDevicePlugin:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">k8s-rdma-shared-dev-plugin</span>    <span class="hljs-attr">repository:</span> <span class="hljs-string">nvcr.io/nvidia/cloud-native</span>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1.3.2</span>    <span class="hljs-comment"># The config below directly propagates to k8s-rdma-shared-device-plugin configuration.</span>    <span class="hljs-comment"># Replace &#x27;devices&#x27; with your (RDMA capable) netdevice name.</span>    <span class="hljs-attr">config:</span> <span class="hljs-string">|</span>      &#123;        <span class="hljs-attr">&quot;configList&quot;:</span> [          &#123;            <span class="hljs-attr">&quot;resourceName&quot;:</span> <span class="hljs-string">&quot;rdma_shared_device_a&quot;</span>,            <span class="hljs-attr">&quot;rdmaHcaMax&quot;:</span> <span class="hljs-number">1000</span>,            <span class="hljs-attr">&quot;selectors&quot;:</span> &#123;              <span class="hljs-attr">&quot;vendors&quot;:</span> [<span class="hljs-string">&quot;15b3&quot;</span>],              <span class="hljs-attr">&quot;deviceIDs&quot;:</span> [<span class="hljs-string">&quot;1017&quot;</span>],              <span class="hljs-attr">&quot;ifNames&quot;:</span> [<span class="hljs-string">&quot;ens2f0&quot;</span>]            &#125;          &#125;        ]      &#125;  <span class="hljs-attr">secondaryNetwork:</span>    <span class="hljs-attr">cniPlugins:</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">plugins</span>      <span class="hljs-attr">repository:</span> <span class="hljs-string">ghcr.io/k8snetworkplumbingwg</span>      <span class="hljs-attr">version:</span> <span class="hljs-string">v0.8.7-amd64</span>    <span class="hljs-attr">multus:</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">multus-cni</span>      <span class="hljs-attr">repository:</span> <span class="hljs-string">ghcr.io/k8snetworkplumbingwg</span>      <span class="hljs-attr">version:</span> <span class="hljs-string">v3.8</span>      <span class="hljs-comment"># if config is missing or empty then multus config will be automatically generated from the CNI configuration file of the master plugin (the first file in lexicographical order in cni-conf-dir)</span>      <span class="hljs-attr">config:</span> <span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-attr">ipamPlugin:</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">whereabouts</span>      <span class="hljs-attr">repository:</span> <span class="hljs-string">ghcr.io/k8snetworkplumbingwg</span>      <span class="hljs-attr">version:</span> <span class="hljs-string">v0.5.4-amd64</span></code></pre><p><strong>MacvlanNetwork CRD</strong></p><p>用于定义Macvlan类型的第二网络，此CRD会被转成Intel Mutlus CNI的CRD <code>NetworkAttachmentDefinition</code>。</p><p>官方样例：</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">mellanox.com/v1alpha1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">MacvlanNetwork</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-macvlannetwork</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">networkNamespace:</span> <span class="hljs-string">&quot;default&quot;</span>  <span class="hljs-attr">master:</span> <span class="hljs-string">&quot;ens2f0&quot;</span>  <span class="hljs-attr">mode:</span> <span class="hljs-string">&quot;bridge&quot;</span>  <span class="hljs-attr">mtu:</span> <span class="hljs-number">1500</span>  <span class="hljs-attr">ipam:</span> <span class="hljs-string">|</span>    &#123;      <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;whereabouts&quot;</span>,      <span class="hljs-attr">&quot;datastore&quot;:</span> <span class="hljs-string">&quot;kubernetes&quot;</span>,      <span class="hljs-attr">&quot;kubernetes&quot;:</span> &#123;        <span class="hljs-attr">&quot;kubeconfig&quot;:</span> <span class="hljs-string">&quot;/etc/cni/net.d/whereabouts.d/whereabouts.kubeconfig&quot;</span>      &#125;,      <span class="hljs-attr">&quot;range&quot;:</span> <span class="hljs-string">&quot;192.168.2.225/28&quot;</span>,      <span class="hljs-attr">&quot;exclude&quot;:</span> [       <span class="hljs-string">&quot;192.168.2.229/30&quot;</span>,       <span class="hljs-string">&quot;192.168.2.236/32&quot;</span>      ],      <span class="hljs-string">&quot;log_file&quot;</span> <span class="hljs-string">:</span> <span class="hljs-string">&quot;/var/log/whereabouts.log&quot;</span>,      <span class="hljs-string">&quot;log_level&quot;</span> <span class="hljs-string">:</span> <span class="hljs-string">&quot;info&quot;</span>,      <span class="hljs-attr">&quot;gateway&quot;:</span> <span class="hljs-string">&quot;192.168.2.1&quot;</span>    &#125;</code></pre><p><strong>HostDeviceNetwork CRD</strong></p><p>用于定义HostDevice类型的第二网络，此CRD会被转成Intel Mutlus CNI的CRD <code>NetworkAttachmentDefinition</code>。</p><p>官方样例：</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">mellanox.com/v1alpha1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">HostDeviceNetwork</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-hostdevice-network</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">networkNamespace:</span> <span class="hljs-string">&quot;default&quot;</span>  <span class="hljs-attr">resourceName:</span> <span class="hljs-string">&quot;hostdev&quot;</span>  <span class="hljs-attr">ipam:</span> <span class="hljs-string">|</span>    &#123;      <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;whereabouts&quot;</span>,      <span class="hljs-attr">&quot;datastore&quot;:</span> <span class="hljs-string">&quot;kubernetes&quot;</span>,      <span class="hljs-attr">&quot;kubernetes&quot;:</span> &#123;        <span class="hljs-attr">&quot;kubeconfig&quot;:</span> <span class="hljs-string">&quot;/etc/cni/net.d/whereabouts.d/whereabouts.kubeconfig&quot;</span>      &#125;,      <span class="hljs-attr">&quot;range&quot;:</span> <span class="hljs-string">&quot;192.168.3.225/28&quot;</span>,      <span class="hljs-attr">&quot;exclude&quot;:</span> [       <span class="hljs-string">&quot;192.168.3.229/30&quot;</span>,       <span class="hljs-string">&quot;192.168.3.236/32&quot;</span>      ],      <span class="hljs-string">&quot;log_file&quot;</span> <span class="hljs-string">:</span> <span class="hljs-string">&quot;/var/log/whereabouts.log&quot;</span>,      <span class="hljs-string">&quot;log_level&quot;</span> <span class="hljs-string">:</span> <span class="hljs-string">&quot;info&quot;</span>    &#125;</code></pre><p><strong>IPoIBNetwork CRD</strong></p><p>用于定义IPoIB类型的第二网络，此CRD会被转成Intel Mutlus CNI的CRD <code>NetworkAttachmentDefinition</code>。</p><p>官方样例：</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">mellanox.com/v1alpha1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">IPoIBNetwork</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-ipoibnetwork</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">networkNamespace:</span> <span class="hljs-string">&quot;default&quot;</span>  <span class="hljs-attr">master:</span> <span class="hljs-string">&quot;ibs3f1&quot;</span>  <span class="hljs-attr">ipam:</span> <span class="hljs-string">|</span>    &#123;      <span class="hljs-attr">&quot;type&quot;:</span> <span class="hljs-string">&quot;whereabouts&quot;</span>,      <span class="hljs-attr">&quot;datastore&quot;:</span> <span class="hljs-string">&quot;kubernetes&quot;</span>,      <span class="hljs-attr">&quot;kubernetes&quot;:</span> &#123;        <span class="hljs-attr">&quot;kubeconfig&quot;:</span> <span class="hljs-string">&quot;/etc/cni/net.d/whereabouts.d/whereabouts.kubeconfig&quot;</span>      &#125;,      <span class="hljs-attr">&quot;range&quot;:</span> <span class="hljs-string">&quot;192.168.5.225/28&quot;</span>,      <span class="hljs-attr">&quot;exclude&quot;:</span> [       <span class="hljs-string">&quot;192.168.6.229/30&quot;</span>,       <span class="hljs-string">&quot;192.168.6.236/32&quot;</span>      ],      <span class="hljs-string">&quot;log_file&quot;</span> <span class="hljs-string">:</span> <span class="hljs-string">&quot;/var/log/whereabouts.log&quot;</span>,      <span class="hljs-string">&quot;log_level&quot;</span> <span class="hljs-string">:</span> <span class="hljs-string">&quot;info&quot;</span>,      <span class="hljs-attr">&quot;gateway&quot;:</span> <span class="hljs-string">&quot;192.168.6.1&quot;</span>    &#125;</code></pre><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>Mellanox-network-operator提供了许多种Kubernetes集成RDMA的方式。比如RDMA Shared Device Plugin、Host Device Network、SR-IOV方式等，SR-IOV方式有能分为传统的SR-IOV方式、用于IB网络的SR-IOV方式、用于Nvidia UFM的SR-IOV方式。下面以RoCE场景下（因工作中主要是用RoCE V2，其他方式以后再研究）几种部署方式进行介绍。</p><h4 id="RDMA-Shared-Device-Plugin"><a href="#RDMA-Shared-Device-Plugin" class="headerlink" title="RDMA Shared Device Plugin"></a>RDMA Shared Device Plugin</h4><p>RDMA Shared Device Plugin模式下，RDMA设备通过Device Plugin将device目录传递给容器，多个容器共享RDMA设备。部署后的架构如下图所示：</p><p><img src="/img/rdma-mellanox-operator-1.png"></p><p><strong>部署方式</strong>：<br>通过helm部署，helm的<code>values.yaml</code>如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">nfd:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">sriovNetworkOperator:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><span class="hljs-comment"># NicClusterPolicy CR values:</span><span class="hljs-attr">deployCR:</span> <span class="hljs-literal">true</span><span class="hljs-attr">ofedDriver:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">nvPeerDriver:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">rdmaSharedDevicePlugin:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">resources:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">rdma_shared_device_a</span>      <span class="hljs-attr">ifNames:</span> [<span class="hljs-string">ens1f0</span>]  <span class="hljs-attr">sriovDevicePlugin:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">false</span></code></pre><h4 id="Secondary-Network"><a href="#Secondary-Network" class="headerlink" title="Secondary Network"></a>Secondary Network</h4><p>Secondary Network模式下，RDMA网卡作为Pod的第二张网卡存在，第二张网卡的实现方式有多种，可以通过上面介绍的CRD进行配置。以macvlan为例，kubelet创建pod时，通过Multus CNI创建两张网卡，其中第一张为主网卡，第二张为使用RDMA设备创建的macvlan网卡，部署后的架构如下图所示：<br><img src="/img/rdma-mellanox-operator-2.png"></p><p><strong>部署方式</strong>：<br>通过helm部署，helm的<code>values.yaml</code>如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">nfd:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">sriovNetworkOperator:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><span class="hljs-comment"># NicClusterPolicy CR values:</span><span class="hljs-attr">deployCR:</span> <span class="hljs-literal">true</span><span class="hljs-attr">ofedDriver:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">false</span> <span class="hljs-attr">rdmaSharedDevicePlugin:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">resources:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">rdma_shared_device_a</span>      <span class="hljs-attr">ifNames:</span> [<span class="hljs-string">ens1f0</span>] <span class="hljs-attr">secondaryNetwork:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">multus:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">cniPlugins:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">ipamPlugin:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span></code></pre><h4 id="Host-Device-Network"><a href="#Host-Device-Network" class="headerlink" title="Host Device Network"></a>Host Device Network</h4><p>Host Device Network模式下，RDMA设备会先通过SR-IOV进行虚化，Pod的第二张网卡通过host- dev cni将VF或PF添加到Pod里，部署后的架构如下图所示：<br><img src="/img/rdma-mellanox-operator-3.png"><br><strong>部署方式</strong>：<br>通过helm部署，helm的<code>values.yaml</code>如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">nfd:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">sriovNetworkOperator:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><span class="hljs-comment"># NicClusterPolicy CR values:</span><span class="hljs-attr">deployCR:</span> <span class="hljs-literal">true</span><span class="hljs-attr">ofedDriver:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">rdmaSharedDevicePlugin:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">false</span> <span class="hljs-attr">sriovDevicePlugin:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">resources:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hostdev</span>      <span class="hljs-attr">vendors:</span> [<span class="hljs-string">15b3</span>]<span class="hljs-attr">secondaryNetwork:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">multus:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">cniPlugins:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">ipamPlugin:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span></code></pre><p>除此外还需通过<code>HostDeviceNetwork</code> CRD进行配置。</p><h4 id="SR-IOV-Operator"><a href="#SR-IOV-Operator" class="headerlink" title="SR-IOV Operator"></a>SR-IOV Operator</h4><p>SR-IOV Operator模式实际上是通过<a href="https://github.com/openshift/sriov-network-operator">sriov-network-operator</a>自动配置SR-IOV，然后通过SR-IOV cni配置pod网络，部署后的架构如下图所示：</p><p><img src="/img/rdma-mellanox-operator-4.png"></p><p><strong>部署方式</strong>：<br>通过helm部署，helm的<code>values.yaml</code>如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">nfd:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">sriovNetworkOperator:</span>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># NicClusterPolicy CR values:</span><span class="hljs-attr">deployCR:</span> <span class="hljs-literal">true</span><span class="hljs-attr">ofedDriver:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span><span class="hljs-attr">rdmaSharedDevicePlugin:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">false</span><span class="hljs-attr">sriovDevicePlugin:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">false</span> <span class="hljs-attr">secondaryNetwork:</span>  <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">multus:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">cniPlugins:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">ipamPlugin:</span>    <span class="hljs-attr">deploy:</span> <span class="hljs-literal">true</span></code></pre><h4 id="几种部署方式的比较"><a href="#几种部署方式的比较" class="headerlink" title="几种部署方式的比较"></a>几种部署方式的比较</h4><p>各种方式中，SR-IOV Operator在RoCE场景下更具有优势。相比Host Device Network方式，SR-IOV Operator自动化程度更高，通过sriov-network-operator的CRD可以配置各个节点的SR-IOV网卡配置；相比Macvlan的Secondary Network，SR-IOV虚拟化能带来比Macvlan更好的性能。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>Mellanox-network-operator提供的部署方式与功能特性（例如GPUDirect）是它的优点。缺点在于缺少集群调度层面的控制，与rit-k8s-rdma类似，无法根据设备拓扑进行RDMA资源的最优分配。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述三种方式中，在RoCE场景下，以Mellanox-Network-Operator的SR-IOV Operator部署方式为最优，但无法实现GPU与RDMA的PCIe对齐，以提高大模型的训练速度。<br>针对GPU与RDMA的PCIe对齐，Mellanox-Network-Operator的SR-IOV Operator部署方式欠缺的能力主要包括：<br>1）通过调度，选择可以为Pod分配相同PCIe Switch下GPU与RDMA资源的节点。<br>2）在节点层面，为Pod分配相同PCIe Switch下GPU与RDMA资源。由于目前NVIDIA GPU、Mellanox RDMA的资源分配方式均是使用Device Plugin机制，Device Plugin的资源分配基本完全由Kubelet决定，而Device Plugin资源的拓扑感知是受Kubelet topology manager控制，Kubelet topology manager只能做到NUMA对齐，因此无法做到PCIe的对齐。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>RDMA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AF_XDP的原理与应用</title>
    <link href="/2023/03/21/AF-XDP%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2023/03/21/AF-XDP%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>AF_XDP是一个协议族，能将DMA缓冲区映射到用户空间，实现zero-copy，用于高性能的数据包处理。</p><a id="more"></a><h2 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h2><p>XDP能在数据包进入协议栈之前就进行处理，根据XDP hook的位置不同，分为：</p><ul><li>Native XDP：在网卡驱动的接收路径中，需要网卡驱动的支持，比如<code>ixgbe</code>驱动的软中断处理中调用。</li><li>Offloaded XDP：不再通过CPU执行XDP程序，而是在网卡中执行XDP程序，由JIT将XDP程序编译成网卡（一般是智能网卡）可运行的指令码，卸载到网卡上。</li><li>Generic XDP：针对不支持Native XDP与Offloaded XDP的情况，提供的一种模式。在内核协议栈中运行。</li></ul><p>XDP对数据包的处理结果（Action）包括DROP、PASS、TX或REDIRECT。其中TX是将数据包从接收网卡中转发出去，REDIRECT是根据BPF MAP进行重定向，可以将数据包从其他网卡中转发出去，也可以将数据包重定向到AF_XDP socket中。</p><h2 id="AF-XDP的实现"><a href="#AF-XDP的实现" class="headerlink" title="AF_XDP的实现"></a>AF_XDP的实现</h2><p>AF_XDP的应用分为用户空间与内核空间两部分逻辑。在用户空间使用<code>socket()</code>系统调用创建一个AF_XDP套接字（XSK），用于应用接受、发送数据包；在内核空间利用XDP的<code>bpf_redirect_map()</code>，将数据包重定向到用户态中（可以通过XDP程序，决定哪些数据包走AF_XDP，哪些数据包走内核协议栈），实现数据包的高性能处理（跳过内核协议栈、sk_buff的创建）。</p><p><img src="/img/af_xdp_1.png"><br>图来自（<a href="https://medium.com/high-performance-network-programming/recapitulating-af-xdp-ef6c1ebead8%EF%BC%89">https://medium.com/high-performance-network-programming/recapitulating-af-xdp-ef6c1ebead8）</a></p><p>具体的，内核空间与用户空间共享一片内存区域，称为UMEM，UMEM划分为许多个chunk，使用chunk存储数据包。内核与用户空间的应用通过<code>RX RING</code>、<code>TX RING</code>、<code>FILL RING</code>、<code>COMPLETION RING</code>四个ring来操作UMEM，ring中的元素（称为desc）存储了指向UMEM某个chunk的addr。</p><p><img src="/img/af_xdp_2.png"><br>图来自（<a href="https://rexrock.github.io/post/af_xdp1/%EF%BC%89">https://rexrock.github.io/post/af_xdp1/）</a></p><ul><li><code>RX RING</code>：存储待XSK处理接收的数据包。<strong>内核为生产者，XSK为消费者</strong>。内核消费<code>FILL RING</code>，将数据包拷贝到<code>FILL RING</code>的desc指向的UMEM chunk中，然后将desc填充到<code>RX RING</code></li><li><code>TX RING</code>：存储待内核发送的数据包。<strong>XSK为生产者，内核为消费者</strong>。XSK消费<code>COMPLETION RING</code>，将要发送的数据包拷贝到<code>COMPLETION RING</code>的desc指向的UMEM chunk中，然后将desc填充到<code>TX RING</code>。</li><li><code>FILL RING</code>：存储可以承载数据包的chunk。<strong>XSK为生产者，内核为消费者</strong>。</li><li><code>COMPLETION RING</code>：存储已经发送完成的数据包。<strong>内核为生产者，XSK为消费者</strong>。</li></ul><p>以接收数据包的过程为例，用户态应用先填充<code>FILL RING</code>，等待数据包的接收。内核将接收到的数据包，拷贝到<code>FILL RING</code>中desc的UMEM chunk中，然后填充<code>RX RING</code>。用户态应用从<code>RX RING</code>中获取接收到的数据包，然后将desc填充回<code>FILL RING</code>，供下次内核接收数据包使用。发送数据包的过程类似，为<code>COMPLETION RING</code>、<code>TX RING</code>的配合使用。</p><h2 id="AF-XDP实例"><a href="#AF-XDP实例" class="headerlink" title="AF_XDP实例"></a>AF_XDP实例</h2><p>AF_XDP的实现分用户态程序与XDP程序。用户态程序初始化过程为：</p><ul><li>创建<code>AF_XDP</code> socket</li><li>申请UMEM</li><li>注册UMEM</li><li>创建四个RING</li><li>绑定到指定设备的某一队列</li></ul><p>XDP程序主要是根据BPF_MAP_TYPE_XSKMAP重定向到对应队列的XSK上。</p><p>C语言的实例在<code>samples/bpf/xdpsock_user.c</code>，可以参考<a href="https://rexrock.github.io/post/af_xdp1/">https://rexrock.github.io/post/af_xdp1/</a> 的分析。</p><p>Go语言的库可以使用<a href="https://github.com/asavie/xdp">asavie/xdp</a>，封装程度更高，以<code>examples/l2fwd</code>为例：</p><pre><code class="hljs go"><span class="hljs-comment">// asavie/xdp/examples/l2fwd/l2fwd.go</span><span class="hljs-comment">// 指定两个网卡，将其中任意一个网卡接收的帧以指定的mac地址，通过另一个网卡转发出去</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;     ...   forwardL2(verbose, inLink, inLinkQueueID, inLinkDst, outLink, outLinkQueueID, outLinkDst)  &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forwardL2</span><span class="hljs-params">(verbose <span class="hljs-keyword">bool</span>, inLink netlink.Link, inLinkQueueID <span class="hljs-keyword">int</span>, inLinkDst net.HardwareAddr, outLink netlink.Link, outLinkQueueID <span class="hljs-keyword">int</span>, outLinkDst net.HardwareAddr)</span></span> &#123;  ...   <span class="hljs-comment">// 创建xdp BPF程序，默认的XDP程序为&lt;linux&gt;/tools/lib/bpf/xsk.c下的xsk_load_xdp_prog()，进行简单的转发，也可以自定义xdp程序  </span>   <span class="hljs-comment">// This is the C-program:  </span><span class="hljs-comment">// SEC(&quot;xdp_sock&quot;) int xdp_sock_prog(struct xdp_md *ctx)  </span><span class="hljs-comment">// &#123;  </span><span class="hljs-comment">//     int *qidconf, index = ctx-&gt;rx_queue_index;  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//     // A set entry here means that the correspnding queue_id  </span><span class="hljs-comment">//     // has an active AF_XDP socket bound to it.  </span><span class="hljs-comment">//     qidconf = bpf_map_lookup_elem(&amp;qidconf_map, &amp;index);  </span><span class="hljs-comment">//     if (!qidconf)  </span><span class="hljs-comment">//         return XDP_ABORTED;  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//     if (*qidconf)  </span><span class="hljs-comment">//         return bpf_redirect_map(&amp;xsks_map, index, 0);  </span><span class="hljs-comment">//  </span><span class="hljs-comment">//     return XDP_PASS;  </span><span class="hljs-comment">// &#125;</span>   inProg, err := xdp.NewProgram(inLinkQueueID + <span class="hljs-number">1</span>)  ...   <span class="hljs-comment">// 加载到input的网卡上</span>   <span class="hljs-keyword">if</span> err := inProg.Attach(inLink.Attrs().Index);...   <span class="hljs-comment">// 创建input的XSK，需要指定网卡的队列</span>   inXsk, err := xdp.NewSocket(inLink.Attrs().Index, inLinkQueueID, <span class="hljs-literal">nil</span>)  ...  <span class="hljs-comment">// 将网卡队列的ID与XSK fd更新到map中，供xdp BPF程序转发</span>   <span class="hljs-keyword">if</span> err := inProg.Register(inLinkQueueID, inXsk.FD());...   <span class="hljs-comment">// 创建output的XSK，这里可能有问题？因为根据vagrant目录下的测试场景，outXsk仍需要转发回包，而不仅仅是作为output，后面的poll逻辑也说明了是个双向的转发，因此还是需要有bpf pro</span>   <span class="hljs-comment">// Note: The XDP socket used for transmitting data does not need an EBPF program.</span>   outXsk, err := xdp.NewSocket(outLink.Attrs().Index, outLinkQueueID, <span class="hljs-literal">nil</span>)  ...<span class="hljs-comment">// 使用poll监听发送和接收，也可以用xsk的Poll()方法，逻辑一样</span><span class="hljs-comment">// func (xsk *Socket) Poll(timeout int) (numReceived int, numCompleted int, err error)</span>   <span class="hljs-keyword">var</span> fds [<span class="hljs-number">2</span>]unix.PollFd     fds[<span class="hljs-number">0</span>].Fd = <span class="hljs-keyword">int32</span>(inXsk.FD())     fds[<span class="hljs-number">1</span>].Fd = <span class="hljs-keyword">int32</span>(outXsk.FD())     <span class="hljs-keyword">for</span> &#123;     <span class="hljs-comment">// 先填充两个socket的fill ring。xsk的实现里面，fill ring与rx ring指向的缓存区域在umem的前半部分，complete ring与tx ring指向的缓存区域在umem的后半部分</span>      inXsk.Fill(inXsk.GetDescs(inXsk.NumFreeFillSlots(), <span class="hljs-literal">true</span>))        outXsk.Fill(outXsk.GetDescs(outXsk.NumFreeFillSlots(), <span class="hljs-literal">true</span>))  <span class="hljs-comment">// 监听socket的读写。NumTransmitted()返回的是通过tx ring进行发送，但未调用Complete()对complete ring进行消费的</span>      fds[<span class="hljs-number">0</span>].Events = unix.POLLIN        <span class="hljs-keyword">if</span> inXsk.NumTransmitted() &gt; <span class="hljs-number">0</span> &#123;           fds[<span class="hljs-number">0</span>].Events |= unix.POLLOUT        &#125;          fds[<span class="hljs-number">1</span>].Events = unix.POLLIN        <span class="hljs-keyword">if</span> outXsk.NumTransmitted() &gt; <span class="hljs-number">0</span> &#123;           fds[<span class="hljs-number">1</span>].Events |= unix.POLLOUT        &#125;          fds[<span class="hljs-number">0</span>].Revents = <span class="hljs-number">0</span>        fds[<span class="hljs-number">1</span>].Revents = <span class="hljs-number">0</span>        _, err := unix.Poll(fds[:], <span class="hljs-number">-1</span>)      ...<span class="hljs-comment">// inXsk收到POLLIN，将inXsk接收的数据发送到outXsk</span>      <span class="hljs-keyword">if</span> (fds[<span class="hljs-number">0</span>].Revents &amp; unix.POLLIN) != <span class="hljs-number">0</span> &#123;           numBytes, numFrames := forwardFrames(inXsk, outXsk, inLinkDst)           ...      &#125;        <span class="hljs-comment">// inXsk收到POLLOUT，消费complete ring，标记对应的descs为freeTXDescs，以供下次Transmit使用</span>      <span class="hljs-keyword">if</span> (fds[<span class="hljs-number">0</span>].Revents &amp; unix.POLLOUT) != <span class="hljs-number">0</span> &#123;           inXsk.Complete(inXsk.NumCompleted())        &#125;        <span class="hljs-comment">// 同上，将outXsk接收的数据发送到inXsk</span>      <span class="hljs-keyword">if</span> (fds[<span class="hljs-number">1</span>].Revents &amp; unix.POLLIN) != <span class="hljs-number">0</span> &#123;           numBytes, numFrames := forwardFrames(outXsk, inXsk, outLinkDst)           numBytesTotal += numBytes           numFramesTotal += numFrames        &#125;       <span class="hljs-keyword">if</span> (fds[<span class="hljs-number">1</span>].Revents &amp; unix.POLLOUT) != <span class="hljs-number">0</span> &#123;           outXsk.Complete(outXsk.NumCompleted())        &#125;     &#125;  &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forwardFrames</span><span class="hljs-params">(input *xdp.Socket, output *xdp.Socket, dstMac net.HardwareAddr)</span> <span class="hljs-params">(numBytes <span class="hljs-keyword">uint64</span>, numFrames <span class="hljs-keyword">uint64</span>)</span></span> &#123;  <span class="hljs-comment">// 接收</span>   inDescs := input.Receive(input.NumReceived())     <span class="hljs-comment">// 替换数据包的mac地址，直接将dstMac拷贝到对应的umem chuck地址上</span>   replaceDstMac(input, inDescs, dstMac)  <span class="hljs-comment">// 获取tx ring中空的descs，其实就是在Complete()中标记为freeTXDescs的descs</span>   outDescs := output.GetDescs(output.NumFreeTxSlots(), <span class="hljs-literal">false</span>)     <span class="hljs-comment">// tx ring不足，进行rx的截断</span>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inDescs) &gt; <span class="hljs-built_in">len</span>(outDescs) &#123;        inDescs = inDescs[:<span class="hljs-built_in">len</span>(outDescs)]     &#125;     numFrames = <span class="hljs-keyword">uint64</span>(<span class="hljs-built_in">len</span>(inDescs))  <span class="hljs-comment">// 将inFrame拷贝到outFrame，这里是数据包的拷贝，而非ring中元素的拷贝，因为input、output xsk有各自的umem。如果是一个xsk的接收与发送，则可以直接修改descs即可</span>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(inDescs); i++ &#123;        outFrame := output.GetFrame(outDescs[i])        inFrame := input.GetFrame(inDescs[i])        numBytes += <span class="hljs-keyword">uint64</span>(<span class="hljs-built_in">len</span>(inFrame))        outDescs[i].Len = <span class="hljs-keyword">uint32</span>(<span class="hljs-built_in">copy</span>(outFrame, inFrame))     &#125;     outDescs = outDescs[:<span class="hljs-built_in">len</span>(inDescs)]       output.Transmit(outDescs)       <span class="hljs-keyword">return</span>  &#125;</code></pre><h2 id="AF-XDP的应用"><a href="#AF-XDP的应用" class="headerlink" title="AF_XDP的应用"></a>AF_XDP的应用</h2><ul><li>VPP利用<a href="https://docs.fd.io/vpp/21.01/d8/d44/af_xdp_doc.html"><code>af_xdp plugin</code></a>将数据包发送到用户空间</li><li>B站<a href="https://www.bilibili.com/read/cv20778694">使用AF_XDP处理QUIC和HTTP/3</a>，带宽能提示提升25%～30%左右</li><li>DPDK使用<a href="https://doc.dpdk.org/guides-21.08/nics/af_xdp.html">AF_XDP实现PMD</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://rexrock.github.io/post/af_xdp1/">https://rexrock.github.io/post/af_xdp1/</a><br><a href="https://www.kernel.org/doc/html/next/networking/af_xdp.html">https://www.kernel.org/doc/html/next/networking/af_xdp.html</a><br><a href="https://archive.fosdem.org/2018/schedule/event/af_xdp/">https://archive.fosdem.org/2018/schedule/event/af_xdp/</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eBPF在CPU调度上的应用</title>
    <link href="/2023/03/15/eBPF%E5%9C%A8CPU%E8%B0%83%E5%BA%A6%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/03/15/eBPF%E5%9C%A8CPU%E8%B0%83%E5%BA%A6%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>目前的<a href="https://ebpf.io/applications/">开源项目</a>中，主要是将eBPF应用在网络、安全、系统观测方面。近些年eBPF技术也开始应用在调度器上，实现调度器的可观察、可编程。本文主要介绍一些eBPF技术在调度器上的应用尝试。</p><a id="more"></a><h2 id="调度器简介"><a href="#调度器简介" class="headerlink" title="调度器简介"></a>调度器简介</h2><p>在Linux中，调度器被抽象为调度类<code>sched_class</code>，调度类中包括了各种调度处理函数，由各种调度算法实现。</p><pre><code class="hljs c"><span class="hljs-comment">// kernel/sched/sched.h</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span> &#123;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_UCLAMP_TASK</span><span class="hljs-keyword">int</span> uclamp_enabled;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">// 将进程加入到调度队列中</span><span class="hljs-keyword">void</span> (*enqueue_task) (struct rq *rq, struct task_struct *p, <span class="hljs-keyword">int</span> flags);<span class="hljs-comment">// 将进程从调度队列中删除</span><span class="hljs-keyword">void</span> (*dequeue_task) (struct rq *rq, struct task_struct *p, <span class="hljs-keyword">int</span> flags);<span class="hljs-comment">// 当进程主动放弃CPU时调用</span><span class="hljs-keyword">void</span> (*yield_task)   (struct rq *rq);<span class="hljs-keyword">bool</span> (*yield_to_task)(struct rq *rq, struct task_struct *p);<span class="hljs-comment">// 检查当前进程是否可被强占</span><span class="hljs-keyword">void</span> (*check_preempt_curr)(struct rq *rq, struct task_struct *p, <span class="hljs-keyword">int</span> flags);<span class="hljs-comment">// 从调度类中选出下一个要运行的进程</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *(*<span class="hljs-title">pick_next_task</span>)(<span class="hljs-title">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span>);</span><span class="hljs-comment">// 将进程放回运行队列</span><span class="hljs-keyword">void</span> (*put_prev_task)(struct rq *rq, struct task_struct *p);<span class="hljs-comment">// 选择下一个进程</span><span class="hljs-keyword">void</span> (*set_next_task)(struct rq *rq, struct task_struct *p, <span class="hljs-keyword">bool</span> first);<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_SMP</span><span class="hljs-comment">// SMP负载均衡</span><span class="hljs-keyword">int</span> (*balance)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);<span class="hljs-comment">// 为进程选择一个适合的CPU</span><span class="hljs-keyword">int</span>  (*select_task_rq)(struct task_struct *p, <span class="hljs-keyword">int</span> task_cpu, <span class="hljs-keyword">int</span> flags);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> * (*<span class="hljs-title">pick_task</span>)(<span class="hljs-title">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span>);</span><span class="hljs-comment">// 迁移到另外的CPU调度队列中</span><span class="hljs-keyword">void</span> (*migrate_task_rq)(struct task_struct *p, <span class="hljs-keyword">int</span> new_cpu);<span class="hljs-comment">// 用于进程唤醒</span><span class="hljs-keyword">void</span> (*task_woken)(struct rq *this_rq, struct task_struct *task);<span class="hljs-comment">// 修改进程CPU亲和性</span><span class="hljs-keyword">void</span> (*set_cpus_allowed)(struct task_struct *p, struct affinity_context *ctx);<span class="hljs-comment">// 启动、关闭运行队列</span><span class="hljs-keyword">void</span> (*rq_online)(struct rq *rq);<span class="hljs-keyword">void</span> (*rq_offline)(struct rq *rq);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span> *(*<span class="hljs-title">find_lock_rq</span>)(<span class="hljs-title">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>, <span class="hljs-title">struct</span> <span class="hljs-title">rq</span> *<span class="hljs-title">rq</span>);</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">// 由time_tick调用。它可能引起进程切换，驱动运行时（running）抢占</span><span class="hljs-keyword">void</span> (*task_tick)(struct rq *rq, struct task_struct *p, <span class="hljs-keyword">int</span> queued);<span class="hljs-comment">// 在进程创建时调用</span><span class="hljs-keyword">void</span> (*task_fork)(struct task_struct *p);<span class="hljs-comment">// 在进程退出时调用</span><span class="hljs-keyword">void</span> (*task_dead)(struct task_struct *p);<span class="hljs-comment">/*</span><span class="hljs-comment"> * The switched_from() call is allowed to drop rq-&gt;lock, therefore we</span><span class="hljs-comment"> * cannot assume the switched_from/switched_to pair is serialized by</span><span class="hljs-comment"> * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.</span><span class="hljs-comment"> */</span> <span class="hljs-comment">// 用于进程切换</span><span class="hljs-keyword">void</span> (*switched_from)(struct rq *this_rq, struct task_struct *task);<span class="hljs-keyword">void</span> (*switched_to)  (struct rq *this_rq, struct task_struct *task);<span class="hljs-comment">// 改变进程优先级</span><span class="hljs-keyword">void</span> (*prio_changed) (struct rq *this_rq, struct task_struct *task,      <span class="hljs-keyword">int</span> oldprio);<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-params">(*get_rr_interval)</span><span class="hljs-params">(struct rq *rq,</span></span><span class="hljs-function"><span class="hljs-params">struct task_struct *task)</span></span>;<span class="hljs-comment">// 更新进程调度信息，比如cfs的vruntime</span><span class="hljs-keyword">void</span> (*update_curr)(struct rq *rq);<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span><span class="hljs-keyword">void</span> (*task_change_group)(struct task_struct *p);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;;</code></pre><p>一般系统调度发生在调用<code>cond_resched()</code>、调用<code>schedule()</code>、从系统调用或中断返回时。在系统创建调用器时，会初始化一个调度定时器，定时器每隔一段时间执行一次中断，判断任务是否要调度，并设置标志位，在中断结束后，由调度算法进行调度。在Linux对于普通进程的调度器是基于红黑树的CFS调度算法。</p><h2 id="BPF-PROG-TYPE-SCHED类型的BPF程序"><a href="#BPF-PROG-TYPE-SCHED类型的BPF程序" class="headerlink" title="BPF_PROG_TYPE_SCHED类型的BPF程序"></a><code>BPF_PROG_TYPE_SCHED</code>类型的BPF程序</h2><p>Roman Gushchin提交的patchset引入了一种新的<code>BPF_PROG_TYPE_SCHED</code>类型的BPF程序，对CFS调度类插入了三个hook：</p><ul><li><p><code>cfs_check_preempt_tick</code>：，在处理调度定时器tick时调用，attach此处的eBPF程序可以查看哪个进程正在运行。当eBPF返回值小于0时，表示该进程可以继续执行，防止其被抢占；当eBPF返回值大于0时，表示该进程需要被切换，由cfs选择新的进程进行抢占；当eBPF返回0时，eBPF不影响调度。</p><pre><code class="hljs c"><span class="hljs-comment">// hook点在`kernel/sched/fair.c`的`check_preempt_tick()`中</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>check_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)&#123; ... ideal_runtime = sched_slice(cfs_rq, curr); delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;<span class="hljs-keyword">if</span> (bpf_sched_enabled()) &#123;<span class="hljs-keyword">int</span> ret = bpf_sched_cfs_check_preempt_tick(curr, delta_exec);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)resched_curr(rq_of(cfs_rq));&#125;...&#125;</code></pre></li><li><p><code>cfs_check_preempt_wakeup</code>在进程被内核唤醒时被调用。当eBPF返回负值时，将阻止该进程抢占正在运行的进程；返回正值，则进行强制抢占；返回0则不影响，留给后续调度算法决定。</p><pre><code class="hljs c"><span class="hljs-comment">// hook点在`kernel/sched/fair.c`的`check_preempt_wakeup()`中</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check_preempt_wakeup</span><span class="hljs-params">(struct rq *rq, struct task_struct *p, <span class="hljs-keyword">int</span> wake_flags)</span></span><span class="hljs-function"></span>&#123;...<span class="hljs-comment">/* Idle tasks are by definition preempted by non-idle tasks. */</span><span class="hljs-keyword">if</span> (unlikely(task_has_idle_policy(curr)) &amp;&amp;    likely(!task_has_idle_policy(p)))<span class="hljs-keyword">goto</span> preempt; <span class="hljs-keyword">if</span> (bpf_sched_enabled()) &#123;<span class="hljs-keyword">int</span> ret = bpf_sched_cfs_check_preempt_wakeup(current, p);<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)<span class="hljs-keyword">goto</span> preempt;&#125;...&#125;</code></pre></li><li><p><code>cfs_wakeup_preempt_entity</code>与<code>cfs_check_preempt_wakeup</code>类似，在新的进程被选中运行时调用，返回值为负数表示不执行抢占，返回值为正式表示强制抢占，返回0不影响。</p><pre><code class="hljs c"><span class="hljs-comment">// hook点在`kernel/sched/fair.c`的`wakeup_preempt_entity()`中</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>wakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se) &#123; s64 gran, vdiff = curr-&gt;vruntime - se-&gt;vruntime; <span class="hljs-keyword">if</span> (bpf_sched_enabled()) &#123;<span class="hljs-keyword">int</span> ret = bpf_sched_cfs_wakeup_preempt_entity(curr, se);<span class="hljs-keyword">if</span> (ret)<span class="hljs-keyword">return</span> ret;&#125; <span class="hljs-keyword">if</span> (vdiff &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;...&#125;</code></pre></li></ul><p>通过这种对CFS调度器加hook，使用BPF影响CPU调度的方式，Facebook在主网页上获得了很好的延迟以及1%RPS提升。详见<a href="https://www.phoronix.com/scan.php?page=news_item&px=Linux-BPF-Scheduler">Early Patches Bring BPF To The Linux Scheduler</a>、<a href="https://lwn.net/Articles/873244">LWN: Controlling the CPU scheduler with BPF</a>。</p><h2 id="sched-ext调度类"><a href="#sched-ext调度类" class="headerlink" title="sched_ext调度类"></a><code>sched_ext</code>调度类</h2><p>内核中，一般会用一个C结构体包含一组函数指针的方式，抽象一些实现，比如上面的<code>sched_class</code>。eBPF的<code>struct_ops</code>特性允许通过BPF程序实现内核里的这种结构体，来实现额外功能。最初<code>struct_ops</code>是用在TCP的拥塞控制上，而目前也用于实现调度算法的扩展上。</p><p><a href="https://github.com/htejun/sched_ext"><code>sched_ext</code></a>项目实现了一个<code>sched_ext</code>调度类（简称为SCX），使用<code>struct sched_ext_ops</code>定义了一组调度处理的函数，eBPF程序通过实现<code>struct sched_ext_ops</code>中的函数来实现调度算法。以下方法中只有<code>name</code>不能为空，其他的都是可选。</p><pre><code class="hljs c"><span class="hljs-comment">// include/linux/sched/ext.h</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_ext_ops</span> &#123;</span><span class="hljs-comment">/* 为被唤醒的进程选择CPU */</span>s32 (*select_cpu)(struct task_struct *p, s32 prev_cpu, u64 wake_flags);<span class="hljs-comment">/* 将进程加入调度队列 */</span><span class="hljs-keyword">void</span> (*enqueue)(struct task_struct *p, u64 enq_flags);<span class="hljs-comment">/* 将进程从调度队列中删除 */</span><span class="hljs-keyword">void</span> (*dequeue)(struct task_struct *p, u64 deq_flags);<span class="hljs-comment">/* 分配调度任务 */</span><span class="hljs-keyword">void</span> (*dispatch)(s32 cpu, struct task_struct *prev);<span class="hljs-comment">/* 任务在CPU上变为runnable，与下面三个方法一起，用于跟踪任务的状态转变。任务会依次经过runable，多次的running、stopping，然后完成执行，变为quiescent*/</span><span class="hljs-keyword">void</span> (*runnable)(struct task_struct *p, u64 enq_flags);<span class="hljs-keyword">void</span> (*running)(struct task_struct *p);<span class="hljs-keyword">void</span> (*stopping)(struct task_struct *p, <span class="hljs-keyword">bool</span> runnable);<span class="hljs-keyword">void</span> (*quiescent)(struct task_struct *p, u64 deq_flags);<span class="hljs-comment">/* yield 让出CPU，to是可选的 */</span><span class="hljs-keyword">bool</span> (*yield)(struct task_struct *from, struct task_struct *to);<span class="hljs-comment">/* Core scheduling的任务排序 */</span><span class="hljs-keyword">bool</span> (*core_sched_before)(struct task_struct *a, struct task_struct *b);<span class="hljs-comment">/* 配置cpu亲和性 */</span><span class="hljs-keyword">void</span> (*set_cpumask)(struct task_struct *p, struct cpumask *cpumask);<span class="hljs-comment">/* cpu空闲状态变化时调用 */</span><span class="hljs-keyword">void</span> (*update_idle)(s32 cpu, <span class="hljs-keyword">bool</span> idle);<span class="hljs-comment">/* 当cpu重新对BPF调度器可用时调用。和下面的cpu_release是一对，cpu_release是当cpu对BPF调度器不可用时调用,一般出现在更高等级的sched_class对cpu的抢占的情况 */</span><span class="hljs-keyword">void</span> (*cpu_acquire)(s32 cpu, struct scx_cpu_acquire_args *args);<span class="hljs-keyword">void</span> (*cpu_release)(s32 cpu, struct scx_cpu_release_args *args);<span class="hljs-comment">/* cpu上、下线时调用 */</span><span class="hljs-keyword">void</span> (*cpu_online)(s32 cpu);<span class="hljs-keyword">void</span> (*cpu_offline)(s32 cpu);<span class="hljs-comment">/* 从task进入BPF调度器，到退出BPF调度器的一些操作 */</span>s32 (*prep_enable)(struct task_struct *p, struct scx_enable_args *args);<span class="hljs-keyword">void</span> (*enable)(struct task_struct *p, struct scx_enable_args *args);<span class="hljs-keyword">void</span> (*cancel_enable)(struct task_struct *p,      struct scx_enable_args *args);<span class="hljs-keyword">void</span> (*disable)(struct task_struct *p);<span class="hljs-comment">/* cgroup相关的操作触发的调度逻辑 */</span>s32 (*cgroup_init)(struct cgroup *cgrp,   struct scx_cgroup_init_args *args);<span class="hljs-keyword">void</span> (*cgroup_exit)(struct cgroup *cgrp);s32 (*cgroup_prep_move)(struct task_struct *p,struct cgroup *from, struct cgroup *to);<span class="hljs-keyword">void</span> (*cgroup_move)(struct task_struct *p,    struct cgroup *from, struct cgroup *to);<span class="hljs-keyword">void</span> (*cgroup_cancel_move)(struct task_struct *p,   struct cgroup *from, struct cgroup *to);<span class="hljs-keyword">void</span> (*cgroup_set_weight)(struct cgroup *cgrp, u32 weight);<span class="hljs-comment">// BPF调度器初始化/退出的逻辑</span>s32 (*init)(<span class="hljs-keyword">void</span>);<span class="hljs-keyword">void</span> (*<span class="hljs-built_in">exit</span>)(struct scx_exit_info *info);<span class="hljs-comment">/* dispatch()可分配的最大任务数 */</span>u32 dispatch_max_batch;u64 flags;u32 timeout_ms;<span class="hljs-keyword">char</span> name[SCX_OPS_NAME_LEN];&#125;;</code></pre><p><code>sched_ext</code>调度类的调度过程为：</p><p>1）当任务被唤醒，调用<code>ops.select_cpu()</code>获取cpu选择（并不是最终调度到的CPU），如果cpu在idle状态，则同时唤醒cpu。</p><p>2）一旦CPU被选中，调用<code>ops.enqueue()</code>入队。</p><blockquote><p><code>sched_ext</code>使用简单的FIFO队列，<code>sched_ext</code>中称为DSQ，队列分为两类：一类是全局队列<code>SCX_DSQ_GLOBAL</code>；一类是per-cpu的本地队列<code>SCX_DSQ_LOCAL</code>。默认情况下有一个<code>SCX_DSQ_GLOBAL</code>，每个cpu有一个<code>SCX_DSQ_LOCAL</code>。也可以通过<code>scx_bpf_create_dsq()</code>与<code>scx_bpf_destroy_dsq()</code>创建自定义的队列。<br><code>ops.enqueue</code>可以立即将任务通过helper函数<code>scx_bpf_dispatch()</code>加入到<code>SCX_DSQ_GLOBAL</code>或<code>SCX_DSQ_LOCAL</code>；也可以通过指定DSQ的ID，将其加入到自定义的队列中；或者是在BPF程序中进行排队（下面的<code>qmap</code>例子中就是这种情况）。</p></blockquote><p>3）当CPU准备好进行调度，会先从它的<code>SCX_DSQ_LOCAL</code>中获取任务，如果<code>SCX_DSQ_LOCAL</code>为空，则从<code>SCX_DSQ_GLOBAL</code>中获取任务。如果还是没有可执行的任务，就会调用<code>ops.dispatch()</code>。<code>ops.dispatch()</code>可以使用如下的helper函数，为local DSQ生成任务：</p><ul><li><code>scx_bpf_dispatch()</code>将一个任务分配到DSQ中，可以是任意的DSQ（<code>SCX_DSQ_LOCAL</code>, <code>SCX_DSQ_LOCAL_ON | cpu</code>, <code>SCX_DSQ_GLOBAL</code>或者自定义DSQ）。任务的分配不是立即生效的，最多会有<code>ops.dispatch_max_batch</code>个待分配的任务。</li><li><code>scx_bpf_consume()</code> 将一个任务从non-local DSQ转移到调度的DSQ中。</li></ul><p>4）调用<code>ops.dispatch()</code>后，如果<code>SCX_DSQ_LOCAL</code>中存在任务，则运行。如果为空，则依次执行：</p><ul><li>从<code>SCX_DSQ_GLOBAL</code>中获取任务</li><li>如果<code>ops.dispatch()</code>已经进行相应的分配，则重复步骤3</li><li>如果之前的任务为SCX的任务，且可运行，则运行之前的任务</li><li>idle</li></ul><p><code>tools/sched_ext/</code>下有大量用例，其中<code>scx_example_qmap[.bpf].c</code>使用<code>BPF_MAP_TYPE_QUEUE</code>实现了五个FIFO的调度，按照“先调度1个queue0上的任务，再调度2个queue1上的任务，再调度4个queue2上的任务，依次类推”的方式进行调度，下面介绍下是如何实现的。</p><ul><li><p>当进程被唤醒时，调用<code>enqueue()</code>将进程加入ebpf map中排队</p><pre><code class="hljs c"><span class="hljs-comment">// qmap的enqueue实现</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPF_STRUCT_OPS</span><span class="hljs-params">(qmap_enqueue, struct task_struct *p, u64 enq_flags)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">static</span> u32 user_cnt, kernel_cnt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_ctx</span> *<span class="hljs-title">tctx</span>;</span>u32 pid = p-&gt;pid;<span class="hljs-comment">// 进程的scx权重，亦是fifo队列的序号</span><span class="hljs-keyword">int</span> idx = weight_to_idx(p-&gt;scx.weight);<span class="hljs-keyword">void</span> *ring;...<span class="hljs-comment">// queue_arr是一个BPF_MAP_TYPE_ARRAY_OF_MAPS类型的map，存储了5个BPF_MAP_TYPE_QUEUE，作为5个fifo调度队列</span>ring = bpf_map_lookup_elem(&amp;queue_arr, &amp;idx);<span class="hljs-keyword">if</span> (!ring) &#123;scx_bpf_error(<span class="hljs-string">&quot;failed to find ring %d&quot;</span>, idx);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 将任务push到fifo队列中，如果队列满了，就直接扔到SCX_DSQ_GLOBAL中</span><span class="hljs-keyword">if</span> (bpf_map_push_elem(ring, &amp;pid, <span class="hljs-number">0</span>)) &#123;scx_bpf_dispatch(p, SCX_DSQ_GLOBAL, slice_ns, enq_flags);<span class="hljs-keyword">return</span>;&#125;__sync_fetch_and_add(&amp;nr_enqueued, <span class="hljs-number">1</span>);&#125;</code></pre></li><li><p>当CPU从<code>SCX_DSQ_LOCAL</code>、<code>SCX_DSQ_GLOBAL</code>获取不到任务后，调用<code>dispatch()</code>重新获取任务</p></li></ul><pre><code class="hljs c"><span class="hljs-comment">// qmap的dispatch实现</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BPF_STRUCT_OPS</span><span class="hljs-params">(qmap_dispatch, s32 cpu, struct task_struct *prev)</span></span><span class="hljs-function"></span>&#123;...<span class="hljs-comment">// idx是fifo的序号，cnt记录对应fifo还能调度多少个任务，两者保存在BPF_MAP_TYPE_PERCPU_ARRAY中</span>u64 *idx = bpf_map_lookup_elem(&amp;dispatch_idx_cnt, &amp;zero);u64 *cnt = bpf_map_lookup_elem(&amp;dispatch_idx_cnt, &amp;one);...<span class="hljs-comment">// 循环5个fifo，获取需要调度的任务</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<span class="hljs-comment">// cnt非正，则继续调度下一个fifo</span><span class="hljs-keyword">if</span> (!*cnt) &#123;*idx = (*idx + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>;*cnt = <span class="hljs-number">1</span> &lt;&lt; *idx;&#125;(*cnt)--;<span class="hljs-comment">// 查找到对应的fifo</span>fifo = bpf_map_lookup_elem(&amp;queue_arr, idx);<span class="hljs-keyword">if</span> (!fifo) &#123;scx_bpf_error(<span class="hljs-string">&quot;failed to find ring %llu&quot;</span>, *idx);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 从fifo中获取对应的任务pid</span><span class="hljs-keyword">if</span> (!bpf_map_pop_elem(fifo, &amp;pid)) &#123;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">p</span>;</span><span class="hljs-comment">// bpf_task_from_pid是一个helper函数，根据pid获取对应的task_struct，获取到就进行调度，否则尝试下一个fifo</span>p = bpf_task_from_pid(pid);<span class="hljs-keyword">if</span> (p) &#123;update_core_sched_head_seq(p);__sync_fetch_and_add(&amp;nr_dispatched, <span class="hljs-number">1</span>);<span class="hljs-comment">// 通过helper函数scx_bpf_dispatch，将任务推到SCX_DSQ_GLOBAL调度队列中，后续待CPU调度完SCX_DSQ_LOCAL后，从中拿出运行</span>scx_bpf_dispatch(p, SCX_DSQ_GLOBAL, slice_ns, <span class="hljs-number">0</span>);<span class="hljs-comment">// 释放task_struct的引用</span>bpf_task_release(p);<span class="hljs-keyword">return</span>;&#125;&#125;*cnt = <span class="hljs-number">0</span>;&#125;&#125;</code></pre><p><code>qmap</code>实现的功能不止这些，还实现了core-sched的支持、高优先级调度类的抢占、对每第n个任务进行暂停等，在<code>scx_example_qmap.bpf.c</code>的头部注释里有介绍，实现在其他的<code>struct sched_ext_ops</code>方法中。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在LCP 2021，Google有分享过<a href="https://lpc.events/event/11/contributions/954/attachments/776/1463/eBPF%20in%20CPU%20Scheduler.pdf">eBPF in CPU Scheduler</a>。主要包括三方面：</p><p>1、通过对<code>sched_switch</code>与<code>sched_wakeup</code>的Trace，来获取调度延迟数据，并指导调度<br>2、Core scheduling中为防止Cross-HT attack，会进行forced idle。通过eBPF统计forced idle的时间。<br>3、针对Google自己的调度系统<a href="https://github.com/google/ghost-kernel"><code>ghOST</code></a>，通过eBPF减少调度延迟。<code>ghOST</code>的目标与<code>sched_ext</code>类似，也是提供一种可开发、易部署的调度器开发框架，但<code>ghOST</code>将调度代码运行在用户空间，而非内核空间。</p><p>除此外，在在离线混部的场景下，也能通过eBPF监控调度，检测应用的干扰。比如阿里的开源混部项目<code>koordinator</code>也有这样的<a href="https://github.com/koordinator-sh/koordinator/blob/main/docs/proposals/20221205-cpu-schedule-latency.md">方案</a>。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KPNG：下一代Kube-Proxy</title>
    <link href="/2022/12/14/KPNG%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3Kube-Proxy/"/>
    <url>/2022/12/14/KPNG%EF%BC%9A%E4%B8%8B%E4%B8%80%E4%BB%A3Kube-Proxy/</url>
    
    <content type="html"><![CDATA[<p>kpng是社区新设计开发的下一代Kube-Proxy，目前仍然在积极开发中。<br>官方repo：<a href="https://github.com/kubernetes-sigs/kpng">https://github.com/kubernetes-sigs/kpng</a><br>kep：<a href="https://github.com/kubernetes/enhancements/pull/2094">https://github.com/kubernetes/enhancements/pull/2094</a></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>kpng主要目的是：</p><ul><li>解耦Kubernetes的业务逻辑（比如serivce的externalTrafficPolicy、internalTrafficPolicy之类逻辑）与后端proxy的实现，以实现一套通用的框架。<br> 对于当前的Kube-Proxy，如果要自己开发其他类型的proxy，需要实现自己的proxier来实现<a href="https://github.com/kubernetes/kubernetes/blob/23c65ec590/pkg/proxy/types.go#L30">Provider</a> 接口，而Provider接口包含了对Service、Endpoint、Node资源的处理逻辑，这部分对于所有proxier来说都是重复的代码。同时，不同proxier内部也存在某些子系统的重复逻辑，比如conntrack模块。</li><li>提高可扩展性，支撑更大规模的集群。目前Kube-Proxy的扩展需要增加对Kube-APIServer的watch请求，不利于规模的扩大。</li></ul><p>kpng的主要思路如下：</p><pre><code class="hljs xl">[<span class="hljs-function"><span class="hljs-title">k8s</span> API] ----&gt;</span> [<span class="hljs-function"><span class="hljs-title">local</span> model] ----&gt;</span> [<span class="hljs-function"><span class="hljs-title">plugin</span>] ----&gt;</span> [<span class="hljs-function"><span class="hljs-title">aggregator</span>] ----&gt;</span> [subsystem]</code></pre><p>1）根据k8s API的资源，构建一个本地期望状态ENLS（expected node-local state），只有当ENLS发生变化的时候，后端plugin才会触发操作。<br>相比Kube-Proxy直接监听Kube-APIServer的event，这种方式能减少无效触发（不改变ENLS的API event）。引用社区在1K service、1.5K pod下的测试。其中rev是ENLS发送变化的event数量，events是API events。</p><pre><code class="hljs apache"><span class="hljs-attribute">stats</span>:timeeventsrevusr cpusys cputot cpumemrevs/events<span class="hljs-attribute">stats</span>:mscountcountmsms%MiB%<span class="hljs-attribute">stats</span>:<span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>+Inf<span class="hljs-number">1</span>.<span class="hljs-number">22</span>NaN<span class="hljs-attribute">stats</span>:<span class="hljs-number">1000</span><span class="hljs-number">2134</span><span class="hljs-number">1064</span><span class="hljs-number">3</span><span class="hljs-number">308</span><span class="hljs-number">31</span>.<span class="hljs-number">280</span><span class="hljs-number">3</span>.<span class="hljs-number">93</span><span class="hljs-number">49</span>.<span class="hljs-number">859</span><span class="hljs-attribute">stats</span>:<span class="hljs-number">2000</span><span class="hljs-number">2137</span><span class="hljs-number">1064</span><span class="hljs-number">0</span><span class="hljs-number">1</span><span class="hljs-number">0</span>.<span class="hljs-number">131</span><span class="hljs-number">3</span>.<span class="hljs-number">94</span><span class="hljs-number">49</span>.<span class="hljs-number">789</span><span class="hljs-attribute">stats</span>:<span class="hljs-number">3000</span><span class="hljs-number">2138</span><span class="hljs-number">1064</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>.<span class="hljs-number">050</span><span class="hljs-number">3</span>.<span class="hljs-number">94</span><span class="hljs-number">49</span>.<span class="hljs-number">766</span>[...]<span class="hljs-attribute">stats</span>:<span class="hljs-number">298000</span><span class="hljs-number">21785</span><span class="hljs-number">1067</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>.<span class="hljs-number">050</span><span class="hljs-number">4</span>.<span class="hljs-number">16</span><span class="hljs-number">4</span>.<span class="hljs-number">898</span><span class="hljs-attribute">stats</span>:<span class="hljs-number">299000</span><span class="hljs-number">21787</span><span class="hljs-number">1067</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>.<span class="hljs-number">089</span><span class="hljs-number">4</span>.<span class="hljs-number">16</span><span class="hljs-number">4</span>.<span class="hljs-number">897</span><span class="hljs-attribute">stats</span>:<span class="hljs-number">300000</span><span class="hljs-number">21788</span><span class="hljs-number">1067</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>.<span class="hljs-number">061</span><span class="hljs-number">4</span>.<span class="hljs-number">17</span><span class="hljs-number">4</span>.<span class="hljs-number">897</span><span class="hljs-attribute">stats</span>:<span class="hljs-number">301000</span><span class="hljs-number">23925</span><span class="hljs-number">1068</span><span class="hljs-number">4</span><span class="hljs-number">64</span><span class="hljs-number">6</span>.<span class="hljs-number">882</span><span class="hljs-number">3</span>.<span class="hljs-number">35</span><span class="hljs-number">4</span>.<span class="hljs-number">464</span> # GC after <span class="hljs-number">2</span>k+ events (without a proxy-related change)<span class="hljs-attribute">stats</span>:<span class="hljs-number">302000</span><span class="hljs-number">23926</span><span class="hljs-number">1068</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>.<span class="hljs-number">052</span><span class="hljs-number">3</span>.<span class="hljs-number">35</span><span class="hljs-number">4</span>.<span class="hljs-number">464</span>[...]<span class="hljs-attribute">stats</span>:<span class="hljs-number">1798000</span><span class="hljs-number">130941</span><span class="hljs-number">1218</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>.<span class="hljs-number">090</span><span class="hljs-number">4</span>.<span class="hljs-number">68</span><span class="hljs-number">0</span>.<span class="hljs-number">930</span><span class="hljs-attribute">stats</span>:<span class="hljs-number">1799000</span><span class="hljs-number">130942</span><span class="hljs-number">1218</span><span class="hljs-number">0</span><span class="hljs-number">0</span><span class="hljs-number">0</span>.<span class="hljs-number">055</span><span class="hljs-number">4</span>.<span class="hljs-number">69</span><span class="hljs-number">0</span>.<span class="hljs-number">930</span></code></pre><p><img src="/img/test-run.1k-svc.svg"><br>2）<code>aggregate</code>聚合多个组件的对子系统的操作，最终进行统一的提交。比如calico、Kube-Proxy、hostport cni等对iptables的操作，统一由<code>aggregate</code>进行操作的合并，避免相互之间的锁竞争。</p><h2 id="KPNG的设计"><a href="#KPNG的设计" class="headerlink" title="KPNG的设计"></a>KPNG的设计</h2><p>由于KPNG目前仍在开发中，最终的技术方案可能会有变动，暂时使用<a href="https://github.com/kubernetes-sigs/kpng/tree/2d38809c64cb70694731b37d150bf6c0268844ca">最新版本</a> 的实现来介绍。KPNG架构图如下。<br><img src="/img/kpng-arch-try-2.svg"><br>首先是上半Server部分，核心是存储了Services、Endpoints、Nodes信息的<code>proxystore.Store</code>，底层是一个B树，<code>proxystore.Store</code>的输入来源可以是其他kpng的gRPC API（api2store）、Kube-APIServer（kube2store）以及本地文件（file2store），对外提供访问的方式可以是gRPC server（store2api）、本地内存（store2localdiff）、本地文件（store2file）。代码实现都在<code>server/jobs/xxx2store</code>以及<code>server/jobs/store2xxx</code>下。</p><p>下半Client部分，获取数据并交于backend进行处理，backend可以是简单的日志打印，或是实现iptables、ipvs、ebpf规则等。获取数据方式目前有两种，一种是gRPC，对应上半部分的<code>store2api</code>；另一种是内存获取，对应<code>store2localdiff</code>。两者都会调用<code>localsink.Sink</code>的<code>func Send(op *OpItem) error</code>，将相应的变更操作传递给后面的逻辑进行处理。</p><h2 id="KPNG使用"><a href="#KPNG使用" class="headerlink" title="KPNG使用"></a>KPNG使用</h2><p>官方博客里的<a href="https://kubernetes.io/blog/2021/10/18/use-kpng-to-write-specialized-kube-proxiers/">例子</a> 是通过gRPC的方式实现资源变更的打印，backend的实现在代码库的examples/pipe-exec/cmd/kpng-json/main.go中。</p><p>除此外，这里给出iptables模式的KPNG部署。首先在代码库的根目录下生成镜像。</p><pre><code class="hljs css"><span class="hljs-selector-tag">docker</span> <span class="hljs-selector-tag">build</span> <span class="hljs-selector-tag">-t</span> <span class="hljs-selector-tag">kpng</span><span class="hljs-selector-pseudo">:latest</span> .</code></pre><p>创建如下的daemonset：</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kpng-proxy</span>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">kpng-proxy</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">kpng-proxy</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-comment"># 偷懒，直接使用Kube-Proxy的sa</span>      <span class="hljs-attr">serviceAccount:</span> <span class="hljs-string">kube-proxy</span>      <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">priorityClassName:</span> <span class="hljs-string">system-node-critical</span>      <span class="hljs-attr">nodeSelector:</span>        <span class="hljs-attr">kubernetes.io/os:</span> <span class="hljs-string">linux</span>      <span class="hljs-attr">containers:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kpng</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">kpng:latest</span>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span>        <span class="hljs-attr">command:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">kpng</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">kube</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">--service-proxy-name=kpng-example</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">to-local</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">to-iptables</span>        <span class="hljs-attr">securityContext:</span>          <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span></code></pre><p>接着创建带有<code>service.kubernetes.io/service-proxy-name: kpng-example</code>标签的service，就能看到在iptables里生成对应的规则了。（如果不确定是Kube-Proxy生成的iptables规则还是kpng，可以在测试前，先把Kube-Proxy切换为ipvs模式或删除）。<br>上面例子中，<code>kube</code>子命令指定了通过<code>kube2store</code>监听kube-apiserver来获取<code>proxystore.Store</code>，<code>to-local</code>子命令指定了通过<code>store2localdiff</code>将<code>proxystore.Store</code>变更增量发送到后端，<code>to-iptables</code>子命令指定使用后端<code>iptables</code>。</p><h2 id="KPNG代码粗读"><a href="#KPNG代码粗读" class="headerlink" title="KPNG代码粗读"></a>KPNG代码粗读</h2><p>首先，kpng代码里实现了很多种名叫<code>store</code>、<code>sink</code>、<code>job</code>的类。总的来说：</p><ul><li><code>job</code>实现数据的处理与传递。比如<code>server/jobs/kube2store/kube2store.go</code>中的<code>Job</code>实现数据从Kube-APIServer（通过List-Watch）到<code>proxystore.Store</code>的传递；<code>server/jobs/store2diff/store2diff.go</code>中的<code>Job</code>实现数据从<code>proxystore.Store</code>到<code>store2diff.Sink</code>的传递。</li><li><code>store</code>用于存储数据，一般底层都是B树，主要的包括存储Services、Endpoints、Nodes信息的<code>proxystore.Store</code>，能提供数据变化跟踪的<code>lightdiffstore.DiffStore</code>与<code>diffstore.Store</code>。</li><li><code>sink</code>提供一些接口，用于接受<code>job</code>数据的传递，一般定义为<code>interface</code>。比如上面提到的<code>client/localsink/localsink.go</code>中的<code>localsink.Sink</code>。<code>sink</code>的实现也可能会是另一个<code>job</code>。</li></ul><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>主要的代码包括：</p><ul><li><code>api/</code>：grpc api的定义，Services、Endpoints、Nodes资源信息的api定义。</li><li><code>backends/</code>：后端实现，都实现了<code>client/backendcmd</code>中的<code>Cmd interface</code>，使用<code>client/backendcmd</code>中的<code>Register()</code>注册，然后就能通过子命令调用对应的后端。<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;backendcmd.Register(<span class="hljs-string">&quot;to-iptables&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">backendcmd</span>.<span class="hljs-title">Cmd</span></span> &#123; <span class="hljs-keyword">return</span> &amp;Backend&#123;&#125; &#125;)&#125;</code></pre></li><li><code>client/</code>：内容比较杂，包含了client用到的<code>store</code>、<code>sink</code>等结构。</li><li><code>cmd/kpng/</code>：main程序代码</li><li><code>from-k8s/</code>：从kubernetes代码库中移植过来的代码</li><li><code>server/</code>：<ul><li><code>server/jobs</code>：包含了server端<code>xxx2store</code>与<code>store2xxx</code>的各种job</li><li><code>server/proxystore</code>：定义了基本的存储结构<code>proxystore.Store</code></li></ul></li></ul><p>接下来分别以<code>gRPC server + examples/print-state</code>的用例和<code>local server + iptables backend</code>的用例介绍代码流程，两个用例能覆盖大多数核心代码，对KPNG有个大体的了解。</p><h3 id="gPRC-Server"><a href="#gPRC-Server" class="headerlink" title="gPRC Server"></a>gPRC Server</h3><p>当执行<code>kpng kube to-api</code>时，kpng会监听Kube-APIServer，并启动gRPC server。</p><h4 id="kube子命令"><a href="#kube子命令" class="headerlink" title="kube子命令"></a>kube子命令</h4><p><code>kube</code>子命令的定义：</p><pre><code class="hljs go"><span class="hljs-comment">// cmd/kpng/k2s.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kube2storeCmd</span><span class="hljs-params">()</span> *<span class="hljs-title">cobra</span>.<span class="hljs-title">Command</span></span> &#123;<span class="hljs-comment">// kube to * command</span>k2sCmd := &amp;cobra.Command&#123;Use:   <span class="hljs-string">&quot;kube&quot;</span>,Short: <span class="hljs-string">&quot;watch Kubernetes API to the globalv1 state&quot;</span>,&#125;...<span class="hljs-comment">// setupKube2store定义了从kube-apiserver到store的逻辑</span><span class="hljs-comment">// storecmds.Commands为kube子命令添加store到local\gRPC\file的逻辑</span>k2sCmd.AddCommand(storecmds.Commands(setupKube2store)...)<span class="hljs-keyword">return</span> k2sCmd&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupKube2store</span><span class="hljs-params">()</span> <span class="hljs-params">(ctx context.Context, store *proxystore.Store, err error)</span></span> &#123;...<span class="hljs-comment">// 创建新的proxystore.store</span>store = proxystore.New()<span class="hljs-comment">// kube2stroe job是Kube-APIServer到store主要逻辑的实现</span><span class="hljs-keyword">go</span> kube2store.Job&#123;Kube:   kubeClient,Store:  store,Config: k2sCfg,&#125;.Run(ctx)<span class="hljs-keyword">return</span>&#125;</code></pre><p><code>kube2store.Job</code>的实现在<code>server/jobs/kube2store</code>下，<code>server/jobs</code>下也包含其他与store相关的job，大同小异。</p><pre><code class="hljs go"><span class="hljs-comment">// server/jobs/kube2store/kube2store.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j Job)</span> <span class="hljs-title">Run</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;...<span class="hljs-comment">// service的informer factory，list时只选择label service.kubernetes.io/service-proxy-name的值与kpng ServiceProxyName相同的service</span><span class="hljs-comment">// 由于informer factory的ListOptions是对所有资源都进行过滤的，因此后面还创建了一个coreFactory</span>svcFactory := informers.NewSharedInformerFactoryWithOptions(j.Kube, time.Second*<span class="hljs-number">30</span>,informers.WithTweakListOptions(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options *metav1.ListOptions)</span></span> &#123; options.LabelSelector = labelSelector &#125;))...<span class="hljs-comment">// start watches</span>coreFactory := factory.Core().V1()...<span class="hljs-comment">//启动service、nodes、endpointSlices的List-watch</span>servicesInformer.AddEventHandler(&amp;serviceEventHandler&#123;j.eventHandler(servicesInformer)&#125;)<span class="hljs-keyword">go</span> servicesInformer.Run(stopCh)nodesInformer := coreFactory.Nodes().Informer()nodesInformer.AddEventHandler(&amp;nodeEventHandler&#123;j.eventHandler(nodesInformer)&#125;)<span class="hljs-keyword">go</span> nodesInformer.Run(stopCh)slicesInformer := factory.Discovery().V1().EndpointSlices().Informer()slicesInformer.AddEventHandler(&amp;sliceEventHandler&#123;j.eventHandler(slicesInformer)&#125;)<span class="hljs-keyword">go</span> slicesInformer.Run(stopCh)...&#125;</code></pre><p>上面的各个eventHandler最终根据List-watch的事件，更新store，以add service event为例。</p><pre><code class="hljs go"><span class="hljs-comment">// server/jobs/kube2store/service-event-handler.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *serviceEventHandler)</span> <span class="hljs-title">OnAdd</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;h.onChange(obj)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *serviceEventHandler)</span> <span class="hljs-title">onChange</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;...<span class="hljs-comment">// 把corev1.service转换为kpng api中定义的localv1.Service，用于保存在store中</span>service := &amp;localv1.Service&#123;Namespace:   svc.Namespace,Name:        svc.Name,Type:        <span class="hljs-keyword">string</span>(svc.Spec.Type),Labels:      globsFilter(svc.Labels, h.config.ServiceLabelGlobs),Annotations: globsFilter(svc.Annotations, h.config.ServiceAnnonationGlobs),IPs: &amp;localv1.ServiceIPs&#123;ClusterIPs:  &amp;localv1.IPSet&#123;&#125;,ExternalIPs: localv1.NewIPSet(svc.Spec.ExternalIPs...),&#125;,ExternalTrafficToLocal: svc.Spec.ExternalTrafficPolicy == v1.ServiceExternalTrafficPolicyTypeLocal,InternalTrafficToLocal: internalTrafficPolicy == v1.ServiceInternalTrafficPolicyLocal,&#125;...<span class="hljs-comment">// 存储到store中，proxystore.Tx是在proxystore.Store上封装了一层，前者能把service、nodes、endpoint转成kv，存储到proxystore.Store中</span><span class="hljs-comment">// Update()传入闭包，操作proxystore.Tx</span>h.s.Update(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *proxystore.Tx)</span></span> &#123;...tx.SetService(service)&#125;)&#125;</code></pre><p>到此，<code>kube</code>子命令的功能就结束了。</p><h4 id="to-api子命令"><a href="#to-api子命令" class="headerlink" title="to-api子命令"></a>to-api子命令</h4><p>上面有提到，为kube子命令添加store到local、gRPC、file的逻辑，都是在<code>storecmds.Commands</code>中实现的。</p><pre><code class="hljs go"><span class="hljs-comment">// cmd/kpng/storecmds/storecmds.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c SetupFunc)</span> <span class="hljs-title">ToAPICmd</span><span class="hljs-params">()</span> *<span class="hljs-title">cobra</span>.<span class="hljs-title">Command</span></span> &#123;cmd := &amp;cobra.Command&#123;Use: <span class="hljs-string">&quot;to-api&quot;</span>,&#125;...cmd.RunE = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ *cobra.Command, _ []<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(err error)</span></span> &#123;...<span class="hljs-comment">// 从xxx2store对应的SetupFunc中获取store</span>ctx, store, err := c()<span class="hljs-comment">// store2api.Job实现将proxystore.Store暴露给gRPC server上</span>j := &amp;store2api.Job&#123;Store:  store,Config: cfg,&#125;<span class="hljs-keyword">return</span> j.Run(ctx)&#125;...&#125;<span class="hljs-comment">// server/jobs/store2api/store2api.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j *Job)</span> <span class="hljs-title">Run</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-title">error</span></span> &#123;lis := server.MustListen(j.Config.BindSpec)<span class="hljs-comment">// 创建gRPC服务</span>...srv = grpc.NewServer()<span class="hljs-comment">// 启动global API与endpoint API的server</span><span class="hljs-keyword">if</span> j.Config.GlobalAPI &#123;global.Setup(srv, j.Store)&#125;<span class="hljs-keyword">if</span> j.Config.LocalAPI &#123;endpoints.Setup(srv, j.Store)&#125;<span class="hljs-keyword">return</span> srv.Serve(lis)&#125;</code></pre><p>以<code>endpoints.Setup()</code>为例，注册的gRPC server设置如下：</p><pre><code class="hljs go"><span class="hljs-comment">// api/localv1/api_grpc.pb.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterSetsServer</span><span class="hljs-params">(s grpc.ServiceRegistrar, srv SetsServer)</span></span> &#123;<span class="hljs-comment">// 当客户端请求gRPC server时，会使用srv调用_Sets_Watch_Handler()方法</span>s.RegisterService(&amp;Sets_ServiceDesc, srv)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">Sets_Watch_Handler</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, stream grpc.ServerStream)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-comment">// 调用SetsServer的Watch方法，传入setsWatchServer，用于信息的接受与发送</span><span class="hljs-keyword">return</span> srv.(SetsServer).Watch(&amp;setsWatchServer&#123;stream&#125;)&#125;<span class="hljs-comment">// setsWatchServer将grpc.ServerStream封装为Send()与Recv()方法</span><span class="hljs-keyword">type</span> setsWatchServer <span class="hljs-keyword">struct</span> &#123;grpc.ServerStream&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *setsWatchServer)</span> <span class="hljs-title">Send</span><span class="hljs-params">(m *OpItem)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> x.ServerStream.SendMsg(m)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *setsWatchServer)</span> <span class="hljs-title">Recv</span><span class="hljs-params">()</span> <span class="hljs-params">(*WatchReq, error)</span></span> &#123;<span class="hljs-keyword">if</span> err := x.ServerStream.RecvMsg(m); err != <span class="hljs-literal">nil</span> &#123;...&#125;...&#125;<span class="hljs-keyword">var</span> Sets_ServiceDesc = grpc.ServiceDesc&#123;...Streams: []grpc.StreamDesc&#123;&#123;...Handler:       _Sets_Watch_Handler,&#125;,&#125;,&#125;</code></pre><p>可以看出gRPC Server接收的是<code>WatchReq</code>，而发送的<code>OpItem</code>，<code>OpItem</code>有点像List-watch的event，但只包括set、delete、reset、sync四种，set、delete用来告诉客户端资源有哪些增量的变化，sync表示最新的增量已传输完毕，告诉客户端可以进行backend规则的同步了，reset一般用在gRPC重连的情况。<br><code>SetsServer</code>是个interface，实现是在<code>server/pkg/server/endpoints/server.go</code>里的<code>Server</code>。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span> <span class="hljs-title">Watch</span><span class="hljs-params">(res localv1.Sets_WatchServer)</span> <span class="hljs-title">error</span></span> &#123;...<span class="hljs-comment">// store2localdiff会根据Store计算资源的变化，通过Sink的Send方法将增量发送</span>job := &amp;store2localdiff.Job&#123;Store: s.Store,<span class="hljs-comment">// serverSink继承了localv1.Sets_WatchServer的Send方法，也就是上面setsWatchServer的Send方法，因此最终通过gRPC发到Client端</span>Sink:  serverSink&#123;res, remote&#125;,&#125;...<span class="hljs-keyword">return</span> job.Run(res.Context())&#125;</code></pre><h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p><code>store2localdiff.Job.Run()</code>内部调用了<code>store2diff.Job.Run()</code>，这块是实现资源变更的增量发送逻辑，即每次只将资源变更的增量通过<code>localsink.Sink.Send()</code>发送，不发送资源的全部信息。</p><p>diff这块代码较多，简言之就是：</p><ul><li>资源变更的追踪是依靠<code>client/lightdiffstore</code>中的<code>DiffStore</code>完成的，其本质是一个B树，在value中记录了此value在上一次Reset之后的状态（changed or unchanged）。而<code>server/pkg/server/watchstate</code>中的<code>WatchState</code>在<code>DiffStore</code>上封装一层，可以将<code>DiffStore</code> diff的结果通过<code>localv1.OpSink.Send()</code>发送出去。</li><li><code>store2diff.Job.Run()</code>会先创建<code>WatchState</code>。然后，在每一轮循环中，先通过<code>store2diff.Sink.Update()</code>从<code>proxystore.Store</code>中更新<code>WatchState</code>；再通过<code>store2diff.Sink.SendDiff()</code>发送diff的结果；当diff结果发送完成后，在发送sync的OpItem，表示发送结束，可以同步。<pre><code class="hljs go"><span class="hljs-comment">// server/jobs/store2diff/store2diff.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(j *Job)</span> <span class="hljs-title">Run</span><span class="hljs-params">(ctx context.Context)</span> <span class="hljs-params">(err error)</span></span> &#123;<span class="hljs-comment">// 创建watchstate</span>w := watchstate.New(j.Sink, j.Sets)...<span class="hljs-keyword">for</span> &#123;...<span class="hljs-keyword">for</span> !updated &#123;<span class="hljs-comment">// block until the revision has been</span><span class="hljs-comment">// incremented... then, we update our state from the</span><span class="hljs-comment">// proxystore</span>rev, closed = j.Store.View(rev, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *proxystore.Tx)</span></span> &#123;j.Sink.Update(tx, w)&#125;)...<span class="hljs-comment">// send the diff</span>updated = j.Sink.SendDiff(w)&#125;<span class="hljs-comment">// signal the change set is fully sent</span>w.SendSync()<span class="hljs-keyword">if</span> w.Err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> w.Err&#125;&#125;</code></pre></li><li><code>store2localdiff.Job</code>实现了<code>store2diff.Sink</code>接口，其中在<code>SendDiff()</code>中，发送完diff结果后，会调用<code>WatchState</code>的<code>Reset()</code>进行资源状态的重置。</li></ul><p>到此为止，整个gRPC Server的流程就结束了。</p><h3 id="gRPC-Client"><a href="#gRPC-Client" class="headerlink" title="gRPC Client"></a>gRPC Client</h3><p>在kpng中，要实现一个自定义的gRPC Client逻辑只要调用<code>client.Run(func)</code>，将实现<code>func</code>传入即可。以<code>examples/print-state</code>为例，其实现了接收内容的打印。</p><pre><code class="hljs go"><span class="hljs-comment">// examples/print-state/main.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;client.Run(printState)&#125;<span class="hljs-comment">// ServiceEndpoints结构记录了一个Service与它对应的本节点的Endpoint</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printState</span><span class="hljs-params">(items []*client.ServiceEndpoints)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;# ------------------------------------------------------------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;#&quot;</span>, time.Now())fmt.Println(<span class="hljs-string">&quot;#&quot;</span>)<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;fmt.Fprintln(os.Stdout, item)&#125;&#125;</code></pre><p><code>client.Run</code>使用了<code>fullstate.Sink</code>，<code>fullstate.Sink</code>内部有个B树结构，存储gRPC客户端接受到的数据，然后每次在收到Server端发送的sync信号后，将全量的数据发给回调函数，也就是传入<code>client.Run()</code>的自定义逻辑。<br><img src="/img/kpng-fullstate-syncer.png"></p><p>到此为止，整个gRPC Server + gRPC Client的模式就结束了。</p><h3 id="local-Server"><a href="#local-Server" class="headerlink" title="local Server"></a>local Server</h3><p>除了上面的gRPC的方式外，还有就是上面iptable用例中，<code>kpng kube to-local to-iptables</code>命令通过内存的方式传递数据。Server和Client会编译到一个二进制文件中。</p><h4 id="to-local"><a href="#to-local" class="headerlink" title="to-local"></a>to-local</h4><p><code>to-local</code>接kube子命令，将<code>proxystore.Store</code>中的资源通过<code>store2localdiff.Job</code>处理后发送给下一个<code>localsink.Sink</code>的实现。</p><pre><code class="hljs go"><span class="hljs-comment">// cmd/kpng/storecmds/storecmds.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c SetupFunc)</span> <span class="hljs-title">ToLocalCmd</span><span class="hljs-params">()</span> <span class="hljs-params">(cmd *cobra.Command)</span></span> &#123;cmd = &amp;cobra.Command&#123;Use: <span class="hljs-string">&quot;to-local&quot;</span>,&#125;job := &amp;store2localdiff.Job&#123;&#125;...cmd.AddCommand(LocalCmds(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sink localsink.Sink)</span> <span class="hljs-title">error</span></span> &#123;job.Sink = sink<span class="hljs-keyword">return</span> job.Run(ctx)&#125;)...)<span class="hljs-keyword">return</span>&#125;</code></pre><h3 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h3><p>上面有介绍，backend都是通过<code>backendcmd.Register</code>方法注册，然后在<code>LocalCmds()</code>创建相应的命令。</p><pre><code class="hljs go"><span class="hljs-comment">// cmd/kpng/storecmds/storecmds.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LocalCmds</span><span class="hljs-params">(run <span class="hljs-keyword">func</span>(sink localsink.Sink)</span> <span class="hljs-title">error</span>) <span class="hljs-params">(cmds []*cobra.Command)</span></span> &#123;<span class="hljs-comment">// 获取所有注册的backend</span><span class="hljs-keyword">for</span> _, useCmd := <span class="hljs-keyword">range</span> backendcmd.Registered() &#123;backend := useCmd.New()cmd := &amp;cobra.Command&#123;Use: useCmd.Use,RunE: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ *cobra.Command, _ []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-comment">// 获取backend的Sink，用于在to-local子命令创建的store2localdiff.Job中获取diff结果</span><span class="hljs-keyword">return</span> run(backend.Sink())&#125;,&#125;...&#125;&#125;</code></pre><p>以iptable为例，<code>Sink()</code>方法如下：</p><pre><code class="hljs go"><span class="hljs-comment">// backends/iptables/sink.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Backend)</span> <span class="hljs-title">Sink</span><span class="hljs-params">()</span> <span class="hljs-title">localsink</span>.<span class="hljs-title">Sink</span></span> &#123;<span class="hljs-keyword">return</span> filterreset.New(pipe.New(decoder.New(s), decoder.New(conntrack.NewSink())))&#125;</code></pre><p>Server端发送的diff结果，流向如下：</p><pre><code class="hljs xl">                                    | --&gt; <span class="hljs-function"><span class="hljs-title">decoder</span>.sink --&gt;</span> iptables                                    |<span class="hljs-function"><span class="hljs-title">diff</span> --&gt;</span> <span class="hljs-function"><span class="hljs-title">filterreset</span>.sink --&gt;</span> <span class="hljs-function"><span class="hljs-title">pipe</span>.sink --&gt;</span> <span class="hljs-function"><span class="hljs-title">decoder</span>.sink --&gt;</span> conntrack</code></pre><p>可以看到kpng中真的是有各种各样的Sink：<code>pipe.Sink</code>将数据发送给多个目的地；<code>decoder.Sink</code>将raw数据转换成service、endpoint、node API；<code>filterreset.Sink</code>是相对于上面介绍的<code>fullstate.Sink</code>来说的，不会将全量数据往后发送，而是过滤掉之前发送过且无变化的资源，相当于是发送增量数据。</p><p><img src="/img/kpng-filterreset-syncer.png"></p><p>如上图所示，资源数据最后到达backend，由backend配置数据路径。kpng中的iptables、ipvs等实现主要是搬的Kube-Proxy代码，同时还在开发eBPF的数据路径。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>除了上面的介绍外，kpng项目中还有很多值得一看的亮点。比如kpng在<code>diffstore.Store</code>中用到了go 1.18新支持的范型；代码库中的<code>doc/service-proxy.md</code>是一篇非常值得一读的Kube-Proxy设计思想的文档。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kube-proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EDT限速: 原理与实现</title>
    <link href="/2022/09/30/EDT%E9%99%90%E9%80%9F-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/30/EDT%E9%99%90%E9%80%9F-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>Kubernetes中，可以通过设置Pod的Annotation <code>kubernetes.io/ingress-bandwidth</code>与<code>kubernetes.io/egress-bandwidth</code>对容器进行带宽限制，bandwidth CNI在容器veth pair的host端设置tc tbf（Token Bucket Filter，令牌桶过滤器）实现限速功能。<a href="https://cilium.io/blog/2020/11/10/cilium-19/#bwmanager">Cilium通过EDT</a>(Earliest Departure Time)替代令牌桶算法进行限速，在延迟与CPU使用率上都有更好表现。</p><a id="more"></a><h2 id="EDT原理"><a href="#EDT原理" class="headerlink" title="EDT原理"></a>EDT原理</h2><p>EDT通过确保数据包不早于某个时间点发送，来控制带宽，而这个时间点是通过上一个数据包的发送时间加上一个延迟来确定的。数据包延迟的计算公式如下所示。</p><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">delay_ns</span> = skb-&gt;</span><span class="hljs-function"><span class="hljs-title">len</span> * NS_PER_SEC / aggregate_state-&gt;</span>rate_limit_bps</code></pre><p>例如，对容器限速10Kbit/s，那容器发送1Kbit大小的包，需要在上一个包发送0.1s之后。似乎可以理解为另一种形式的令牌桶，只不过数据包发送的“成本”由令牌变成了时间片。</p><p>引用google分享的<a href="https://legacy.netdevconf.info/0x14/pub/papers/55/0x14-paper55-talk-paper.pdf">Replacing HTB with EDT and BPF</a> 中的描述，EDT限速流程如下图所示：数据包在进入MQ队列之前，被设置<code>skb-&gt;tstamp</code>；在FQ队列中，确保数据包不会早于<code>skb-&gt;tstamp</code>设置的时间被发出。<br><img src="/img/edt_1.jpg"></p><ul><li><p>MQ：引用相关Patch里的介绍如下。是个多队列的框架，使用hash函数将流量分配到下面的多个队列。</p><blockquote><p>The <code>mq</code> qdisc is a dummy qdisc which sets up an array of <code>pfifo_fast</code> queues as a Traffic Control <code>tc class</code> under the root <code>mq qdisc</code>. One <code>pfifo_fast</code> queue is created for each hardware queue.</p><p>Traffic is placed into each queue using a hash function. This should allow traffic to spread across the multiple queues.</p></blockquote></li><li><p>FQ：公平队列，在被修改为<a href="https://lore.kernel.org/netdev/20180921155154.49489-1-edumazet@google.com/">EDT mode</a> 后，能确保队列中的数据包不会早于<code>skb-&gt;tstamp</code>设置的时间被发出。引用<a href="https://legacy.netdevconf.info/0x12/session.html?evolving-from-afap-teaching-nics-about-time">Evolving from AFAP: Teaching NICs about time</a> 分享里的一个图，其核心结构是一个timestamp的优先循环队列。<br><img src="/img/edt_3.jpg"></p></li></ul><h2 id="Cilium中的实现"><a href="#Cilium中的实现" class="headerlink" title="Cilium中的实现"></a>Cilium中的实现</h2><p>Cilium使用EDT实现了<a href="https://github.com/cilium/cilium/commit/29f46540359d175690e9e9974eeeff970b0f38e0">Bandwidth Manager</a> ，具体实现如下：</p><p>Cilium Daemon启动时需要判断内核是否能支持EDT</p><pre><code class="hljs go">pkg/bandwidth/bandwidth.<span class="hljs-keyword">go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ProbeBandwidthManager</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> h := probes.NewProbeManager().GetHelpers(<span class="hljs-string">&quot;sched_cls&quot;</span>) ...<span class="hljs-keyword">if</span> _, err := sysctl.Read(<span class="hljs-string">&quot;net.core.default_qdisc&quot;</span>) ...&#125;</code></pre><p>接着配置系统参数，修改主机网卡队列类型</p><pre><code class="hljs go">pkg/bandwidth/bandwidth.<span class="hljs-keyword">go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitBandwidthManager</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">// 先设置一些系统参数，包括将默认的队列设置为`fq`，将拥塞算法设置为BBR。</span>...congctl := <span class="hljs-string">&quot;cubic&quot;</span><span class="hljs-keyword">if</span> option.Config.EnableBBR &#123;congctl = <span class="hljs-string">&quot;bbr&quot;</span>&#125;...baseSettings := []setting&#123;&#123;<span class="hljs-string">&quot;net.core.netdev_max_backlog&quot;</span>, <span class="hljs-string">&quot;1000&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;net.core.somaxconn&quot;</span>, <span class="hljs-string">&quot;4096&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;net.core.default_qdisc&quot;</span>, <span class="hljs-string">&quot;fq&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;net.ipv4.tcp_max_syn_backlog&quot;</span>, <span class="hljs-string">&quot;4096&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;net.ipv4.tcp_congestion_control&quot;</span>, congctl&#125;,&#125;...<span class="hljs-comment">// 再为cilium使用的宿主机网卡设备添加mq qdisc,子队列会自动创建FQ；如果不支持mq,则直接创建FQ</span><span class="hljs-keyword">for</span> _, device := <span class="hljs-keyword">range</span> option.Config.GetDevices() &#123;...qdisc = &amp;netlink.GenericQdisc&#123;QdiscAttrs: netlink.QdiscAttrs&#123;LinkIndex: link.Attrs().Index,Parent:    netlink.HANDLE_ROOT,&#125;,QdiscType: <span class="hljs-string">&quot;mq&quot;</span>,&#125;which := <span class="hljs-string">&quot;mq with fq leafs&quot;</span><span class="hljs-keyword">if</span> err := netlink.QdiscReplace(qdisc); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// No MQ support, so just replace to FQ directly.</span>fq := &amp;netlink.Fq&#123;QdiscAttrs: netlink.QdiscAttrs&#123;LinkIndex: link.Attrs().Index,Parent:    netlink.HANDLE_ROOT,&#125;,Pacing: <span class="hljs-number">1</span>,&#125;...which = <span class="hljs-string">&quot;fq&quot;</span>&#125;log.WithField(<span class="hljs-string">&quot;device&quot;</span>, device).Infof(<span class="hljs-string">&quot;Setting qdisc to %s&quot;</span>, which)&#125;&#125;</code></pre><p>数据包经过容器tc bpf程序，设置聚合</p><pre><code class="hljs c">bpf/bpf_lxc.c<span class="hljs-comment">// 加载在每个容器的veth pair的tc层，设置aggregate。对mq来说，能将容器所有的包都聚合到一个fq子队列，防止数据包的乱序发送</span>__section(<span class="hljs-string">&quot;from-container&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">handle_xgress</span><span class="hljs-params">(struct __ctx_buff *ctx)</span></span><span class="hljs-function"></span>&#123;...edt_set_aggregate(ctx, LXC_ID);...&#125;</code></pre><p>数据包到宿主机网卡准备发出时，经宿主机的bpf程序重新设置发送时间tstamp，接下来就由内核的fq队列进行发送。</p><pre><code class="hljs c">bpf/bpf_host.c__section(<span class="hljs-string">&quot;to-netdev&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">to_netdev</span><span class="hljs-params">(struct __ctx_buff *ctx __maybe_unused)</span></span><span class="hljs-function"></span>&#123;...<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(ENABLE_BANDWIDTH_MANAGER)</span>ret = edt_sched_departure(ctx);<span class="hljs-comment">/* No send_drop_notify_error() here given we&#x27;re rate-limiting. */</span><span class="hljs-keyword">if</span> (ret == CTX_ACT_DROP) &#123;update_metrics(ctx_full_len(ctx), METRIC_EGRESS,       -DROP_EDT_HORIZON);<span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>...&#125;bpf/lib/edt.h<span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">int</span> <span class="hljs-title">edt_sched_departure</span><span class="hljs-params">(struct __ctx_buff *ctx)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-comment">// aggregate记录在ctx-&gt;queue_mapping</span>aggregate.id = edt_get_aggregate(ctx);<span class="hljs-keyword">if</span> (!aggregate.id)<span class="hljs-keyword">return</span> CTX_ACT_OK;info = map_lookup_elem(&amp;THROTTLE_MAP, &amp;aggregate);now = ktime_get_ns();t = ctx-&gt;tstamp;<span class="hljs-keyword">if</span> (t &lt; now)t = now;    <span class="hljs-comment">// 计算当前数据包的延迟（发送成本）</span>delay = ((__u64)ctx_wire_len(ctx)) * NSEC_PER_SEC / info-&gt;bps;<span class="hljs-comment">// info-&gt;t_last 记录了上一个数据包的最早发送时间，t_next是当前数据包的最早发送时间</span>t_next = READ_ONCE(info-&gt;t_last) + delay;<span class="hljs-keyword">if</span> (t_next &lt;= t) &#123;<span class="hljs-comment">// 数据包的最早发送时间早于当前，可以直接发送</span>WRITE_ONCE(info-&gt;t_last, t);<span class="hljs-keyword">return</span> CTX_ACT_OK;&#125;<span class="hljs-comment">// 防止发送时间较远的数据包长时间填充fq，see also 39d010504e6b (&quot;net_sched:* sch_fq: add horizon attribute&quot;)</span><span class="hljs-keyword">if</span> (t_next - now &gt;= info-&gt;t_horizon_drop)<span class="hljs-keyword">return</span> CTX_ACT_DROP;WRITE_ONCE(info-&gt;t_last, t_next);<span class="hljs-comment">// 设置最早发送时间</span>ctx-&gt;tstamp = t_next;<span class="hljs-keyword">return</span> CTX_ACT_OK;&#125;</code></pre><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>代码<code>edt.c</code>：</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bpf/bpf_helpers.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/if_ether.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/pkt_cls.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/swab.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/ip.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_elf_map</span></span><span class="hljs-class">&#123;</span>        __u32 type;        __u32 size_key;        __u32 size_value;        __u32 max_elem;        __u32 flags;        __u32 id;        __u32 pinning;        __u32 inner_id;        __u32 inner_idx;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NS_PER_SEC 1000000000ULL</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PIN_GLOBAL_NS 2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __section(NAME) \</span>        __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __READ_ONCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __READ_ONCE(X) (*(volatile typeof(X) *)&amp;X)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __WRITE_ONCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __WRITE_ONCE(X, V) (*(volatile typeof(X) *)&amp;X) = (V)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">/* &#123;READ,WRITE&#125;_ONCE() with verifier workaround via bpf_barrier(). */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> READ_ONCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ_ONCE(X) \</span>        (&#123; typeof(X) __val = __READ_ONCE(X);\   bpf_barrier();\   __val; &#125;)<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> WRITE_ONCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE_ONCE(X, V) \</span>        (&#123; typeof(X) __val = (V);\   __WRITE_ONCE(X, __val);\   bpf_barrier();\   __val; &#125;)<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> barrier</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> barrier() asm volatile(<span class="hljs-meta-string">&quot;&quot;</span> \</span>                               :  \                               :  \                               : <span class="hljs-string">&quot;memory&quot;</span>)<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">void</span> <span class="hljs-title">bpf_barrier</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-comment">/* Workaround to avoid verifier complaint:</span><span class="hljs-comment">         * &quot;dereference of modified ctx ptr R5 off=48+0, ctx+const is allowed,</span><span class="hljs-comment">         *        ctx+const+const is not&quot;</span><span class="hljs-comment">         */</span>        barrier();&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_elf_map</span> __<span class="hljs-title">section</span>(&quot;<span class="hljs-title">maps</span>&quot;) <span class="hljs-title">rate_map</span> = &#123;</span>    .type = BPF_MAP_TYPE_HASH,    .size_key = <span class="hljs-keyword">sizeof</span>(__u32),    .size_value = <span class="hljs-keyword">sizeof</span>(__u64),    .pinning = PIN_GLOBAL_NS,    .max_elem = <span class="hljs-number">16</span>,&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_elf_map</span> __<span class="hljs-title">section</span>(&quot;<span class="hljs-title">maps</span>&quot;) <span class="hljs-title">tstamp_map</span> = &#123;</span>    .type = BPF_MAP_TYPE_HASH,    .size_key = <span class="hljs-keyword">sizeof</span>(__u32),    .size_value = <span class="hljs-keyword">sizeof</span>(__u64),    .max_elem = <span class="hljs-number">16</span>,&#125;;__section(<span class="hljs-string">&quot;tc/edt&quot;</span>) <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">edt</span><span class="hljs-params">(struct __sk_buff *skb)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">void</span> *data_end = (<span class="hljs-keyword">void</span> *)(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)skb-&gt;data_end;        __u64 *rate, *tstamp, delay_ns, now, t, t_next;        <span class="hljs-keyword">void</span> *data = (<span class="hljs-keyword">void</span> *)(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)skb-&gt;data;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">ip</span> = <span class="hljs-title">data</span> + <span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">ethhdr</span>);</span>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethhdr</span> *<span class="hljs-title">eth</span> = <span class="hljs-title">data</span>;</span>        <span class="hljs-keyword">if</span> (data + <span class="hljs-keyword">sizeof</span>(struct ethhdr) &gt; data_end)                <span class="hljs-keyword">return</span> TC_ACT_OK;        <span class="hljs-keyword">if</span> (eth-&gt;h_proto != ___constant_swab16(ETH_P_IP) &amp;&amp;            eth-&gt;h_proto != ___constant_swab16(ETH_P_IPV6))                <span class="hljs-keyword">return</span> TC_ACT_OK;        <span class="hljs-keyword">if</span> (data + <span class="hljs-keyword">sizeof</span>(struct ethhdr) + <span class="hljs-keyword">sizeof</span>(struct iphdr) &gt; data_end)                <span class="hljs-keyword">return</span> TC_ACT_OK;        rate = bpf_map_lookup_elem(&amp;rate_map, &amp;ip-&gt;daddr);        <span class="hljs-keyword">if</span> (!rate)        &#123;                <span class="hljs-keyword">return</span> TC_ACT_OK;        &#125;        now = bpf_ktime_get_ns();        t = skb-&gt;tstamp;        <span class="hljs-keyword">if</span> (t &lt; now)                t = now;        delay_ns = skb-&gt;len * NS_PER_SEC / (*rate);        tstamp = bpf_map_lookup_elem(&amp;tstamp_map, &amp;ip-&gt;daddr);        <span class="hljs-keyword">if</span> (!tstamp)        &#123;                bpf_map_update_elem(&amp;tstamp_map, &amp;ip-&gt;daddr, &amp;t, BPF_ANY);                <span class="hljs-keyword">return</span> TC_ACT_OK;        &#125;        t_next = READ_ONCE(*tstamp) + delay_ns;        <span class="hljs-keyword">if</span> (t_next &lt;= t)        &#123;                WRITE_ONCE(*tstamp, t);                <span class="hljs-keyword">return</span> TC_ACT_OK;        &#125;        WRITE_ONCE(*tstamp, t_next);        skb-&gt;tstamp = t_next;        <span class="hljs-keyword">return</span> TC_ACT_OK;&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre><p>在ubuntu上测试，<code>eno1</code>为主机网卡。执行如下命令：</p><pre><code class="hljs shell">// 创建qdisc，由于我的网卡不支持多队列，跳过mq，直接创建fq<span class="hljs-meta">$</span><span class="bash"> tc qdisc add dev eno1 root handle 1: fq</span>// 编译bpf，加载到egress<span class="hljs-meta">$</span><span class="bash"> clang -O2 -Wall -target bpf -c  edt.c -o  edt.o</span><span class="hljs-meta">$</span><span class="bash"> tc qdisc add dev eno1 clsact</span><span class="hljs-meta">$</span><span class="bash"> tc filter add dev eno1 egress bpf direct-action obj edt.o sec tc/edt</span><span class="hljs-meta">$</span><span class="bash"> bpftool net show</span>// 更新rate_map，限制目的地为192.168.2.1(c0a80201)的流量最大为10Mbits/s（value需要转换为byte，即1250000）<span class="hljs-meta">$</span><span class="bash"> bpftool map update pinned /sys/fs/bpf/tc/globals/rate_map key 0xC0 0xA8 0x02 0x01 value 0xd0 0x12 0x13 0 0 0 0 0</span>// iperf测试<span class="hljs-meta">$</span><span class="bash"> iperf3 -c 192.168.2.1</span>Connecting to host 192.168.2.1, port 5201[  5] local 192.168.2.2 port 28180 connected to 192.168.2.1 port 5201[ ID] Interval           Transfer     Bitrate         Retr  Cwnd[  5]   0.00-1.00   sec  1.38 MBytes  11.6 Mbits/sec    0   33.9 KBytes[  5]   1.00-2.00   sec  1.12 MBytes  9.38 Mbits/sec    0   33.9 KBytes[  5]   2.00-3.00   sec  1.24 MBytes  10.4 Mbits/sec    0   33.9 KBytes[  5]   3.00-4.00   sec  1.12 MBytes  9.38 Mbits/sec    0   33.9 KBytes// 限制20Mbits/s<span class="hljs-meta">$</span><span class="bash"> bpftool map update pinned /sys/fs/bpf/tc/globals/rate_map key 0xC0 0xA8 0x02 0x01 value 0xA0 0x25 0x26 0 0 0 0 0</span><span class="hljs-meta">$</span><span class="bash"> iperf3 -c 192.168.2.1</span>Connecting to host 192.168.2.1, port 5201[  5] local 192.168.2.2 port 28184 connected to 192.168.2.1 port 5201[ ID] Interval           Transfer     Bitrate         Retr  Cwnd[  5]   0.00-1.00   sec  2.50 MBytes  21.0 Mbits/sec    0   33.9 KBytes[  5]   1.00-2.00   sec  2.36 MBytes  19.8 Mbits/sec    0   33.9 KBytes[  5]   2.00-3.00   sec  2.49 MBytes  20.9 Mbits/sec    0   42.4 KBytes</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/ByteDanceTech/article/details/120878281">https://blog.csdn.net/ByteDanceTech/article/details/120878281</a><br><a href="https://www.51cto.com/article/685201.html">https://www.51cto.com/article/685201.html</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BPF</tag>
      
      <tag>Cilium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义容器安全：在Kubernete中使用seccomp notify</title>
    <link href="/2022/08/22/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%EF%BC%9A%E5%9C%A8Kubernete%E4%B8%AD%E4%BD%BF%E7%94%A8seccomp-notify/"/>
    <url>/2022/08/22/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%EF%BC%9A%E5%9C%A8Kubernete%E4%B8%AD%E4%BD%BF%E7%94%A8seccomp-notify/</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何在Kubernetes中通过seccomp notify机制来自定义容器的安全机制。</p><a id="more"></a><h2 id="seccomp是什么"><a href="#seccomp是什么" class="headerlink" title="seccomp是什么"></a>seccomp是什么</h2><p><code>seccomp</code>是Linux内核中用于限制应用使用 <strong>系统调用（System Calls）</strong> 的机制，类比于<code>iptables</code>是网络的防火墙，<code>seccomp</code>是系统调用的防火墙。<code>seccomp</code>包括STRICT模式、BPF模式（cBPF，非eBFP）。</p><ul><li><code>STRICT</code>：严格限制系统调用，只允许使用<code>read</code>，<code>wirte</code>，<code>_exit</code>，<code>sigreturn</code>四个系统调用，对于其他的系统调用，会发送<code>SIGKILL</code>型号，使用场景有限。</li><li><code>BPF</code>：当系统调用发生时，<code>seccomp-bpf</code>调用指定的bpf过滤程序，bpf程序通过返回<code>SCMP_ACT_ALLOW</code>,<code>SCMP_ACT_KILL</code>,<code>SCMP_ACT_ERRNO</code>等值，来决定系统调用如何处理。一般是允许或拒绝，也可以向调用者假装返回调用成功的code，但实际上未进行系统调用。<br><code>seccomp-bpf</code>需要静态加载一个bpf程序，一般不需要自己重头编写，而是使用<code>libseccomp</code>进行编写。通过<code>libseccomp</code>，我们只需要编写如下所示的json文件，就能实现<code>seccomp-bpf</code>对系统调用的过滤。<pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;defaultAction&quot;</span>: <span class="hljs-string">&quot;SCMP_ACT_ERRNO&quot;</span>,  <span class="hljs-comment">// 默认拒绝，白名单形式</span>    <span class="hljs-attr">&quot;syscalls&quot;</span>: [        &#123;            <span class="hljs-attr">&quot;names&quot;</span>: [                  <span class="hljs-comment">// 允许的系统调用</span>                <span class="hljs-string">&quot;accept&quot;</span>,                <span class="hljs-string">&quot;chown&quot;</span>,                <span class="hljs-string">&quot;kill&quot;</span>,                <span class="hljs-string">&quot;mmap&quot;</span>,                ...            ],            <span class="hljs-attr">&quot;action&quot;</span>: <span class="hljs-string">&quot;SCMP_ACT_ALLOW&quot;</span>,            <span class="hljs-attr">&quot;args&quot;</span>: [],            <span class="hljs-attr">&quot;comment&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,            <span class="hljs-attr">&quot;includes&quot;</span>: &#123;&#125;,            <span class="hljs-attr">&quot;excludes&quot;</span>: &#123;&#125;        &#125;    ]&#125;</code></pre></li></ul><h2 id="seccomp用于容器"><a href="#seccomp用于容器" class="headerlink" title="seccomp用于容器"></a>seccomp用于容器</h2><p>通过seccomp可以限制容器内进程的系统调用，防止恶意攻击。<br>docker可以通过<code>--security-opt seccomp</code>对seccomp进行配置，不配置的情况下使用docker的<a href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json">默认的seccomp配置</a>。</p><ul><li>不对容器开启seccomp<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run --security-opt seccomp=unconfined xxxx</span></code></pre></li><li>指定自定义的seccomp策略<pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run --security-opt seccomp=/path/to/seccomp/config.json</span></code></pre>在只使用containerd的环境中，其配置方式与docker是一致的，containerd的<a href="https://github.com/containerd/containerd/blob/main/contrib/seccomp/seccomp_default.go"><code>default seccomp</code></a> 也基本是与docker是一致的。</li></ul><h3 id="kubernetes中使用seccomp"><a href="#kubernetes中使用seccomp" class="headerlink" title="kubernetes中使用seccomp"></a>kubernetes中使用seccomp</h3><p>在1.19之前的K8S版本中，可以通过添加<code>seccomp.security.alpha.kubernetes.io/pod</code>的Annotation来指定容器的seccomp配置：</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">some-pod</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">some-pod</span>  <span class="hljs-attr">annotations:</span>    <span class="hljs-attr">seccomp.security.alpha.kubernetes.io/pod:</span> <span class="hljs-string">localhost/profiles/some-profile.json</span><span class="hljs-attr">spec:</span></code></pre><p>在1.19以后通过<code>pod.spec.securityContext.seccompProfile</code>来指定：</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">some-pod</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">some-pod</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">securityContext:</span>    <span class="hljs-attr">seccompProfile:</span>      <span class="hljs-attr">type:</span> <span class="hljs-string">Localhost</span>      <span class="hljs-attr">localhostProfile:</span> <span class="hljs-string">profiles/some-profile.json</span>  <span class="hljs-attr">containers:</span></code></pre><p>其中<code>type</code>可以设置为:</p><ul><li><code>Localhost</code>：使用指定的seccomp的配置文件。</li><li><code>RuntimeDefault</code>：使用runtime默认的seccomp配置，例如上面的docker、containerd。</li><li><code>Unconfined</code>：关闭seccomp。<br>另外，可以通过开启kubelet的<a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2413-seccomp-by-default/README.md">SeccompDefault</a> 特性，来对容器默认配置runtime default seccomp策略。</li></ul><h2 id="seccomp-notify"><a href="#seccomp-notify" class="headerlink" title="seccomp notify"></a>seccomp notify</h2><p>虽然有了seccomp-bpf，但仍有诸多限制。seccomp-bpf整体上仍然是静态加载规则，bpf程序不能解引用指针（dereference pointer），去获取指针指向的内容。比如<code>open(&quot;/tmp/file.log&quot;,O_WRONLY)</code>的系统调用，在<code>seccomp_data</code>的<code>args</code>中可能是<code>[0x55fffff,0x0001]</code>，即<code>open(0x55fffff,0x0001)</code>，而<code>0x55fffff</code>指向的<code>/tmp/file.log</code>并不能获得到。</p><pre><code class="hljs c"><span class="hljs-comment">// seccomp_data是bpf程序的输入</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seccomp_data</span> &#123;</span>      <span class="hljs-keyword">int</span> nr;                         <span class="hljs-comment">// system call number</span>    __u32 arch;                     <span class="hljs-comment">// AUDIT_ARCH_* in &lt;linux/audit.h&gt;</span>    __u64 instruction_pointer;      <span class="hljs-comment">// CPU instruction pointer</span>    __u64 args[<span class="hljs-number">6</span>];                  <span class="hljs-comment">// system call arguments</span>&#125;;</code></pre><p>同时，cBPF也无法像eBPF那样通过BPF maps改变程序的行为。因此，无法实现例如：根据不同的pod、namespace执行不同的seccomp策略；或是阻塞容器的系统调用，直至Kubernetes裁决系统调用可以执行等一些场景。</p><p>seccomp notify可以解决这些问题。在seccomp notify机制下，seccomp会将系统调用的决定权转交给另一个用户态的进程，这个过程是通过seccomp返回对应的seccomp-bpf程序的文件描述符fd来实现的。以系统调用mount为例（kinvolk上的一个例子），具体的流程如下：<br><img src="/img/seccomp-notify-example-syscall-mount.jpg"></p><ul><li>程序调用<code>mount()</code>系统调用</li><li><code>seccomp</code>执行bpf程序，收到返回值<code>SCMP_ACT_MOTIFY</code></li><li><code>seccomp agent</code>通过使用<code>SECCOMP_IOCTL_NOTIF_RECV</code>调用<code>ioctl</code>，获取<code>seccomp_notify</code>（结构如图所示）</li><li><code>seccomp agent</code>从程序对应的<code>/proc/pid/mem</code>中读取<code>mount()</code>的参数，并执行mount操作（如果程序运行在容器里，需要进入对应的ns。例子中是执行mount操作，除此外可以根据需要进行审计记录等其他操作）</li><li><code>seccomp agent</code>使用<code>SECCOMP_IOCTL_NOTIF_SEND</code>调用<code>ioctl</code>，返回<code>seccomp_notify_resp</code>（结构如图所示），告诉<code>seccomp</code>返回success。</li><li><code>seccomp</code>返回0给程序</li></ul><p>使用seccomp notify需要：</p><ul><li>Runc &gt;= 1.1.0</li><li>Libseccomp &gt;= 2.5.0 (&gt;= 2.5.2 recommended)</li><li>Linux kernel &gt;= 5.9</li></ul><h3 id="kinvolk-seccomp-agent"><a href="#kinvolk-seccomp-agent" class="headerlink" title="kinvolk seccomp agent"></a>kinvolk seccomp agent</h3><p>随着runc实现<a href="https://github.com/opencontainers/runc/pull/2682">对seccomp notify的支持</a>，在K8S中使用seccomp notify也成为可能。简单来说，首先为runc运行的container配置bpf程序，用于返回notify；在收到seccomp的notify后，runc主进程调用seccomp agent（提前配置了socket地址），来进行加下来的处理逻辑。seccomp agent可以通过查询kube-apiserver来进一步实现复杂的处理逻辑。在runc中有个测试用的<a href="https://github.com/opencontainers/runc/blob/main/contrib/cmd/seccompagent/seccompagent.go">seccompagent</a> ，实现了简单的对<code>&quot;chmod&quot;, &quot;fchmod&quot;, &quot;fchmodat&quot;, &quot;mkdir&quot;</code>四个系统调用的，如果自己实现，则可以通过<a href="https://github.com/kinvolk/seccompagent">kinvolk/seccompagent</a> 实现。</p><p>引用kinvolk社区的一张图，说明K8S+seccomp notify的整个流程。<br><img src="/img/kinvolk-seccompagent-k8s.jpg"><br>1）配置pod的<code>seccompProfile</code>，指定配置文件为<code>foo.json</code>。文件中通过<code>SCMP_ACT_NOTIFY</code> 的action设置了哪些系统调用需要使用seccomp notify机制，同时通过<code>listenerPath</code>配置了seccomp agent的调用地址。除此外，还可以通过<code>listenerMetadata</code> 指定传递给seccomp agent的参数。<br>2）pod调度到节点，containerd根据设置的<code>foo.json</code>生成配置调用runc启动容器。<br>3）在pod调用mount后，runc收到seccomp返回的fd，将container process state与fd发送到seccomp agent中，由seccomp agent完成处理逻辑。</p><p>kinvolk/seccompagent代码库的结构：</p><ul><li><code>pkg/agent</code>：agent的实现，启动socket监听，接受OCI hook传递过来的fd。</li><li><code>pkg/handlers</code>：一些基本的系统调用实现，比如<code>mkdir</code>、<code>mount</code>等</li><li><code>pkg/kuberesolver</code>：用于实现基于Kubernetes Pod的自定义handler</li><li><code>pkg/nsenter</code>：用于操作、进入其他namespace</li><li><code>pkg/readarg</code>：用于获取系统调用的参数</li><li><code>pkg/registry</code>：用于注册一组系统调用的handler</li></ul><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>在kinvolk/seccompagent中有个<a href="https://github.com/kinvolk/seccompagent/blob/main/cmd/seccompagent/seccompagent.go">Demo</a>，下面以<code>mkdir</code>的调用演示功能。<br>为了简化demo，对官方的Demo部分代码做了精简：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat demo.go</span>package mainimport (&quot;fmt&quot;&quot;github.com/kinvolk/seccompagent/pkg/agent&quot;&quot;github.com/kinvolk/seccompagent/pkg/handlers&quot;&quot;github.com/kinvolk/seccompagent/pkg/kuberesolver&quot;&quot;github.com/kinvolk/seccompagent/pkg/nsenter&quot;&quot;github.com/kinvolk/seccompagent/pkg/registry&quot;)func main() &#123;nsenter.Init()kubeResolverFunc := func(pod *kuberesolver.PodContext, metadata map[string]string) *registry.Registry &#123;r := registry.New()r.SyscallHandler[&quot;mkdir&quot;] = handlers.MkdirWithSuffix(fmt.Sprintf(&quot;-%s-%s&quot;, pod.Pod, pod.Namespace)) // 注册mkdir的系统调用handlerreturn r&#125;resolver, err := kuberesolver.KubeResolver(kubeResolverFunc)if err != nil &#123;panic(err)&#125;err = agent.StartAgent(&quot;/run/seccomp-agent.socket&quot;, resolver)&#125;<span class="hljs-meta">$</span><span class="bash"> cat notify.json</span>&#123;   &quot;architectures&quot; : [      &quot;SCMP_ARCH_X86&quot;,      &quot;SCMP_ARCH_X32&quot;   ],   &quot;defaultAction&quot; : &quot;SCMP_ACT_ALLOW&quot;,   &quot;listenerPath&quot;: &quot;/run/seccomp-agent.socket&quot;,   &quot;syscalls&quot; : [      &#123;         &quot;action&quot; : &quot;SCMP_ACT_NOTIFY&quot;,         &quot;names&quot; : [            &quot;mkdir&quot;         ]      &#125;   ]&#125;</code></pre><p>用<a href="https://github.com/kinvolk/seccompagent/blob/main/Dockerfile">Dockerfile</a>创建镜像，部署<a href="https://github.com/kinvolk/seccompagent/blob/main/deploy/seccompagent.yaml">seccomp agent</a> 与测试用的busybox，将<code>notify.json</code>拷贝到<code> /var/lib/kubelet/seccomp/notify.json</code>：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat busybox.yaml</span>apiVersion: apps/v1kind: Deploymentmetadata:  name: busybox-deploy  namespace: testspec:  replicas: 1  selector:    matchLabels:      app: busybox-deploy  template:    metadata:      labels:        app: busybox-deploy    spec:      securityContext:        seccompProfile:          type: Localhost          localhostProfile: notify.json #相对于/var/lib/kubelet/seccomp的文件路径      tolerations:        - key: &quot;node-role.kubernetes.io/master&quot;          operator: Exists      containers:        - image: busybox          command: [&quot;sleep&quot;,&quot;3600&quot;]          imagePullPolicy: IfNotPresent          name: busybox<span class="hljs-meta">$</span><span class="bash"> ls /var/lib/kubelet/seccomp/notify.json</span>/var/lib/kubelet/seccomp/notify.json<span class="hljs-meta">$</span><span class="bash"> kubectl get po -n seccomp-agent -o wide</span>NAME                  READY   STATUS    RESTARTS   AGE     IP            NODE       NOMINATED NODE   READINESS GATESseccomp-agent-7z2bl   1/1     Running   0          2m31s   10.222.0.20   maao-dev   &lt;none&gt;           &lt;none&gt;<span class="hljs-meta">$</span><span class="bash"> kubectl get po -n <span class="hljs-built_in">test</span> -o wide</span>NAME                              READY   STATUS    RESTARTS   AGE   IP            NODE       NOMINATED NODE   READINESS GATESbusybox-deploy-697468b5dd-dxr7q   1/1     Running   0          2m    10.222.0.21   maao-dev   &lt;none&gt;           &lt;none&gt;</code></pre><p>在busybox里调用<code>mkdir</code>，会由seccomp agent创建带有相应后缀的文件夹：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> kubectl <span class="hljs-built_in">exec</span> -it busybox-deploy-697468b5dd-dxr7q -n <span class="hljs-built_in">test</span> sh</span>kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead./ # lsbin   dev   etc   home  proc  root  sys   tmp   usr   var/ # mkdir a/ # lsa-busybox-deploy-697468b5dd-dxr7q-test  etc                                     root                                    usrbin                                     home                                    sys                                     vardev                                     proc                                    tmp</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kinvolk.io/blog/2022/03/bringing-seccomp-notify-to-runc-and-kubernetes/">Bringing Seccomp Notify to Runc and Kubernetes</a>（主要介绍Seccomp Notify在Kubernetes里的实践，里面有链接很多相关的博文）<br><a href="https://people.kernel.org/brauner/the-seccomp-notifier-new-frontiers-in-unprivileged-container-development">Seccomp Notify – New Frontiers in Unprivileged Container Development</a>（很全面的一篇文章，从seccomp介绍到seccomp notify）<br><a href="https://itnext.io/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111">Hardening Docker and Kubernetes with <code>seccomp</code></a>（主要介绍Kubernetes中原生的seccomp使用）<br><a href="https://archive.fosdem.org/2021/schedule/event/containers_k8s_seccomp_notify/">Seccomp Notify on Kubernetes</a> FOSDEM 2021的一个分享</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Seccomp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cilium流量分析(一)</title>
    <link href="/2022/08/09/Cilium%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-%E4%B8%80/"/>
    <url>/2022/08/09/Cilium%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>结合开发环境和代码进行Cilium流量的分析，会省略一些特性，比如Overlay、L7 Policy等。顺序是按照官方文档<a href="https://docs.cilium.io/en/v1.13/network/ebpf/lifeofapacket/">Life of a Packet</a> 的图进行，本文是Endpoint to Endpoint(socket)的分析。</p><a id="more"></a><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>使用cilium 1.12.0版本的代码库，在Mac上使用<br><code>K8S=1 NO_BUILD=1 TUNNEL_MODE_STRING=disabled SERVER_BOX=cilium/ubuntu-next-cgroupv2 SERVER_VERSION=0 contrib/vagrant/start.sh</code>部署单节点的Cilium Kubernetes集群。其中：<br>1）提前执行了<code>make build</code>，不然在vm里编译会很慢<br>2）修改了shell脚本里的cilium启动参数，主要：关闭了tunnel（默认是VXLAN）；启动cilium kube-proxy-replacement；启用sockops。</p><pre><code class="hljs shell">--- a/contrib/vagrant/scripts/03-install-kubernetes-worker.sh+++ b/contrib/vagrant/scripts/03-install-kubernetes-worker.sh@@ -305,10 +305,10 @@ EOF log &quot;reloading systemctl daemon and enabling and restarting kube-proxy&quot; sudo systemctl daemon-reload-sudo systemctl enable kube-proxy-sudo systemctl restart kube-proxy+# sudo systemctl enable kube-proxy+# sudo systemctl restart kube-proxy-sudo systemctl status kube-proxy --no-pager+# sudo systemctl status kube-proxy --no-pager--- a/contrib/vagrant/start.sh+++ b/contrib/vagrant/start.sh@@ -306,7 +306,7 @@ function write_cilium_cfg() &#123;     cilium_options=&quot;\       --debug --pprof --enable-hubble --hubble-listen-address :4244 --enable-k8s-event-handover \-      --k8s-require-ipv4-pod-cidr --enable-bandwidth-manager --kube-proxy-replacement=disabled \+      --k8s-require-ipv4-pod-cidr --enable-bandwidth-manager --kube-proxy-replacement=strict --cgroup-root=/sys/fs/cgroup --sockops-enable \       --enable-remote-node-identity&quot;     cilium_operator_options=&quot; --debug&quot;</code></pre><p>3）重新做了个box：cilium/ubuntu-next-cgroupv2，就是在cilium/ubuntu-next之上开启了<a href="https://github.com/systemd/systemd/blob/main/docs/CGROUP_DELEGATION.md#three-different-tree-setups-">cgroupv2 unified mode</a>。<code>BPF_PROG_TYPE_CGROUP_XXX</code>需要cgroupv2才能使用。</p><blockquote><p>Kubernetes使用cgroupv2需要做一些<a href="https://blog.kintone.io/entry/2022/03/08/170206">额外的配置</a>。</p></blockquote><p>环境部署完后，再部署个pod/nc-k8s1，service/nc-k8s1。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> kubectl get po -o wide</span>NAME      READY   STATUS    RESTARTS   AGE   IP           NODE   NOMINATED NODE   READINESS GATESnc-k8s1   1/1     Running   0          5s    10.11.0.99   k8s1   &lt;none&gt;           &lt;none&gt;<span class="hljs-meta">$</span><span class="bash"> kubectl get node -o wide</span>NAME   STATUS   ROLES    AGE   VERSION   INTERNAL-IP     EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION         CONTAINER-RUNTIMEk8s1   Ready    &lt;none&gt;   61m   v1.24.2   192.168.60.11   &lt;none&gt;        Ubuntu 20.04.4 LTS   5.18.0-g7e062cda7d90   containerd://1.6.3<span class="hljs-meta">$</span><span class="bash"> systemctl status kube-proxy</span>● kube-proxy.service - Kubernetes Kube-Proxy Server     Loaded: loaded (/etc/systemd/system/kube-proxy.service; disabled; vendor preset: enabled)     Active: inactive (dead)       Docs: https://kubernetes.io/docs/concepts/overview/components/#kube-proxy             https://kubernetes.io/docs/reference/generated/kube-proxy/<span class="hljs-meta">$</span><span class="bash"> kubectl get svc -o wide</span>NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE    SELECTORkubernetes   ClusterIP   172.20.0.1    &lt;none&gt;        443/TCP        8m2s   &lt;none&gt;nc-k8s1      NodePort    172.20.0.84   &lt;none&gt;        80:32438/TCP   9s     app=nc-k8s1</code></pre><h2 id="Endpoint-to-Endpoint-socket"><a href="#Endpoint-to-Endpoint-socket" class="headerlink" title="Endpoint to Endpoint(socket)"></a>Endpoint to Endpoint(socket)</h2><h3 id="流量图"><a href="#流量图" class="headerlink" title="流量图"></a>流量图</h3><p><img src="/img/cilium_bpf_datapath_e2e.svg"></p><p>这一篇主要分析下下面那张socket的图，tc的后面再分析。图中的<code>bpf_sockops.c</code>与<code>bpf_redir.c</code>是<code>BPF_PROG_TYPE_SOCK_OPS</code>与 <code>BPF_PROG_TYPE_SK_SKB</code>配合做的一个socket层的redirect，先由<code>bpf_sockops.c</code>维护一个<code>BPF_MAP_TYPE_SOCKHASH</code>类型的Map，再由<code>bpf_redir.c</code>根据Map将数据重定向到对应的socket。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>分别查看bpf_redir、bpf_sockops与map。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> bpftool prog show pinned /sys/fs/bpf/bpf_redir</span>3228: sk_msg  name bpf_redir_proxy  tag 2dfc83bbb7ceae9b  gplloaded_at 2022-08-05T06:58:48+0000  uid 0xlated 1064B  jited 590B  memlock 4096B  map_ids 402,406,422btf_id 233<span class="hljs-meta">$</span><span class="bash"> bpftool prog show pinned /sys/fs/bpf/bpf_sockops</span>3222: sock_ops  name bpf_sockmap  tag 00baed82e9c683bc  gplloaded_at 2022-08-05T06:58:48+0000  uid 0xlated 1656B  jited 888B  memlock 4096B  map_ids 417,402,406,98,422btf_id 225<span class="hljs-meta">$</span><span class="bash"> bpftool map show id 422</span>422: sockhash  name cilium_sock_ops  flags 0x0key 44B  value 4B  max_entries 65535  memlock 3145728B</code></pre><p>调用层次：</p><pre><code class="hljs coq">__section(<span class="hljs-string">&quot;sk_msg&quot;</span>)bpf_redir_proxy  |<span class="hljs-type">-sk_msg_extract4_key</span>  |<span class="hljs-type">-lookup_ip4_remote_endpoint</span>  |<span class="hljs-type">-policy_sk_egress</span>  |<span class="hljs-type">-msg_redirect_hash</span>_section(<span class="hljs-string">&quot;sockops&quot;</span>)bpf_sockmap  |<span class="hljs-type">-switch</span> (op)    <span class="hljs-built_in">case</span> BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB:    <span class="hljs-built_in">case</span> BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:       bpf_sock_ops_ipv4         |<span class="hljs-type">-sk_extract4_key</span>         |<span class="hljs-type">-lookup_ip4_remote_endpoint</span>         |<span class="hljs-type">-policy_sk_egress</span>         |<span class="hljs-type">-__lookup_ip4_endpoint</span>         |<span class="hljs-type">-sock_hash_update</span></code></pre><p>看下大体的实现：</p><pre><code class="hljs c"><span class="hljs-comment">// 负责进行socket重定向</span>__section(<span class="hljs-string">&quot;sk_msg&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bpf_redir_proxy</span><span class="hljs-params">(struct sk_msg_md *msg)</span></span><span class="hljs-function"></span>&#123;  sk_msg_extract4_key(msg, &amp;key); <span class="hljs-comment">// 从msg中获取map的key,key包括了socket的源地址、源端口、目标地址、目标端口、IPFamily</span>  info = lookup_ip4_remote_endpoint(key.dip4); <span class="hljs-comment">// 从ipcache map中查找对应的endpoint，用于policy的判断。ipcache存储了cilium管理的endpoint，以ip地址为key，value为对应的endpoint信息，比如identity，cilium的网络策略的实现依赖于identity</span>  verdict = policy_sk_egress(dst_id, key.sip4, (__u16)key.dport); <span class="hljs-comment">// policy的判断</span>  <span class="hljs-keyword">if</span> (verdict &gt;= <span class="hljs-number">0</span>)    msg_redirect_hash(msg, &amp;SOCK_OPS_MAP, &amp;key, flags); <span class="hljs-comment">//调用bpf_sk_redirect_map helper function，根据sockhash map进行重定向</span>&#125;<span class="hljs-comment">// 负责进行sockhash map的维护</span>_section(<span class="hljs-string">&quot;sockops&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bpf_sockmap</span><span class="hljs-params">(struct bpf_sock_ops *skops)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">switch</span> (op) &#123;  <span class="hljs-keyword">case</span> BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: <span class="hljs-comment">// 分别对应被动连接与主动连接，因此sockhash map里两个方向的socket都会记录</span>  <span class="hljs-keyword">case</span> BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:  ...<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ENABLE_IPV4</span>    <span class="hljs-keyword">if</span> (family == AF_INET)      bpf_sock_ops_ipv4(skops); <span class="hljs-comment">// 当socket状态变为ESTABLISHED后，执行bpf_sock_ops_ipv4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  ...  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bpf_sock_ops_ipv4</span><span class="hljs-params">(struct bpf_sock_ops *skops)</span></span><span class="hljs-function"></span>&#123;  sk_extract4_key(skops, &amp;key);  <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;    info = lookup_ip4_remote_endpoint(key.dip4); <span class="hljs-comment">// 从ipcache map中查找有对应的endpoint</span>    <span class="hljs-keyword">if</span> (info != <span class="hljs-literal">NULL</span> &amp;&amp; info-&gt;sec_label)      dst_id = info-&gt;sec_label;    <span class="hljs-keyword">else</span>      dst_id = WORLD_ID;  &#125;  verdict = policy_sk_egress(dst_id, key.sip4, (__u16)key.dport); <span class="hljs-comment">// policy策略判断</span>  <span class="hljs-comment">/* Lookup IPv4 address, this will return a match if:</span><span class="hljs-comment">   * - The destination IP address belongs to the local endpoint manage</span><span class="hljs-comment">   *   by Cilium.</span><span class="hljs-comment">   * - The destination IP address is an IP address associated with the</span><span class="hljs-comment">   *   host itself.</span><span class="hljs-comment">   * Then because these are local IPs that have passed LB/Policy/NAT</span><span class="hljs-comment">   * blocks redirect directly to socket.</span><span class="hljs-comment">   */</span>  exists = __lookup_ip4_endpoint(key.dip4);  <span class="hljs-keyword">if</span> (!exists)    <span class="hljs-keyword">return</span>;  sock_hash_update(skops, &amp;SOCK_OPS_MAP, &amp;key, BPF_NOEXIST); <span class="hljs-comment">// 更新sockhash map</span>&#125;</code></pre><p>代码逻辑比较简单，其中重定向是通过bpf helper函数<code>bpf_msg_redirect_hash()</code>实现，会根据sockhash map中的key直接进行转发。此外涉及另外两个map，其中<code>cilium_ipcache</code>是<code>lookup_ip4_remote_endpoint()</code>查询的map，<code>cilium_lxc</code>是<code>__lookup_ip4_endpoint</code>查询的map。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cilium map get cilium_ipcache | grep 10.11.0.99</span>10.11.0.99/32                             identity=3187 encryptkey=0 tunnelendpoint=0.0.0.0   sync<span class="hljs-meta">$</span><span class="bash"> cilium map get cilium_lxc | grep 10.11.0.99</span>10.11.0.99:0     id=25    flags=0x0000 ifindex=22  mac=DA:96:96:60:21:7E nodemac=9A:37:05:A5:EA:14   sync</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来手动测试下重定向，先使用bpftool查看map，有4条数据。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> bpftool map dump id 422</span>key:0a 0b 00 0a 00 00 00 00  00 00 00 00 00 00 00 000a 0b 00 e9 00 00 00 00  00 00 00 00 00 00 00 0001 00 00 00 10 90 00 00  c4 e6 00 00value:No space left on devicekey:c0 a8 3c 0b 00 00 00 00  00 00 00 00 00 00 00 00c0 a8 3c 0b 00 00 00 00  00 00 00 00 00 00 00 0001 00 00 00 10 90 00 00  d6 70 00 00value:No space left on devicekey:c0 a8 3c 0b 00 00 00 00  00 00 00 00 00 00 00 00c0 a8 3c 0b 00 00 00 00  00 00 00 00 00 00 00 0001 00 00 00 d6 70 00 00  10 90 00 00value:No space left on devicekey:0a 0b 00 e9 00 00 00 00  00 00 00 00 00 00 00 000a 0b 00 0a 00 00 00 00  00 00 00 00 00 00 00 0001 00 00 00 c4 e6 00 00  10 90 00 00value:No space left on deviceFound 0 elements</code></pre><p>在节点上执行<code>tcpdump -i lxcf4d0f7379d34 -enn</code>，其中<code>lxcf4d0f7379d34</code>是nc-k8s1容器的veth pair宿主机一端。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> kubectl <span class="hljs-built_in">exec</span> -it nc-k8s1 -- ip a</span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host       valid_lft forever preferred_lft forever21: eth0@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP qlen 1000    link/ether da:96:96:60:21:7e brd ff:ff:ff:ff:ff:ff    inet 10.11.0.99/32 scope global eth0       valid_lft forever preferred_lft forever    inet6 fd04::b033/128 scope global flags 02       valid_lft forever preferred_lft forever    inet6 fe80::d896:96ff:fe60:217e/64 scope link       valid_lft forever preferred_lft forever<span class="hljs-meta">$</span><span class="bash"> ip a</span>...22: lxcf4d0f7379d34@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000    link/ether 9a:37:05:a5:ea:14 brd ff:ff:ff:ff:ff:ff link-netns cni-83b0571c-c726-6eaa-1e3f-5395347df6ea    inet6 fe80::9837:5ff:fea5:ea14/64 scope link       valid_lft forever preferred_lft forever</code></pre><p>在节点上执行<code>nc 10.11.0.99 80</code>，（nc-k8s1里执行了nc -lv 80）可以看到tcpdump抓到了tcp三次握手的包。但后续的数据包不会被tcpdump抓到，因为后续的数据包通过socket重定向进行转发，不再通过包括tc在内的内核协议栈，tcpdump也就无法在tc层抓到相应的数据包。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> nc 10.11.0.99 80</span>hellopackage<span class="hljs-meta">$</span><span class="bash"> kubectl logs -f nc-k8s1</span>Listening on [0.0.0.0] (family 0, port 80)Connection from 10.11.0.233 47638 received!hellopackage</code></pre><p>在断开连接前，再次查看sockhash map，可以看到新增的两条数据，分别是tcp两端socket在建立是加入的。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> bpftool map dump id 422 | grep key | wc -l</span>6</code></pre><h3 id="Service实现（socket）"><a href="#Service实现（socket）" class="headerlink" title="Service实现（socket）"></a>Service实现（socket）</h3><p>cilium在socket层的bpf程序除了上面两个外，还有就是cgroupv2类型的bpf程序也会在socket操作时触发，cilium用来实现kubernetes service的功能。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> bpftool cgroup show /sys/fs/cgroup/</span>ID       AttachType      AttachFlags     Name3222     sock_ops                        bpf_sockmap3280     connect4                        sock4_connect3260     connect6                        sock6_connect3288     post_bind4                      sock4_post_bind3268     post_bind6                      sock6_post_bind3292     sendmsg4                        sock4_sendmsg3272     sendmsg6                        sock6_sendmsg3296     recvmsg4                        sock4_recvmsg3276     recvmsg6                        sock6_recvmsg3284     getpeername4                    sock4_getpeername3264     getpeername6                    sock6_getpeername</code></pre><p>以ipv4 tcp的service为例，在socket connect调用时触发bpf程序。<br>调用层次：</p><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">__section</span>(<span class="hljs-string">&quot;cgroup/connect4&quot;</span>)</span><span class="hljs-variable">sock4_connect</span>  |-<span class="hljs-variable">__sock4_xlate_fwd</span>      |-<span class="hljs-variable">lb4_lookup_service</span>          |-<span class="hljs-function"><span class="hljs-title">map_lookup_elem</span>(<span class="hljs-variable">LB4_SERVICES_MAP_V2</span>)</span>      |-<span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">!svc</span>)        <span class="hljs-variable">sock4_wildcard_lookup_full</span>          |-<span class="hljs-variable">sock4_wildcard_lookup</span>      |-<span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-function"><span class="hljs-title">lb4_svc_is_affinity</span>(<span class="hljs-variable">svc</span>))</span>        <span class="hljs-variable">lb4_affinity_backend_id_by_netns</span>          |-<span class="hljs-variable">__lb4_affinity_backend_id</span>              |-<span class="hljs-function"><span class="hljs-title">map_lookup_elem</span>(<span class="hljs-variable">LB4_AFFINITY_MAP</span>)</span>        <span class="hljs-variable">__lb4_lookup_backend</span>          |-<span class="hljs-function"><span class="hljs-title">map_lookup_elem</span>()</span>      |-<span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">backend_id</span> == <span class="hljs-number">0</span>)        <span class="hljs-variable">__lb4_lookup_backend_slot</span>          |-<span class="hljs-function"><span class="hljs-title">map_lookup_elem</span>(<span class="hljs-variable">LB4_SERVICES_MAP_V2</span>)</span>        <span class="hljs-variable">__lb4_lookup_backend</span>          |-<span class="hljs-function"><span class="hljs-title">map_lookup_elem</span>(<span class="hljs-variable">LB4_BACKEND_MAP_V2</span>)</span>      |-<span class="hljs-variable">lb4_update_affinity_by_netns</span>          |--<span class="hljs-variable">__lb4_update_affinity</span>              |-<span class="hljs-function"><span class="hljs-title">map_update_elem</span>(<span class="hljs-variable">LB4_AFFINITY_MAP</span>)</span>      |-<span class="hljs-variable">sock4_update_revnat</span>        |-<span class="hljs-function"><span class="hljs-title">map_lookup_elem</span>(<span class="hljs-variable">LB4_REVERSE_NAT_SK_MAP</span>)</span></code></pre><p>大体代码：</p><pre><code class="hljs c">__section(<span class="hljs-string">&quot;cgroup/connect4&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sock4_connect</span><span class="hljs-params">(struct bpf_sock_addr *ctx)</span></span><span class="hljs-function"></span>&#123;....__sock4_xlate_fwd(ctx, ctx, <span class="hljs-literal">false</span>); <span class="hljs-keyword">return</span> SYS_PROCEED;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-keyword">static</span> __always_inline <span class="hljs-keyword">int</span> __sock4_xlate_fwd(struct bpf_sock_addr *ctx,     struct bpf_sock_addr *ctx_full,     <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> udp_only)&#123;<span class="hljs-keyword">if</span> (is_defined(ENABLE_SOCKET_LB_HOST_ONLY) &amp;&amp; !in_hostns) <span class="hljs-comment">//验证是否符合lb host only</span><span class="hljs-keyword">return</span> -ENXIO;<span class="hljs-keyword">if</span> (!udp_only &amp;&amp; !sock_proto_enabled(ctx-&gt;protocol))  <span class="hljs-comment">//验证协议类型</span><span class="hljs-keyword">return</span> -ENOTSUP;svc = lb4_lookup_service(&amp;key, <span class="hljs-literal">true</span>); <span class="hljs-comment">//找clusterIP</span><span class="hljs-keyword">if</span> (!svc)svc = sock4_wildcard_lookup_full(&amp;key, in_hostns); <span class="hljs-comment">//找nodeport与hostport</span><span class="hljs-keyword">if</span> (!svc)<span class="hljs-keyword">return</span> -ENXIO;<span class="hljs-keyword">if</span> (lb4_svc_is_affinity(svc)) &#123;  <span class="hljs-comment">//设置了亲和性</span>backend_id = lb4_affinity_backend_id_by_netns(svc, &amp;id);<span class="hljs-keyword">if</span> (backend_id != <span class="hljs-number">0</span>) &#123; backend = __lb4_lookup_backend(backend_id); <span class="hljs-keyword">if</span> (!backend) <span class="hljs-comment">//后端pod已不存在，重新调度</span>backend_id = <span class="hljs-number">0</span>;&#125;&#125;<span class="hljs-keyword">if</span> (backend_id == <span class="hljs-number">0</span>) &#123;key.backend_slot = (sock_select_slot(ctx_full) % svc-&gt;count) + <span class="hljs-number">1</span>;backend_slot = __lb4_lookup_backend_slot(&amp;key);backend_id = backend_slot-&gt;backend_id;backend = __lb4_lookup_backend(backend_id);&#125;<span class="hljs-keyword">if</span> (lb4_svc_is_affinity(svc) &amp;&amp; !backend_from_affinity) <span class="hljs-comment">//如果是service设置了亲和性，并且此次是重新负载了，则进行affinity map的更新</span>lb4_update_affinity_by_netns(svc, &amp;id, backend_id);<span class="hljs-keyword">if</span> (sock4_update_revnat(ctx_full, backend, &amp;orig_key,svc-&gt;rev_nat_index) &lt; <span class="hljs-number">0</span>) &#123;update_metrics(<span class="hljs-number">0</span>, METRIC_EGRESS, REASON_LB_REVNAT_UPDATE);<span class="hljs-keyword">return</span> -ENOMEM;&#125;<span class="hljs-comment">// 进行socket的DNAT</span>ctx-&gt;user_ip4 = backend-&gt;address;ctx_set_port(ctx, backend-&gt;port);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>流程如下：<br>1）先找到对应的Service。通过<code>lb4_lookup_service()</code>查找是否是某个Service的ClusterIP。这块查询的是hash map <code>cilium_lb4_services_v2</code>，key和value如下。</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lb4_key</span> &#123;</span>__be32 address;<span class="hljs-comment">/* Service virtual IPv4 address */</span>__be16 dport;<span class="hljs-comment">/* L4 port filter, if unset, all ports apply */</span>__u16 backend_slot;<span class="hljs-comment">/* Backend iterator, 0 indicates the svc frontend */</span>__u8 proto;<span class="hljs-comment">/* L4 protocol, currently not used (set to 0) */</span>__u8 scope;<span class="hljs-comment">/* LB_LOOKUP_SCOPE_* for externalTrafficPolicy=Local */</span>__u8 pad[<span class="hljs-number">2</span>];&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lb4_service</span> &#123;</span><span class="hljs-keyword">union</span> &#123;__u32 backend_id;<span class="hljs-comment">/* Backend ID in lb4_backends */</span>__u32 affinity_timeout;<span class="hljs-comment">/* In seconds, only for svc frontend */</span>__u32 l7_lb_proxy_port;<span class="hljs-comment">/* In host byte order, only when flags2 &amp;&amp; SVC_FLAG_L7LOADBALANCER */</span>&#125;;<span class="hljs-comment">/* For the service frontend, count denotes number of service backend</span><span class="hljs-comment"> * slots (otherwise zero).</span><span class="hljs-comment"> */</span>__u16 count;__u16 rev_nat_index;<span class="hljs-comment">/* Reverse NAT ID in lb4_reverse_nat */</span>__u8 flags;__u8 flags2;__u8  pad[<span class="hljs-number">2</span>];&#125;;</code></pre><p>以环境中的service/nc-k8s1为例，clusterIP为<code>172.20.0.84</code>，map信息为：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cilium map get cilium_lb4_services_v2  | grep 172.20.0.84</span>172.20.0.84:80        10800 1 (6) [0x10 0x0]    sync</code></pre><p>通过bpftool可以看到两条记录，第一条是service backend，记录了后端nc-k8s1 pod信息，第二条是service frontend记录了service的信息。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> bpftool map dump pinned /sys/fs/bpf/tc/globals/cilium_lb4_services_v2 | grep <span class="hljs-string">&quot;ac 14 00 54&quot;</span></span>key: ac 14 00 54 00 50 01 00  00 00 00 00  value: 14 00 00 00 00 00 00 06  00 00 00 00key: ac 14 00 54 00 50 00 00  00 00 00 00  value: 30 2a 00 00 01 00 00 06  10 00 00 00</code></pre><p>整理一下就是：</p><pre><code class="hljs json">[&#123;    <span class="hljs-attr">&quot;key&quot;</span>: &#123;<span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;172.20.0.84&quot;</span>,<span class="hljs-attr">&quot;dport&quot;</span>: <span class="hljs-number">80</span>,<span class="hljs-attr">&quot;backend_slot&quot;</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">&quot;proto&quot;</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">&quot;scope&quot;</span>: <span class="hljs-number">0</span>&#125;,<span class="hljs-attr">&quot;value&quot;</span>: &#123;<span class="hljs-attr">&quot;backend_id&quot;</span>: <span class="hljs-number">0x14</span>,<span class="hljs-attr">&quot;count&quot;</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">&quot;rev_nat_index&quot;</span>: <span class="hljs-number">0x06</span>&#125;&#125;, &#123;<span class="hljs-attr">&quot;key&quot;</span>: &#123;<span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;172.20.0.84&quot;</span>,<span class="hljs-attr">&quot;dport&quot;</span>: <span class="hljs-number">80</span>,<span class="hljs-attr">&quot;backend_slot&quot;</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">&quot;proto&quot;</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">&quot;scope&quot;</span>: <span class="hljs-number">0</span>&#125;,<span class="hljs-attr">&quot;value&quot;</span>: &#123;<span class="hljs-attr">&quot;affinity_timeout&quot;</span>: <span class="hljs-number">0x302a</span>,<span class="hljs-attr">&quot;count&quot;</span>: <span class="hljs-number">1</span>,<span class="hljs-attr">&quot;rev_nat_index&quot;</span>: <span class="hljs-number">0x06</span>&#125;&#125;]</code></pre><p><code>lb4_lookup_service()</code>是根据ClusterIP查找对应的service，如果<code>lb4_lookup_service()</code>查找失败，会使用<code>sock4_wildcard_lookup_full()</code>查找nodeport、hostport记录，环境中的nc-k8s1 service的nodeport是32438，map中的记录如下所示。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cilium map get cilium_lb4_services_v2  | grep 32438</span>10.0.2.15:32438       10800 1 (11) [0x52 0x0]   sync0.0.0.0:32438         10800 1 (8) [0x12 0x0]    sync192.168.59.15:32438   10800 1 (10) [0x52 0x0]   sync192.168.61.11:32438   10800 1 (13) [0x52 0x0]   sync192.168.60.11:32438   10800 1 (12) [0x52 0x0]   sync</code></pre><p>2）亲和性逻辑。通过<code>lb4_affinity_backend_id_by_netns()</code>查找亲和性的后端。这里用到的map是<code>cilium_lb4_affinity</code> ，key中记录了clientIP、访问时间等，map在进行负载之后通过<code>lb4_update_affinity_by_netns()</code>进行更新。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">  bpftool map dump pinned /sys/fs/bpf/tc/globals/cilium_lb4_affinity</span>key: 01 00 00 00 00 00 00 00  00 06 01 00 00 00 00 00value: 14 1d 00 00 00 00 00 00  14 00 00 00 00 00 00 00Found 1 element</code></pre><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lb_affinity_val</span> &#123;</span>__u64 last_used;__u32 backend_id; __u32 pad;&#125; __packed;</code></pre><p>通过<code>lb4_affinity_backend_id_by_netns()</code>找到backend_ip后，再通过<code>__lb4_lookup_backend()</code>查找后端，查找的map为<code>cilium_lb4_backends_v2</code>，key为<code>backend_ip</code>，value中记录了podIP</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cilium map get cilium_lb4_backends_v2</span>Key   Value                 State   Error20    ANY://10.11.0.99:80   sync</code></pre><p>3）选择后端Pod进行负载。<code>sock_select_slot()</code>方法用于选择后端Pod，对TCP使用<code>get_prandom_u32()</code>进行随机选择，对于UDP则对socket cookie作hash进行选择。根据<code>backend_slot</code>查询<code>backend_id</code>，最终查询到<code>backend</code>。</p><p>4）更新nat表。如下记录，表示 <code>172.20.0.84:80</code>(<code>ac 14 00 54 00 50</code>)发送到了<code>10.11.0.99：80</code>（<code>0a 0b 00 63 00 50</code>），其中前面64位是socket cookie。这个表主要在recvmsg4、getpeername4时用于进行DNAT，查了相关资料，部分UDP应用需要检测回包源地址，因此需要进行DNAT。而getpeername通过DNAT可以获取到Service的地址，做到对完全应用透明。</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> bpftool map dump pinned /sys/fs/bpf/tc/globals/cilium_lb4_reverse_sk | grep <span class="hljs-string">&quot;ac 14 00 54 00 50&quot;</span></span>key: 0b 3e 00 00 00 00 00 00  0a 0b 00 63 00 50 00 00  value: ac 14 00 54 00 50 00 06</code></pre>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BPF</tag>
      
      <tag>Cilium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[笔记]BPF and XDP Reference Guide(cilium)</title>
    <link href="/2021/03/01/%E7%AC%94%E8%AE%B0-BPF-and-XDP-Reference-Guide-cilium/"/>
    <url>/2021/03/01/%E7%AC%94%E8%AE%B0-BPF-and-XDP-Reference-Guide-cilium/</url>
    
    <content type="html"><![CDATA[<p>本文是Cilium中<a href="https://docs.cilium.io/en/stable/bpf/">BPF and XDP Reference Guide</a>的笔记。本文半翻译、半笔记，有些地方直接概况叙述。</p><p>学习BPF的过程：</p><ul><li>阅读相关文献，记录两篇的笔记。另一篇的链接<a href="https://maao.cloud/2021/02/24/%E7%AC%94%E8%AE%B0-Linux-Socket-Filtering-aka-Berkeley-Packet-Filter-BPF/">[笔记]Linux Socket Filtering aka Berkeley Packet Filter (BPF)</a></li></ul><a id="more"></a><p>BPF类似于虚机指令集，允许在许多内核hook执行代码，主要用于网络、内核追踪以及安全（比如sandboxing）。</p><p>BPF的发展进过了cBPF与eBPF，tcpdump就是使用cBPF，但目前内核中只允许eBPF，兼容cBPF，cBPF的指令在内核中会自动替换为eBPF。</p><h2 id="BPF结构"><a href="#BPF结构" class="headerlink" title="BPF结构"></a>BPF结构</h2><p>BPF除了指令集，还有bpf map、辅助函数（helper functions）、尾调机制（tail calls）、安全强化原语（security hardening primitives）、用于pinning对象（BPF map或是BPF program）的伪文件系统，另外还支持网卡offload的指令。</p><p>编译：C -&gt; Clang -&gt; LLVM backend -&gt; BPF指令</p><p>BPF的两个主要子系统<code>tc</code>和<code>XDP</code>。</p><ul><li><code>XDP</code>在最早的网络驱动程序阶段，高性能 ，但数据包还未进行元数据的解析。</li><li><code>tc</code>位置在内核栈中，可以访问更多的数据包元数据以及内核函数。</li><li>其他的子系统还包括：<code>kprobes</code>、<code>uprobes</code>、<code>tracepoints</code>等。</li></ul><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>BPF是RISC指令集：</p><ul><li><p>BPF指令-&gt; JIT -&gt; 机器码</p></li><li><p>BPF指令直接在内核中操作，无需进行内核/用户空间的切换。</p></li><li><p>灵活的可编程数据路径（data path），通过减少场景无需的特性，提升程序性能。</p></li><li><p>无缝的BPF程序更新，无需重启内核 ，也不会中断网络。</p></li><li><p>稳定的用户空间ABI，可跨不同体系的移植。</p></li></ul><p>BPF是事件驱动的：例如数据包的接收触发ingress path上的BPF程序，内核代码的执行触发相应的kprobe BPF。</p><p>BPF包括11个64位的寄存器（包含32位的子寄存器）、程序计数器、512字节的栈。<br>寄存器分别是<code>r0</code>到<code>r10</code>，除了部分特殊的逻辑运算指令（ALU）外会使用其32位的子寄存器外，其他都是使用64位寄存器。32位到64位的扩展为高位补零。</p><ul><li><code>r0</code> 存放bpf helper函数的返回值。另外，整个BPF的返回值会以32位的形式存放在<code>r0</code>中。</li><li><code>r1-r5</code>存放调用bpf helper函数的实参，bpf helper函数之后，应作为未初始寄存器对待。因此在调用bpf helper函数之前，需要将<code>r1-r5</code>转存到<code>r6-r9</code>或是bpf的堆栈。</li><li><code>r1</code>在bpf执行开始，会存储上下文变量（ctx），一般根据BPF程序的不同，ctx不同，比如tc/bpf中，ctx是<code>sk_buff</code>的指针。</li><li><code>r6-r9</code>在bpf helper执行前后数据不变，可用于存放需要保持的数据</li><li><code>r10</code>唯一只读的寄存器，存储着bpf的堆栈地址。</li></ul><p>BPF helper最多支持5个参数，在内核中BPF通过<code>BPF_CALL_0()</code>到<code>BPF_CALL_5()</code>进行声明。（注：后面数字表示参数数量，<code>include/uapi/linux/bpf.h</code>中有各个helper函数的注解）</p><p>BPF程序的指令数量最大限制在4096条，5.1版本的内核后，限制扩到100万个，但仍不允许存在循环，但可以前后跳转的指令，比如尾调<code>tail call</code>，尾调的上限为32层。</p><p>指令64位，目前有87条，格式（eBPF）如下，编码定义在<code>linux/bpf.h</code>下。</p><pre><code class="hljs apache"><span class="hljs-attribute">op</span>:<span class="hljs-number">8</span>, dst_reg:<span class="hljs-number">4</span>, src_reg:<span class="hljs-number">4</span>, <span class="hljs-literal">off</span>:<span class="hljs-number">16</span>, imm:<span class="hljs-number">32</span></code></pre><p><code>op</code>字段表明了操作是基于寄存器还是立即数，基于立即数的<code>op</code>，其目的操作数始终为寄存器。<code>off</code>为偏移量，<code>imm</code>为立即数，两者都是有符号类型。</p><p><code>OP</code>的结构为<code>code:4,source:1,class:3</code>，    <code>source</code>值：</p><ul><li><code>BPF_X</code>：基于寄存器的操作</li><li><code>BPF_K</code>：基于立即数的操作</li></ul><p><code>class</code>包括：</p><ul><li><code>BPF_LD</code>、<code>BPF_LDX</code>：<code>BPF_LD</code>是个特殊指令，用于double word的立即数加载，受限<code>imm:32</code>，会跨两个指令；<code>BPF_LD</code>也可以用于数据包的读取（注：会有一些使用约定，比如<code>r6</code>保存<code>sk_buff</code>的指针）。<code>BPF_LDX</code>从内存读取数据 ，内存可以是栈、map、数据包等。</li><li><code>BPF_ST</code>、<code>BPF_STX</code>：<code>BPF_STX</code>将寄存器中的数据存储到内存或者是bpf堆栈、bpf map等，<code>BPF_STX</code> 还可以做word和double-word的原子累加操作。<code>BPF_ST</code>与<code>BPF_STX</code>类似，但原数据只能是立即数。</li><li><code>BPF_ALU</code>、<code>BPF_ALU64</code>：<code>BPF_ALU</code>是32位操作，<code>BPF_ALU64</code>是64位操作，都支持 <code>+ - &amp; | &lt;&lt; &gt;&gt; ^ * / %  ~</code>。两者还包含特殊的ALU操作：mov（<code>&lt;X&gt;:=&lt;Y&gt;</code>），<code>BPF_ALU64</code>还包含一组有符号的右移操作，<code>BPF_ALU</code>包含字节顺序转换的指令。</li><li><code>BPF_JMP</code>：包括无条件与有条件跳转。跳转的下一指令为<code>off+1</code>，因为<code>off</code>为有符号类型，可以完成前跳，但不能产生循环或跳出程序范围。不同于cBPF（存在true或false两个偏移量），条件跳转机制为fall-through，更符合CPU的分支预测逻辑。另外包含三个特殊的跳转操作：退出指令<code>exit instruction</code>；用于调用helper方法的调用指令<code>call instruction</code>；用于调用其他BPF程序的尾调指令<code>tail call instruction</code>。</li></ul><p>目前下列架构都内置了内核 eBPF JIT 编译器：<code>x86_64</code>、<code>arm64</code>、<code>ppc64</code>、<code>s390x</code> 、<code>mips64</code>、<code>sparc64</code> 和 <code>arm</code>。</p><p>通过系统调用<code>bpf()</code>可以进行：</p><ul><li>创建、加载、卸载BPF程序</li><li>创建、操作BPF map</li><li>pinning BPF map和BPF程序到BPF文件系统中（做持久化）</li></ul><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p><strong>不同类型的BPF 程序能够使用的辅助函数不完全相同</strong>。</p><pre><code class="hljs apache"><span class="hljs-attribute">u64</span> fn(u<span class="hljs-number">64</span> r<span class="hljs-number">1</span>, u<span class="hljs-number">64</span> r<span class="hljs-number">2</span>, u<span class="hljs-number">64</span> r<span class="hljs-number">3</span>, u<span class="hljs-number">64</span> r<span class="hljs-number">4</span>, u<span class="hljs-number">64</span> r<span class="hljs-number">5</span>)</code></pre><p><strong>内核将辅助函数抽象为<code>BPF_CALL_0()</code>到<code>BPF_CALL_5()</code>几个宏</strong>，例如map update的调用（注：<code>BPF_CALL_4</code>表示4个参数，后面依次是参数类型，参数；<code>bpf_func_proto</code>给verifier进行调用的参数类型验证，另外<code>map-&gt;ops-&gt;map_update_elem</code>不同bpf map类型有不同的实现，在<code>kernel\bpf</code>下）：</p><pre><code class="hljs c">BPF_CALL_4(bpf_map_update_elem, struct bpf_map *, <span class="hljs-built_in">map</span>, <span class="hljs-keyword">void</span> *, key,           <span class="hljs-keyword">void</span> *, value, u64, flags)&#123;    WARN_ON_ONCE(!rcu_read_lock_held());    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="hljs-built_in">map</span>, key, value, flags);&#125;<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_func_proto</span> <span class="hljs-title">bpf_map_update_elem_proto</span> = &#123;</span>    .func           = bpf_map_update_elem,    .gpl_only       = <span class="hljs-literal">false</span>,    .ret_type       = RET_INTEGER,    .arg1_type      = ARG_CONST_MAP_PTR,    .arg2_type      = ARG_PTR_TO_MAP_KEY,    .arg3_type      = ARG_PTR_TO_MAP_VALUE,    .arg4_type      = ARG_ANYTHING,&#125;;</code></pre><ul><li>根据之前的约定（<code>r1-r5</code>传递参数），JIT只需要进行跳转，不需要进行寄存器的操作。</li><li>参数可以是任意类型，也可以是堆栈的指针。</li><li>内核<code>struct bpf_verifier_ops</code>包含回调函数<code>get_func_proto</code>，能根据BPF程序类型（<code>enum bpf_func_id</code>）来映射可用的BPF helper函数。</li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p><img src="/img/bpf-2021030101.png"></p><p>map驻留在内存中，可以通过用户空间的<strong>文件描述符</strong>访问，可以在任意BPF程序以及用户空间应用之间共享。共享map的BPF程序不需要是相同的程序类型，单个BPF程序最多可以访问64个map。</p><p>map有<code>per-CPU</code>以及<code>non-per-CPU</code>的通用map，另外还有提供给特定辅助函数的非通用map。通用map包括 <code>BPF_MAP_TYPE_HASH</code>, <code>BPF_MAP_TYPE_ARRAY</code>, <code>BPF_MAP_TYPE_PERCPU_HASH</code>, <code>BPF_MAP_TYPE_PERCPU_ARRAY</code>, <code>BPF_MAP_TYPE_LRU_HASH</code>, <code>BPF_MAP_TYPE_LRU_PERCPU_HASH</code> 和 <code>BPF_MAP_TYPE_LPM_TRIE</code>，他们都使用相同的一组BPF辅助函数来执行查找、更新或删除等。</p><p>非通用map包括 <code>BPF_MAP_TYPE_PROG_ARRAY</code>, <code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>, <code>BPF_MAP_TYPE_CGROUP_ARRAY</code>, <code>BPF_MAP_TYPE_STACK_TRACE</code>, <code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>, <code>BPF_MAP_TYPE_HASH_OF_MAPS</code>。例如 <code>BPF_MAP_TYPE_PROG_ARRAY</code>用于存储其他BPF程序，<code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>用于存储其他map的指针。这些map都是为了与bpf help一起完成特定功能。</p><h3 id="Object-Pinning"><a href="#Object-Pinning" class="headerlink" title="Object Pinning"></a>Object Pinning</h3><p><img src="/img/bpf-2021030102.png"></p><p>BPF maps和BPF程序只能通过文件描述符访问，后端是匿名inode。用户空间的程序可以利用大多数文件描述符的APIs进行操作。但同时，文件描述符被限制在程序的生命周期内，使得map共享之类操作难以实现（比如tc的ingress和egress BPF程序希望共享一个bpf  map，或是在BPF运行期间监视和更新BPF map）。</p><p>为克服此限制，实现了一个最小的内核空间的BPF文件系统，BPF map和BPF程序可以被Pin到此文件系统中。两个BPF系统调用<code>BPF_OBJ_PIN</code>和<code>BPF_OBJ_GET</code>分别用于pin操作和获取被pin的对象。</p><p>利用BPF文件系统，tc可以实现ingress和egress的map共享，BPF文件系统不是单例模式，支撑多挂载实例、硬链接、软链接等。</p><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p><img src="/img/bpf-2021030103.png"></p><p>尾调（tail calls）允许BPF程序调用其他BPF程序，但不再返回父程序。相比于通常的调用，尾调开销小，实现了远跳转（long jump），复用原来的栈帧（stack frame）（因为不用返回 ？）。</p><p>由于BPF程序是单独验证的，因此状态的传递要么是使用<code>per-cpu</code> map，或是对于tc程序 ，使用<code>skb</code>中的字段，例如<code>cb[]</code>（Controller buff）。</p><p>尾调只能在相同类型的BPF程序之间，尾调的程序要么都是通过JIT编译的，要么都是通过解释器执行的，不能混合。</p><p>尾调涉及两个组件：一个是程序map <code>BPF_MAP_TYPE_PROG_ARRAY</code>，可以由用户空间进行填充，其值为尾调的BPF程序的文件描述符；另一个是辅助函数<code>bpf_tail_call()</code>，传入的参数包括一个程序map的引用以及需要查询的key。然后内核将这个辅助函数内联（inlines）到专门的BPF指令中。目前，程序数组在用户空间只写。</p><p>内核根据传入的文件描述符查找相关的 BPF 程序，然后自动替换。如果没有map对应的value，内核会fall through ，继续执行 <code>bpf_tail_call()</code> 后面的指令。尾调可用来解析报文头。另外，在运行时，尾调函数可自动添加替换，从而实现BPF程序行为的改变。</p><h3 id="BPF到BPF的调用"><a href="#BPF到BPF的调用" class="headerlink" title="BPF到BPF的调用"></a>BPF到BPF的调用</h3><p><img src="/img/bpf-2021030104.png"></p><p>除了BPF辅助函数、BPF尾调函数外，还有一个特性：BPF to BFP calls。在引入此特性之前，BPF C程序使用<code>always_inline</code>声明方法，每次调用都进行内联，会增加代码的大小</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>   __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __inline</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __inline                         \</span>   <span class="hljs-keyword">inline</span> __attribute__((always_inline))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">static</span> __inline <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> XDP_DROP;&#125;__section(<span class="hljs-string">&quot;prog&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> foo();&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre><p>从内核4.16和LLVM6.0开始，不再需要使用<code>always_inline</code>：</p><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>   __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> XDP_DROP;&#125;__section(<span class="hljs-string">&quot;prog&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> foo();&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre><p>主流的BPF JIT都支持，例如<code>x86_64</code>和<code>arm64</code>。调用方式与BPF辅助函数类似，允许的最大嵌套调用为8。调用者可以将指针（比如指向堆栈的）向下传递给被调用者，但绝不能相反。</p><p>在内核5.9版本之前，BPF的尾调与子程序（BPF2BFP）是不兼容的，利用尾调的BPF程序无法减小应用image，无法加快加载。在内核5.10后，不再有此限制。但混合两个功能一起使用可能会导致内核栈溢出，下面是混合了BPF2BPF和尾调的情况：</p><p><img src="/img/bpf-2021030105.png"></p><p>尾调在跳到目标程序之前，只会回溯（unwind）它当前的栈。如上图所示，如果子函数（sub-function，图中subfunc1）中有尾调方法，那么在执行func2时（从subfunc1尾调过去），父函数func1的栈会保留在func2的栈中。一旦func3终止，之前所有的栈都会被回溯（unwind）。</p><p>内核引入如下机制：调用链中的每个子程序的栈大小不可超过256字节，当存在BPF2BPF时，主函数（调用BPF2BPF的函数）可被认为是子程序。根据这个限制，BPF程序最后的栈大小被限制在8KB（256*尾调上限32）。</p><p>当前，BPF尾调与BPF2BPF组合调用功能只在<code>x86_64</code>上支持。</p><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p><img src="/img/bpf-2021030106.png"></p><p>提供内核eBPF JIT编译器的架构包括：<code>x84_64</code>、<code>arm64</code>、<code>ppc64</code>、<code>s390x</code>、<code>mips64</code>、<code>sparc64</code>、32位的<code>arm</code>、<code>x86_32</code>。3开启JIT：</p><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_enable</code></pre><p>32位的<code>mips</code>,<code>ppc</code>和<code>sparc</code>只支持cBPF JIT，其他的架构不支持BPF JIT，需要使用内核的解释器。内核源代码中，通过grep <code>HAVE_EBPF_JIT</code>可以查询相应的支持。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> git grep HAVE_EBPF_JIT arch/</span>arch/arm/Kconfig:       select HAVE_EBPF_JIT   if !CPU_ENDIAN_BE32arch/arm64/Kconfig:     select HAVE_EBPF_JITarch/powerpc/Kconfig:   select HAVE_EBPF_JIT   if PPC64arch/mips/Kconfig:      select HAVE_EBPF_JIT   if (64BIT &amp;&amp; !CPU_MICROMIPS)arch/s390/Kconfig:      select HAVE_EBPF_JIT   if PACK_STACK &amp;&amp; HAVE_MARCH_Z196_FEATURESarch/sparc/Kconfig:     select HAVE_EBPF_JIT   if SPARC64arch/x86/Kconfig:       select HAVE_EBPF_JIT   if X86_64</code></pre><p>JIT编译器加快了BPF程序的执行速度，因为与解释器（interpreter）比起来，JIT降低了每条指令的执行成本。通常，指令可以与基础架构的原生指令有一对一的映射，这也减少了最终可执行映像（executable image）的大小，因此对CPU更加友好。</p><h3 id="加固（Hardening）"><a href="#加固（Hardening）" class="headerlink" title="加固（Hardening）"></a>加固（Hardening）</h3><p>为了避免代码被损坏，BPF的解释器image（<code>struct bpf_prog</code>）以及JIT编译器image（<code>struct bpf_binary_header</code>）在内核中是只读。支持设置只读的架构：</p><pre><code class="hljs gradle">$ git <span class="hljs-keyword">grep</span> ARCH_HAS_SET_MEMORY | <span class="hljs-keyword">grep</span> selectarch<span class="hljs-regexp">/arm/</span>Kconfig:    select ARCH_HAS_SET_MEMORYarch<span class="hljs-regexp">/arm64/</span>Kconfig:  select ARCH_HAS_SET_MEMORYarch<span class="hljs-regexp">/s390/</span>Kconfig:   select ARCH_HAS_SET_MEMORYarch<span class="hljs-regexp">/x86/</span>Kconfig:    select ARCH_HAS_SET_MEMORY</code></pre><p>其中<code>CONFIG_ARCH_HAS_SET_MEMORY</code>是不可配置的，总是开启的。<br>在<code>x86_64</code>中，开启<code>CONFIG_RETPOLINE</code>后，BGP的尾调通过<code>retpoline</code>实现间接跳转（retpoline是Google开发的针对Spectre变种2漏洞缓解利用技术），<code>CONFIG_RETPOLINE</code>默认是开启的。<br>当时设置<code>/proc/sys/net/core/bpf_jit_harden</code>为1时，对非特权用户的JIT编译会进行额外的加固过程，对性能有一定的影响，但仍比解释器要高。<br><strong>盲化</strong>：开启加固可以对BPF的32位和64位常量盲化（blind），防止JIT喷射攻击。</p><blockquote><p>JIT喷射攻击：攻击者利用包含立即数的脚本指令, 通过控制源程序将“常量” 作为立即数注入即时编译器的生成代码中(如指令 “XOR EAX 0x3c909090”), 然后通过一个控制流劫持漏洞跳转到“常量”的地址加一个偏移值, 此时“常量”就变成了可以被识别执行的代码片段。通过连续输入大量的常量就可以在代码缓存中生成攻击者需要的Shellcode。</p></blockquote><p>盲化的方式是通过两步将基于立即数的指令转化成基于寄存器的指令，比如load指令的盲化：1）将盲化后的<code>rnd^imm</code>立即数加载到寄存器；2）异或寄存器与<code>rnd</code>。<br>盲化关闭的程序：</p><pre><code class="hljs angelscript"># echo <span class="hljs-number">0</span> &gt; /proc/sys/net/core/bpf_jit_harden  ffffffffa034f5e9 + &lt;x&gt;:  [...]  <span class="hljs-number">39</span>:   mov    $<span class="hljs-number">0xa8909090</span>,%eax  <span class="hljs-number">3</span>e:   mov    $<span class="hljs-number">0xa8909090</span>,%eax  <span class="hljs-number">43</span>:   mov    $<span class="hljs-number">0xa8ff3148</span>,%eax  <span class="hljs-number">48</span>:   mov    $<span class="hljs-number">0xa89081b4</span>,%eax  <span class="hljs-number">4</span>d:   mov    $<span class="hljs-number">0xa8900bb0</span>,%eax  <span class="hljs-number">52</span>:   mov    $<span class="hljs-number">0xa810e0c1</span>,%eax  <span class="hljs-number">57</span>:   mov    $<span class="hljs-number">0xa8908eb4</span>,%eax  <span class="hljs-number">5</span>c:   mov    $<span class="hljs-number">0xa89020b0</span>,%eax  [...]</code></pre><p>在开启盲化后：</p><pre><code class="hljs perl"><span class="hljs-comment"># echo 1 &gt; /proc/sys/net/core/bpf_jit_harden</span>  ffffffffa034f1e5 + &lt;<span class="hljs-keyword">x</span>&gt;:  [...]  <span class="hljs-number">39</span>:   mov    $0xe1192563,%r10d  <span class="hljs-number">3</span>f:   <span class="hljs-keyword">xor</span>    $0x4989b5f3,%r10d  <span class="hljs-number">46</span>:   mov    %r10d,%eax  <span class="hljs-number">49</span>:   mov    $0xb8296d93,%r10d  <span class="hljs-number">4</span>f:   <span class="hljs-keyword">xor</span>    $0x10b9fd03,%r10d  <span class="hljs-number">56</span>:   mov    %r10d,%eax  <span class="hljs-number">59</span>:   mov    $0x8c381146,%r10d  <span class="hljs-number">5</span>f:   <span class="hljs-keyword">xor</span>    $0x24c7200e,%r10d  <span class="hljs-number">66</span>:   mov    %r10d,%eax  <span class="hljs-number">69</span>:   mov    $0xeb2a830e,%r10d  <span class="hljs-number">6</span>f:   <span class="hljs-keyword">xor</span>    $0x43ba02ba,%r10d  <span class="hljs-number">76</span>:   mov    %r10d,%eax  <span class="hljs-number">79</span>:   mov    $0xd9730af,%r10d  <span class="hljs-number">7</span>f:   <span class="hljs-keyword">xor</span>    $0xa5073b1f,%r10d  <span class="hljs-number">86</span>:   mov    %r10d,%eax  <span class="hljs-number">89</span>:   mov    $0x9a45662b,%r10d  <span class="hljs-number">8</span>f:   <span class="hljs-keyword">xor</span>    $0x325586ea,%r10d  <span class="hljs-number">96</span>:   mov    %r10d,%eax  [...]</code></pre><p>两个程序是一样的，只是第二个不再有立即数的操作（注：通过寄存器操作与异或代替）。</p><p><strong>JIT  kallsyms</strong>：除盲化外，开启加固后还会关闭JIT kallsyms，从而JIT image的地址不再会暴露在<code>/proc/kallsyms</code>中。</p><p><code>CONFIG_BPF_JIT_ALWAYS_ON</code>会总是开启JIT编译器，删除BPF解释器，也可用于Spectre变种2漏洞的缓解。在虚机的场景下，虚机内核不再复用主机内核的BPF解释器，以避免被攻击。在容器场景下，去除解释器可降低内核复杂度。因此这个属性通常建议开启。</p><p>最后<code>/proc/sys/kernel/unprivileged_bpf_disabled</code>可以禁止非特权用户进行<code>bpf()</code>系统调用，但此参数一旦设置，无法在更改，除非重启内核。开启后（设置为<code>1</code>），在初始命名空间外，只有<code>CAP_SYS_ADMIN</code>的特权进程才能调用。Cilium启动的时候会开启。</p><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/u</span>nprivileged_bpf_disabled</code></pre><h3 id="Offloads"><a href="#Offloads" class="headerlink" title="Offloads"></a>Offloads</h3><p><img src="/img/bpf_offload-2021032201.png"><br>BPF网络程序（tc、XDP）可以将程序offload到NIC上，通过NIC直接执行BPF程序。<br>Netronome的nfp驱动支持通过JIT编译器offload，即JIT会将BPF指令编译为NIC的指令（包括BPF map映射到NIC）。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>一般发行版会自带<code>iproute2</code>，除非需要测试或使用最新版本的BPF特性，则需要进行<code>iproute2</code>和内核的编译。</p><h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><p>BPF新开发的特性在<code>net-next</code>分支，而BPF最新的修正在<code>net</code>分支。克隆<code>net-next</code>分支：</p><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/</span>netdev/net-<span class="hljs-keyword">next</span>.git</code></pre><p>克隆<code>net</code>分支：</p><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/</span>netdev/net.git</code></pre><p><code>.config</code>的配置：</p><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_CGROUP_BPF</span>=y<span class="hljs-attr">CONFIG_BPF</span>=y<span class="hljs-attr">CONFIG_BPF_SYSCALL</span>=y<span class="hljs-attr">CONFIG_NET_SCH_INGRESS</span>=m<span class="hljs-attr">CONFIG_NET_CLS_BPF</span>=m<span class="hljs-attr">CONFIG_NET_CLS_ACT</span>=y<span class="hljs-attr">CONFIG_BPF_JIT</span>=y<span class="hljs-attr">CONFIG_LWTUNNEL_BPF</span>=y<span class="hljs-attr">CONFIG_HAVE_EBPF_JIT</span>=y<span class="hljs-attr">CONFIG_BPF_EVENTS</span>=y<span class="hljs-attr">CONFIG_TEST_BPF</span>=m</code></pre><p>有些条目无法通过<code>make menuconfig</code>选择，比如<code>CONFIG_HAVE_EBPF_JIT</code>（建议开启）在带有eBPF JIT的架构体系中自动选择。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证新内核的BPF功能：</p><pre><code class="hljs awk">$ cd tools<span class="hljs-regexp">/testing/</span>selftests<span class="hljs-regexp">/bpf/</span>$ make$ sudo ./test_verifierSummary: <span class="hljs-number">847</span> PASSED, <span class="hljs-number">0</span> SKIPPED, <span class="hljs-number">0</span> FAILED</code></pre><blockquote><p>对于4.16+以上的内核，BPF部分测试用例依赖LLVM 6.0+，提供无需inline的BPF2BPF功能，如果发行版无LLVM 6.0+，需要按照下面LLVM节中所述，编译LLVM。</p></blockquote><p>运行所有的BPF自检测试：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo make run_tests</span></code></pre><h4 id="编译iproute2"><a href="#编译iproute2" class="headerlink" title="编译iproute2"></a>编译iproute2</h4><p>与<code>net</code>和<code>net-next</code>类似，iproute2也分为<code>master</code>和<code>net-next</code>，并与内核的<code>net</code>和<code>net-next</code>相互对应。克隆<code>master</code>：</p><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/i</span>proute2/iproute2.git</code></pre><p>克隆<code>net-next</code>：</p><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/linux/</span>kernel<span class="hljs-regexp">/git/i</span>proute2/iproute2.git</code></pre><p>编译与安装：</p><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">cd</span> <span class="hljs-string">iproute2/</span><span class="hljs-string">$</span> <span class="hljs-string">./configure</span> <span class="hljs-string">--prefix=/usr</span><span class="hljs-string">TC</span> <span class="hljs-string">schedulers</span> <span class="hljs-string">ATM</span>    <span class="hljs-literal">no</span><span class="hljs-attr">libc has setns:</span> <span class="hljs-literal">yes</span><span class="hljs-attr">SELinux support:</span> <span class="hljs-literal">yes</span><span class="hljs-attr">ELF support:</span> <span class="hljs-literal">yes</span><span class="hljs-attr">libmnl support:</span> <span class="hljs-literal">no</span><span class="hljs-attr">Berkeley DB:</span> <span class="hljs-literal">no</span><span class="hljs-attr">docs: latex:</span> <span class="hljs-literal">no</span> <span class="hljs-attr">WARNING:</span> <span class="hljs-literal">no</span> <span class="hljs-string">docs</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">built</span> <span class="hljs-string">from</span> <span class="hljs-string">LaTeX</span> <span class="hljs-string">files</span> <span class="hljs-attr">sgml2html:</span> <span class="hljs-literal">no</span> <span class="hljs-attr">WARNING:</span> <span class="hljs-literal">no</span> <span class="hljs-string">HTML</span> <span class="hljs-string">docs</span> <span class="hljs-string">can</span> <span class="hljs-string">be</span> <span class="hljs-string">built</span> <span class="hljs-string">from</span> <span class="hljs-string">SGML</span><span class="hljs-string">$</span> <span class="hljs-string">make</span>[<span class="hljs-string">...</span>]<span class="hljs-string">$</span> <span class="hljs-string">sudo</span> <span class="hljs-string">make</span> <span class="hljs-string">install</span></code></pre><p>确保<code>configure</code>脚本显示<code>ELF support: yes</code>，以便iproute2可以处理LLVM后端的ELF文件。</p><h4 id="编译bpftool"><a href="#编译bpftool" class="headerlink" title="编译bpftool"></a>编译bpftool</h4><p>bpftool用于debug bpf程序与bpf map的工具，在内核的<code>tools/bpf/bpftool</code>下。</p><pre><code class="hljs routeros">$ cd &lt;kernel-tree&gt;/tools/bpf/bpftool/$ makeAuto-detecting<span class="hljs-built_in"> system </span>features:<span class="hljs-built_in">..</span>.                        libbfd: [ on  ]<span class="hljs-built_in">..</span>.        disassembler-four-args: [ OFF ]  CC       xlated_dumper.o  CC       prog.o  CC       common.o  CC       cgroup.o  CC       main.o  CC       json_writer.o  CC       cfg.o  CC       map.o  CC       jit_disasm.o  CC       disasm.omake[1]: Entering directory <span class="hljs-string">&#x27;/home/foo/trees/net/tools/lib/bpf&#x27;</span>Auto-detecting<span class="hljs-built_in"> system </span>features:<span class="hljs-built_in">..</span>.                        libelf: [ on  ]<span class="hljs-built_in">..</span>.                           bpf: [ on  ]  CC       libbpf.o  CC       bpf.o  CC       nlattr.o  LD       libbpf-in.o  LINK     libbpf.amake[1]: Leaving directory <span class="hljs-string">&#x27;/home/foo/trees/bpf/tools/lib/bpf&#x27;</span>  LINK     bpftool$ sudo make install</code></pre><h3 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h3><p>LLVM是当前唯一提供BPF编译后端的套件，gcc不支持。<br>LLVM 3.7加入BPF后端，一般默认开启，因此在安装clang和LLVM后就可以将C语言编译为BPF对象文件了。<br>典型的工作流程：</p><ul><li>编写C语言文件</li><li>LLVM编译为obj文件或ELF文件</li><li>用户空间的loader工具（iproute2）通过<code>bpf()</code>系统调用加载BPF到内核</li><li>内核验证BPF程序</li><li>JIT编译为本机指令，并新建文件描述符，用于挂载到子系统中(e.g. networking)</li><li>如果支持，子系统进一步将BPF程序offload到NIC上。</li></ul><p>检测LLVM是否支持BPF（llc是LLVM编译器，输入LLVM IR，输出汇编文件或者是目标文件）：</p><pre><code class="hljs properties"><span class="hljs-meta">$</span> <span class="hljs-string">llc --version</span><span class="hljs-attr">LLVM</span> <span class="hljs-string">(http://llvm.org/):</span><span class="hljs-attr">LLVM</span> <span class="hljs-string">version 3.8.1</span><span class="hljs-attr">Optimized</span> <span class="hljs-string">build.</span><span class="hljs-attr">Default</span> <span class="hljs-string">target: x86_64-unknown-linux-gnu</span><span class="hljs-attr">Host</span> <span class="hljs-string">CPU: skylake</span><span class="hljs-attr">Registered</span> <span class="hljs-string">Targets:</span>  <span class="hljs-attr">[...]</span>  <span class="hljs-attr">bpf</span>        <span class="hljs-string">- BPF (host endian)</span>  <span class="hljs-attr">bpfeb</span>      <span class="hljs-string">- BPF (big endian)</span>  <span class="hljs-attr">bpfel</span>      <span class="hljs-string">- BPF (little endian)</span>  <span class="hljs-attr">[...]</span></code></pre><p>默认情况，<code>bpf</code>类型的target是和CPU的字节序一致的。可以通过<code>bpfeb</code>和<code>bpfel</code>进行交叉编译，在大端机器上编译小端的BPF程序，在小端机器上运行。需要注意前端clang也需要运行在相同的字节序上。</p><p>一个XDP drop程序样例（<code>xdp-example.c</code>）：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>   __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>__section(<span class="hljs-string">&quot;prog&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> XDP_DROP;&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre><p>编译并加载到内核：</p><pre><code class="hljs gams"><span class="hljs-symbol">$</span> clang -O2 -Wall -target bpf -c xdp-example.c -o xdp-example.o# ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp obj xdp-example.o</span></code></pre><blockquote><p>加载XDP程序到网络设备，需要linux 4.11版本以及对应的device支持，或是linux 4.12以上的版本。</p></blockquote><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">file</span> <span class="hljs-string">xdp-example.o</span><span class="hljs-attr">xdp-example.o:</span> <span class="hljs-string">ELF</span> <span class="hljs-number">64</span><span class="hljs-string">-bit</span> <span class="hljs-string">LSB</span> <span class="hljs-string">relocatable,</span> <span class="hljs-string">*unknown</span> <span class="hljs-string">arch</span> <span class="hljs-number">0xf7</span><span class="hljs-string">*</span> <span class="hljs-string">version</span> <span class="hljs-number">1</span> <span class="hljs-string">(SYSV),</span> <span class="hljs-string">not</span> <span class="hljs-string">stripped</span></code></pre><p><code>0xf7</code>表示官方BPF机器值<code>EM_BPF</code>，十进制<code>247</code>。<code>LSB</code>表示小端字节序。通过<code>readelf -a xdp-example.o</code>命令可以看到更多的ELF文件信息，比如section头、重定向条目、symbol表。</p><h4 id="编译安装LLVM"><a href="#编译安装LLVM" class="headerlink" title="编译安装LLVM"></a>编译安装LLVM</h4><p>少数情况下可能需要编译安装clang和LLVM：</p><pre><code class="hljs sql">$ git clone https://git.llvm.org/git/llvm.git$ cd llvm/tools$ git clone <span class="hljs-comment">--depth 1 https://git.llvm.org/git/clang.git</span>$ cd ..; mkdir build; cd build$ cmake .. -DLLVM_TARGETS_TO_BUILD=&quot;BPF;X86&quot; -DBUILD_SHARED_LIBS=OFF -DCMAKE_BUILD_TYPE=<span class="hljs-keyword">Release</span> -DLLVM_BUILD_RUNTIME=<span class="hljs-keyword">OFF</span>$ make -j $(getconf _NPROCESSORS_ONLN)$ ./<span class="hljs-keyword">bin</span>/llc <span class="hljs-comment">--version</span>LLVM (<span class="hljs-keyword">http</span>://llvm.org/):LLVM <span class="hljs-keyword">version</span> x.y.zsvnOptimized build.<span class="hljs-keyword">Default</span> target: x86_64-<span class="hljs-literal">unknown</span>-linux-gnuHost CPU: skylakeRegistered Targets:  bpf    - BPF (host <span class="hljs-keyword">endian</span>)  bpfeb  - BPF (<span class="hljs-keyword">big</span> <span class="hljs-keyword">endian</span>)  bpfel  - BPF (<span class="hljs-keyword">little</span> <span class="hljs-keyword">endian</span>)  x86    - <span class="hljs-number">32</span>-<span class="hljs-built_in">bit</span> X86: Pentium-Pro <span class="hljs-keyword">and</span> above  x86<span class="hljs-number">-64</span> - <span class="hljs-number">64</span>-<span class="hljs-built_in">bit</span> X86: EM64T <span class="hljs-keyword">and</span> AMD64$ <span class="hljs-keyword">export</span> <span class="hljs-keyword">PATH</span>=$PWD/<span class="hljs-keyword">bin</span>:$<span class="hljs-keyword">PATH</span>   <span class="hljs-comment"># add to ~/.bashrc</span></code></pre><p>确保<code>--version</code>中会有<code>Optimized build</code>，否则当以debug模式编译时，编译的时间会大大增加。</p><h4 id="汇编输出"><a href="#汇编输出" class="headerlink" title="汇编输出"></a>汇编输出</h4><p>为了调试，clang可以直接产生汇编输出（通过<code>-S</code>）：</p><pre><code class="hljs awk">$ clang -O2 -S -Wall -target bpf -c xdp-example.c -o xdp-example.S$ cat xdp-example.S    .text    .section    prog,<span class="hljs-string">&quot;ax&quot;</span>,@progbits    .globl      xdp_drop    .p2align    <span class="hljs-number">3</span>xdp_drop:                             <span class="hljs-comment"># @xdp_drop</span><span class="hljs-comment"># BB#0:</span>    r0 = <span class="hljs-number">1</span>    <span class="hljs-keyword">exit</span>    .section    license,<span class="hljs-string">&quot;aw&quot;</span>,@progbits    .globl    __license               <span class="hljs-comment"># @__license</span>__license:    .asciz    <span class="hljs-string">&quot;GPL&quot;</span></code></pre><p>从LLVM 6.0开始，提供了BPF汇编解释器，通过<code>llvm-mc</code>将上面的汇编输出编译为obj文件。</p><pre><code class="hljs elm"><span class="hljs-title">llvm</span>-mc -triple bpf -file<span class="hljs-keyword">type</span>=obj -o xdp-example.o xdp-example.<span class="hljs-type">S</span></code></pre><h4 id="输出DWARF"><a href="#输出DWARF" class="headerlink" title="输出DWARF"></a>输出DWARF</h4><p>在LLVM 4.0版本开始，可以通过<code>-g</code>将debug信息以dwarf的格式编译到obj文件中。然后使用<code>llvm-objdump</code>查看汇编以及对应的C语言的注释。其中编号<code>0</code>和<code>1</code>是与内核验证器的日志输出一致的，因此当未被内核的验证器通过时，可以通过<code>llvm-objdump</code>查看具体报错的C语言代码。</p><pre><code class="hljs awk">$ clang -O2 -g -Wall -target bpf -c xdp-example.c -o xdp-example.o$ llvm-objdump -S -no-show-raw-insn xdp-example.oxdp-example.o:        file format ELF64-BPFDisassembly of section prog:xdp_drop:; &#123;    <span class="hljs-number">0</span>:        r0 = <span class="hljs-number">1</span>; return XDP_DROP;    <span class="hljs-number">1</span>:        <span class="hljs-keyword">exit</span></code></pre><pre><code class="hljs routeros">\#<span class="hljs-built_in"> ip </span>link <span class="hljs-builtin-name">set</span> dev em1 xdp obj xdp-example.o verbProg section <span class="hljs-string">&#x27;prog&#x27;</span> loaded (5)! - Type:         6 - Instructions: 2 (0 over limit) - License:      GPLVerifier analysis:0: (b7) r0 = 11: (95) exitprocessed 2 insns</code></pre><p>如果不加<code>-no-show-raw-insn</code>，<code>llvm-objdump</code>还会将<code>struct bpf_insn</code>（BPF指令）以十六进制的形式显示。</p><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">llvm-objdump</span> <span class="hljs-string">-S</span> <span class="hljs-string">xdp-example.o</span><span class="hljs-attr">xdp-example.o:</span>        <span class="hljs-string">file</span> <span class="hljs-string">format</span> <span class="hljs-string">ELF64-BPF</span><span class="hljs-attr">Disassembly of section prog:</span><span class="hljs-attr">xdp_drop:</span><span class="hljs-string">;</span> &#123;   <span class="hljs-attr">0:</span>       <span class="hljs-string">b7</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>     <span class="hljs-string">r0</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span> <span class="hljs-string">return</span> <span class="hljs-string">foo();</span>   <span class="hljs-attr">1:</span>       <span class="hljs-number">95</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>     <span class="hljs-string">exit</span></code></pre><h4 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h4><p>生成LLVM IR文件用于调试，并进一步通过LLVM IR文件生成obj文件：</p><pre><code class="hljs mipsasm">$ clang -O2 -Wall -target <span class="hljs-keyword">bpf </span>-emit-<span class="hljs-keyword">llvm </span>-c xdp-example.c -o xdp-example.<span class="hljs-keyword">bc</span><span class="hljs-keyword">$ </span><span class="hljs-keyword">llc </span>xdp-example.<span class="hljs-keyword">bc </span>-march=<span class="hljs-keyword">bpf </span>-filetype=obj -o xdp-example.o</code></pre><p>生成的LLVM IR还能转存为人类可读的格式：</p><pre><code class="hljs llvm">clang -O<span class="hljs-number">2</span> -Wall -emit-llvm -S -<span class="hljs-keyword">c</span> xdp-example.<span class="hljs-keyword">c</span> -o -</code></pre><h4 id="BTF"><a href="#BTF" class="headerlink" title="BTF"></a>BTF</h4><p>除了默认的debug格式DWARF外，BPF还有提供BTF（BPF Type Format）。DWARF能转换成BTF，BTF通过BPF loader工具加载到内核，验证器可以验证BTF的正确性，并追踪BTF中的结构体。<br>将BPF map中的key、value类型的注释（annotate）到BTF中，dump时会同时显示map的类型。BTF是一个通用的debug格式，任意DWARF都可以转换为BTF，比如内核的vmlinux DWARF。<br>BTF与DWARF格式的转换，由于libdw（注：“libdw1 provides a library that provides access to DWARF debug information stored inside ELF files.”）不支持BPF的重定位，因此<code>pahole</code>（注：“<strong>pahole</strong> shows data structure layouts encoded in debugging information formats, DWARF and CTF being supported.”）类似的工具无法正常使用，解决方法包括：</p><ul><li>使用elfutils(&gt;=0.173)，elfutils实现了适当的BPF重定位支持。</li><li><code>llc</code>添加<code>-mattr=dwarfris</code>参数，以关闭DWARF与ELF符号表之间的跨section重定位。<pre><code class="hljs routeros">$ llc <span class="hljs-attribute">-march</span>=bpf <span class="hljs-attribute">-mattr</span>=help |&amp; grep dwarfris  dwarfris - <span class="hljs-builtin-name">Disable</span> MCAsmInfo DwarfUsesRelocationsAcrossSections.  [<span class="hljs-built_in">..</span>.]</code></pre></li></ul><p><code>pahole</code>依赖LLVM输出的DWARF信息，后续将利用BTF信息。将DWARF转换为BTF，需要<code>pahole</code>&gt;=1.12：</p><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>t.kernel.org<span class="hljs-regexp">/pub/</span>scm<span class="hljs-regexp">/devel/</span>pahole/pahole.git</code></pre><p><code>pahole</code>通过<code>-J</code>将DWARF转换为BTF，查看<code>pahole</code>是否支持转换（<code>pahole</code>还依赖<code>llvm-objcopy</code>工具）</p><pre><code class="hljs stata">$ pahole --<span class="hljs-keyword">help</span> | grep BTF-J, --btf_encode           <span class="hljs-keyword">Encode</span> <span class="hljs-keyword">as</span> BTF</code></pre><p>如上面介绍的，debug信息的生成了依赖前端<code>clang</code>的<code>-g</code>选项，比如下面使用<code>-mattr=dwarfris</code>的方式：</p><pre><code class="hljs mipsasm">$ clang -O2 -g -Wall -target <span class="hljs-keyword">bpf </span>-emit-<span class="hljs-keyword">llvm </span>-c xdp-example.c -o xdp-example.<span class="hljs-keyword">bc</span><span class="hljs-keyword">$ </span><span class="hljs-keyword">llc </span>xdp-example.<span class="hljs-keyword">bc </span>-march=<span class="hljs-keyword">bpf </span>-mattr=dwarfris -filetype=obj -o xdp-example.o</code></pre><p>或者也可以直接使用clang生成带有debug信息的obj文件。</p><pre><code class="hljs llvm">clang -<span class="hljs-keyword">target</span> bpf -O<span class="hljs-number">2</span> -g -<span class="hljs-keyword">c</span> -Xclang -<span class="hljs-keyword">target</span>-feature -Xclang +dwarfris -<span class="hljs-keyword">c</span> xdp-example.<span class="hljs-keyword">c</span> -o xdp-example.o</code></pre><p>使用<code>pahole</code>从DWARF信息中dump出上面BPF程序的数据结构：</p><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">pahole</span> <span class="hljs-string">xdp-example.o</span><span class="hljs-string">struct</span> <span class="hljs-string">xdp_md</span> &#123;        <span class="hljs-string">__u32</span>                      <span class="hljs-string">data;</span>                 <span class="hljs-string">/*</span>     <span class="hljs-number">0</span>     <span class="hljs-number">4</span> <span class="hljs-string">*/</span>        <span class="hljs-string">__u32</span>                      <span class="hljs-string">data_end;</span>             <span class="hljs-string">/*</span>     <span class="hljs-number">4</span>     <span class="hljs-number">4</span> <span class="hljs-string">*/</span>        <span class="hljs-string">__u32</span>                      <span class="hljs-string">data_meta;</span>            <span class="hljs-string">/*</span>     <span class="hljs-number">8</span>     <span class="hljs-number">4</span> <span class="hljs-string">*/</span>        <span class="hljs-string">/*</span> <span class="hljs-attr">size:</span> <span class="hljs-number">12</span>, <span class="hljs-attr">cachelines:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">members:</span> <span class="hljs-number">3</span> <span class="hljs-string">*/</span>        <span class="hljs-string">/*</span> <span class="hljs-attr">last cacheline:</span> <span class="hljs-number">12</span> <span class="hljs-string">bytes</span> <span class="hljs-string">*/</span>&#125;<span class="hljs-string">;</span></code></pre><p><code>pahole -J</code>可以将DWARF数据转换为BTF，但最终的obj文件里仍会同时包含DWARF与BTF两种数据。</p><pre><code class="hljs llvm">$ clang -<span class="hljs-keyword">target</span> bpf -O<span class="hljs-number">2</span> -Wall -g -<span class="hljs-keyword">c</span> -Xclang -<span class="hljs-keyword">target</span>-feature -Xclang +dwarfris -<span class="hljs-keyword">c</span> xdp-example.<span class="hljs-keyword">c</span> -o xdp-example.o$ pahole -J xdp-example.o</code></pre><p>通过<code>readelf</code>工具可以看到<code>.BTF</code>section。</p><pre><code class="hljs angelscript">$ readelf -a xdp-example.o[...]  [<span class="hljs-number">18</span>] .BTF              PROGBITS         <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000671</span>[...]</code></pre><h4 id="指令集版本"><a href="#指令集版本" class="headerlink" title="指令集版本"></a>指令集版本</h4><p>默认情况，LLVM为了兼容低版本内核 ，会使用BPF基础指令集进行编译。但是也可以通过LLVM的<code>-mcpu</code>来选择指令集的版本。<code>-mcpu</code>可用于交叉编译的场景。</p><pre><code class="hljs fortran">$ llc -march bpf -mcpu=helpAvailable CPUs for this <span class="hljs-keyword">target</span>:  <span class="hljs-keyword">generic</span> - <span class="hljs-keyword">Select</span> the <span class="hljs-keyword">generic</span> processor<span class="hljs-number">.</span>  probe   - <span class="hljs-keyword">Select</span> the probe processor<span class="hljs-number">.</span>  v1      - <span class="hljs-keyword">Select</span> the v1 processor<span class="hljs-number">.</span>  v2      - <span class="hljs-keyword">Select</span> the v2 processor<span class="hljs-number">.</span>[<span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span>]</code></pre><p><code>generic</code>是默认的选项，是v1版本的BPF基础指令集。<code>probe</code>（cilium使用）会自动探测内核可用的BPF指令集。完整的是使用样例：</p><pre><code class="hljs mipsasm">$ clang -O2 -Wall -target <span class="hljs-keyword">bpf </span>-emit-<span class="hljs-keyword">llvm </span>-c xdp-example.c -o xdp-example.<span class="hljs-keyword">bc</span><span class="hljs-keyword">$ </span><span class="hljs-keyword">llc </span>xdp-example.<span class="hljs-keyword">bc </span>-march=<span class="hljs-keyword">bpf </span>-mcpu=probe -filetype=obj -o xdp-example.o</code></pre><h4 id="clang-target（64位-32位）"><a href="#clang-target（64位-32位）" class="headerlink" title="clang target（64位/32位）"></a>clang target（64位/32位）</h4><p>使用<code>clang -target bpf</code>和不使用<code>-target bpf</code>而使用默认的target，在不同的系统架构下有些不同的细微差别。<br>引用内核的<code>Documentation/bpf/bpf_devel_QA.txt</code>：</p><ul><li>BPF可以递归引用（include）头文件，在文件范围内内联汇编代码。 默认target可以很好的处理这种情况，但target bpf大多数情况下无法正确处理。</li><li>如果没有加<code>-g</code>参数，对于编译后是否会产生额外的elf sections，默认target可能会生成，但target bpf不会。</li><li>对于C语言中的<code>switch</code>，默认target会生成switch表和跳转操作。但switch表在全局只读section中，bpf程序是无法读取的，因此target bpf不支持这种使用switch表的优化方式。clang可以通过<code>-fno-jump-tables</code>关闭switch表的生成。</li><li>无论底层clang的版本和内核的版本（32位或64位），target bpf总是会保证指针、long 、unsigned long类型是64位的。但默认target是根据底层系统架构来的。</li></ul><p>默认target（例如x86_64的架构上选择<code>x86_64</code>的target）在追踪内核的<code>struct pt_regs</code>结构或其他与寄存器宽带有关的内核结构时有用，<code>struct pt_regs</code>结构用于映射cpu寄存器。但在其他情况下，比如网络的应用场景，建议使用<code>target bpf</code>。<br>LLVM从7.0开始也支持32位的子寄存器和BPF ALU32，需要开启<code>alu32</code>参数，开启后，LLVM会总是尝试使用32位的子寄存器以及BPF ALU32。</p><pre><code class="hljs arduino">$ cat <span class="hljs-number">32</span>-<span class="hljs-built_in">bit</span>-example.c    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *b, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *c)</span></span><span class="hljs-function">    </span>&#123;      <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sum = *a + *b;      *c = sum;    &#125;</code></pre><p>默认情况下的汇编：</p><pre><code class="hljs awk">$ clang -target bpf -emit-llvm -S <span class="hljs-number">32</span>-bit-example.c$ llc -march=bpf <span class="hljs-number">32</span>-bit-example.ll$ cat <span class="hljs-number">32</span>-bit-example.s    cal:      r1 = *(u32 *)(r1 + <span class="hljs-number">0</span>)      r2 = *(u32 *)(r2 + <span class="hljs-number">0</span>)      r2 += r1      *(u32 *)(r3 + <span class="hljs-number">0</span>) = r2      <span class="hljs-keyword">exit</span></code></pre><p>开启<code>-mattr=+alu32</code>后：</p><pre><code class="hljs awk">$ llc -march=bpf -mattr=+alu32 <span class="hljs-number">32</span>-bit-example.ll$ cat <span class="hljs-number">32</span>-bit-example.s    cal:      w1 = *(u32 *)(r1 + <span class="hljs-number">0</span>)      w2 = *(u32 *)(r2 + <span class="hljs-number">0</span>)      w2 += w1      *(u32 *)(r3 + <span class="hljs-number">0</span>) = w2      <span class="hljs-keyword">exit</span></code></pre><p>上面<code>w</code>表示32位的子寄存器，<code>r</code>表示64位的寄存器。<br>开启32位子寄存器可以减少类型扩展指令。对于32架构上的eBPF JIT编译器来说，会将一对寄存器作为64位的BPF寄存器使用，因此需要额外的指令去操作高位的32位寄存器。使用32位指令后，可以保证读取时，只操作低位的32位寄存器。但写时，仍需要将高位的32位寄存器清零。如果JIT编译器能知道逻辑上一个寄存器的定义就是指32位寄存器，那么高位的子寄存器操作就可以省略。</p><h4 id="C语言开发注意事项"><a href="#C语言开发注意事项" class="headerlink" title="C语言开发注意事项"></a>C语言开发注意事项</h4><p>使用C语言开发BPF与通常的C语言开发不太一样，需要注意：<br>1）<strong>在旧版本的LLVM中不只支持函数调用以及共享库，因此所有方法都需要进行内联</strong>。<br>共享库是无法与BPF一起使用的，但对于一般的库来说，可以通过先放到头文件中，然后再引用到程序中的方式进行使用。比如Cilium大量使用了此方式（<code>bpf/lib/</code>）。也可以直接引用头文件（比如内核或其他库的头文件），然后使用其中内联的方法或者是宏定义。<br>对于内核（4.16+）和LLVM（6.0+）来说，支持BPF2BPF，因此无需内联。其他情况下需要内联，在内联时推荐使用<code>always_inline</code>方式，因为对于<code>inline</code>属性，编译器仍能决定不进行内联。一旦编译器未进行内联，LLVM就会生成带有重定位项（relocation entry）的elf文件，BPF loaders（例如iproute2）只能识别处理BPF maps的重定位，因此会报错。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>   __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __inline</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __inline                         \</span>   <span class="hljs-keyword">inline</span> __attribute__((always_inline))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">static</span> __inline <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> XDP_DROP;&#125;__section(<span class="hljs-string">&quot;prog&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> foo();&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre><p>2）<strong>不同的程序可以在一个C文件的不同section中</strong>。<br>C语言编写的BPF程序中使用大量的section注释，BPF ELF loader会根据section的名称来加载相应的BPF程序和maps。比如iproute2默认使用<code>maps</code>和<code>license</code>作为section的名称，来查询BPF maps以及BPF程序的license信息。BPF程序启用部分helper函数，需要持有GPL兼容license，例如<code>bpf_ktime_get_ns()</code>，<code>bpf_probe_read()</code>。<br>下面的tc程序用于计数ingress和egress的流量，可以加载到某个网卡上 。程序定义了<code>ingress</code>和<code>egress</code>两个section，同时通过内联方式调用<code>account_data()</code>，通过<code>maps</code> section来利用bpf maps。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/pkt_cls.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iproute2/bpf_elf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>   __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __inline</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __inline                         \</span>   <span class="hljs-keyword">inline</span> __attribute__((always_inline))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> lock_xadd</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> lock_xadd(ptr, val)              \</span>   ((<span class="hljs-keyword">void</span>)__sync_fetch_and_add(ptr, val))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BPF_FUNC</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> BPF_FUNC(NAME, ...)              \</span>   (*NAME)(__VA_ARGS__) = (<span class="hljs-keyword">void</span> *)BPF_FUNC_##NAME#endif<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *BPF_FUNC(map_lookup_elem, <span class="hljs-keyword">void</span> *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_elf_map</span> <span class="hljs-title">acc_map</span> __<span class="hljs-title">section</span>(&quot;<span class="hljs-title">maps</span>&quot;) = &#123;</span>    .type           = BPF_MAP_TYPE_ARRAY,    .size_key       = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>),    .size_value     = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>),    .pinning        = PIN_GLOBAL_NS,    .max_elem       = <span class="hljs-number">2</span>,&#125;;<span class="hljs-function"><span class="hljs-keyword">static</span> __inline <span class="hljs-keyword">int</span> <span class="hljs-title">account_data</span><span class="hljs-params">(struct __sk_buff *skb, <span class="hljs-keyword">uint32_t</span> dir)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">uint32_t</span> *bytes;    bytes = map_lookup_elem(&amp;acc_map, &amp;dir);    <span class="hljs-keyword">if</span> (bytes)            lock_xadd(bytes, skb-&gt;len);    <span class="hljs-keyword">return</span> TC_ACT_OK;&#125;__section(<span class="hljs-string">&quot;ingress&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tc_ingress</span><span class="hljs-params">(struct __sk_buff *skb)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> account_data(skb, <span class="hljs-number">0</span>);&#125;__section(<span class="hljs-string">&quot;egress&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tc_egress</span><span class="hljs-params">(struct __sk_buff *skb)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> account_data(skb, <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre><ul><li>上面程序引用了一些头文件，包括内核头文件、C语言标准头文件、iproute2头文件，其中iproute2头文件中定义了<code>struct bpf_elf_map</code>，用于创建BPF map。你可以用<code>struct bpf_elf_map</code>创建多个不同名称的同类型map，但需要都在<code>__section(&quot;maps&quot;)</code>下。另外不同的BPF ELF loader中也有不同的map定义结构，比如libbpf就和iproute2的<code>struct bpf_elf_map</code>不同。</li><li><code>map_lookup_elem()</code>对应<code>BPF_FUNC_map_lookup_elem</code>的helper函数，定义在<code>uapi/linux/bpf.h</code>里。</li><li>因为定义的map是全局的，因此需要使用原子操作。在程序中使用的是<code>lock_xadd()</code>，LLVM将<code>__sync_fetch_and_add()</code>作为BPF原子加的内置函数，对应的指令为<code>BPF_STX | BPF_XADD | BPF_W</code>。</li><li><code>.pinning = PIN_GLOBAL_NS,</code>表示将map pin到BPF的文件系统中，默认情况下，路径为<code>/sys/fs/bpf/tc/globals/acc_map</code>，由于是global，表明各个obj文件都能对其进行访问。比如多个BPF程序都定义了相同（名字和属性都相同）的<code>acc_map</code> bpf map，同时都使用了 <code>PIN_GLOBAL_NS</code>，那么多个BPF程序都会共享这个map。上面的<code>ingress</code>启动后会查询是否存在<code>acc_map</code>对应的文件系统，没有则创建。在<code>egress</code>启动时，则直接使用。</li><li>除了<code>PIN_GLOBAL_NS</code>外，还有<code>PIN_OBJECT_NS</code>，将会创建object对应的目录，将map放在其下。<code>PIN_NONE</code>表示不pin到文件系统中，那么tc结束后，map将不能被从用户空间进行访问，同时程序中的ingress和egress使用的将是两个map。</li><li>可以通过bpf系统调用中的<code>BPF_OBJ_GET</code>来创建指向相同的map的文件描述符，通过这个文件描述符可以对map进行lookup/update/delete的操作。</li></ul><pre><code class="hljs routeros">$ clang -O2 -Wall -target bpf -c tc-example.c -o tc-example.o<span class="hljs-comment"># tc qdisc add dev em1 clsact</span><span class="hljs-comment"># tc filter add dev em1 ingress bpf da obj tc-example.o sec ingress</span><span class="hljs-comment"># tc filter add dev em1 egress bpf da obj tc-example.o sec egress</span><span class="hljs-comment"># tc filter show dev em1 ingress</span>filter protocol all pref 49152 bpffilter protocol all pref 49152 bpf handle 0x1 tc-example.o:[ingress] direct-action id 1 tag c5f7825e5dac396f<span class="hljs-comment"># tc filter show dev em1 egress</span>filter protocol all pref 49152 bpffilter protocol all pref 49152 bpf handle 0x1 tc-example.o:[egress] direct-action id 2 tag b2fd5adc0f262714<span class="hljs-comment"># mount | grep bpf</span>sysfs on /sys/fs/bpf<span class="hljs-built_in"> type </span>sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)bpf on /sys/fs/bpf<span class="hljs-built_in"> type </span>bpf (rw,relatime,<span class="hljs-attribute">mode</span>=0700)<span class="hljs-comment"># tree /sys/fs/bpf/</span>/sys/fs/bpf/+--<span class="hljs-built_in"> ip </span>-&gt; /sys/fs/bpf/tc/+-- tc|   +-- globals|       +-- acc_map+-- xdp -&gt; /sys/fs/bpf/tc/4 directories, 1 file</code></pre><p>3）<strong>不允许有全局的变量</strong><br>BPF不允许有全局的变量，但可以通过只包含一个值的<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>来替代，因为BPF能确保不会被抢占。可以用于尾调或堆栈限制的扩充。<br>一般，不同BPF程序之间共享状态使用常规BPF map即可。</p><p>4）<strong>不支持const的字符串和数组</strong><br>同样是由于loader不支持重定位导致。可通过<code>trace_printk()</code>helper函数解决 。</p><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BPF_FUNC</span>(<span class="hljs-params">trace_printk, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fmt, <span class="hljs-keyword">int</span> fmt_size, ...</span>)</span>;<span class="hljs-meta">#ifndef printk</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> printk(fmt, ...)                                      \</span>    (&#123;                                                         \        <span class="hljs-keyword">char</span> ____fmt[] = fmt;                                  \        trace_printk(____fmt, <span class="hljs-keyword">sizeof</span>(____fmt), <span class="hljs-meta">##__VA_ARGS__); \</span>    &#125;)<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>上面程序可以通过<code>printk(&quot;skb len:%u\n&quot;, skb-&gt;len);</code>来使用宏，使用<code>tc exec bpf dbg</code>来输出。但<code>track_printk()</code>不推荐生产环境使用：一是由于helper函数最多5个参数，因此<code>track_printk()</code>可输出的信息只能传递三个参数；二是<code>skb len:%u\n</code>这种const string在每次调用<code>track_printk()</code>时都需要重新加载到栈中。（另外<code>track_printk()</code>是全局的）<br>推荐使用<code>skb_event_output()</code>和<code>xdp_event_output()</code>，你可以自定义event结构，将其存储在perf的事件环形缓冲区中，存储过程是无需锁的，比<code>trace_printk()</code>更快。</p><p>5）<strong>使用LLVM内置的方法memset()/memcpy()/memmove()/memcmp()</strong><br>BPF除了helper函数，一般使用库中的方法需要进行内联。此外，LLVM提供了内置的总会被内联的方法：</p><pre><code class="hljs lisp">#ifndef memset# define memset(<span class="hljs-name">dest</span>, chr, n)   __builtin_memset((<span class="hljs-name">dest</span>), (<span class="hljs-name">chr</span>), (<span class="hljs-name">n</span>))#endif#ifndef memcpy# define memcpy(<span class="hljs-name">dest</span>, src, n)   __builtin_memcpy((<span class="hljs-name">dest</span>), (<span class="hljs-name">src</span>), (<span class="hljs-name">n</span>))#endif#ifndef memmove# define memmove(<span class="hljs-name">dest</span>, src, n)  __builtin_memmove((<span class="hljs-name">dest</span>), (<span class="hljs-name">src</span>), (<span class="hljs-name">n</span>))#endif</code></pre><p><code>memcmp()</code>在部分场景下可能不会被内联，暂时不推荐使用。</p><p>6）<strong>不支持循环</strong><br>内核中的BPF验证器会通过深度优先的方式检测所有可能的执行路径，确保没有循环，以保证程序可以终止。<br>通过<code>#pragma unroll</code>可以实现有限的循环。（<code>#pragma unroll</code>的<a href="https://www.ibm.com/support/knowledgecenter/SSLTBW_2.4.0/com.ibm.zos.v2r4.cbclx01/opt_unroll.htm">介绍</a>)</p><pre><code class="hljs properties"><span class="hljs-comment">#pragma unroll</span>    <span class="hljs-attr">for</span> <span class="hljs-string">(i = 0; i &lt; IPV6_MAX_HEADERS; i++) &#123;</span>        <span class="hljs-attr">switch</span> <span class="hljs-string">(nh) &#123;</span>        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_NONE:</span>            <span class="hljs-attr">return</span> <span class="hljs-string">DROP_INVALID_EXTHDR;</span>        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_FRAGMENT:</span>            <span class="hljs-attr">return</span> <span class="hljs-string">DROP_FRAG_NOSUPPORT;</span>        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_HOP:</span>        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_ROUTING:</span>        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_AUTH:</span>        <span class="hljs-attr">case</span> <span class="hljs-string">NEXTHDR_DEST:</span>            <span class="hljs-attr">if</span> <span class="hljs-string">(skb_load_bytes(skb, l3_off + len, &amp;opthdr, sizeof(opthdr)) &lt; 0)</span>                <span class="hljs-attr">return</span> <span class="hljs-string">DROP_INVALID;</span>            <span class="hljs-attr">nh</span> = <span class="hljs-string">opthdr.nexthdr;</span>            <span class="hljs-attr">if</span> <span class="hljs-string">(nh == NEXTHDR_AUTH)</span>                <span class="hljs-attr">len</span> <span class="hljs-string">+= ipv6_authlen(&amp;opthdr);</span>            <span class="hljs-attr">else</span>                <span class="hljs-attr">len</span> <span class="hljs-string">+= ipv6_optlen(&amp;opthdr);</span>            <span class="hljs-attr">break;</span>        <span class="hljs-attr">default</span>:<span class="hljs-string"></span>            <span class="hljs-meta">*nexthdr</span> = <span class="hljs-string">nh;</span>            <span class="hljs-attr">return</span> <span class="hljs-string">len;</span>        <span class="hljs-attr">&#125;</span>    <span class="hljs-attr">&#125;</span></code></pre><p>另一种方式是通过尾调同一函数，并使用<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>来作为局部缓存。但循环上限为34（本身一次调用，加上尾调上限33）。</p><p>7）<strong>使用尾调对程序进行划分</strong><br>尾调可以实现多阶段的数据包分析，还可以实现事件通知。比如Cilium在运行时通知数据包的drop事件，通过尾调包含<code>skb_event_output()</code>方法的函数。<br>尾调程序的map（<code>BPF_MAP_TYPE_PROG_ARRAY</code>）可以定义灵活的功能，当尾调超过限制时，会进行fall-through。例如XDP或tc的程序，可以设置如下的程序map：</p><ul><li>索引0中的程序执行流量采样（traffic sampling）</li><li>然后跳到索引1执行防火墙策略，然后DROP或者是继续执行索引2</li><li>索引2执行其他的修改，然后发出数据包<pre><code class="hljs cpp">[...]<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __stringify</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __stringify(X)   #X</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>   __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section_tail</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section_tail(ID, KEY)          \</span>   __section(__stringify(ID) <span class="hljs-string">&quot;/&quot;</span> __stringify(KEY))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BPF_FUNC</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> BPF_FUNC(NAME, ...)              \</span>   (*NAME)(__VA_ARGS__) = (<span class="hljs-keyword">void</span> *)BPF_FUNC_##NAME#endif#define BPF_JMP_MAP_ID   <span class="hljs-number">1</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> BPF_FUNC(tail_call, struct __sk_buff *skb, <span class="hljs-keyword">void</span> *<span class="hljs-built_in">map</span>,                     <span class="hljs-keyword">uint32_t</span> index);<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_elf_map</span> <span class="hljs-title">jmp_map</span> __<span class="hljs-title">section</span>(&quot;<span class="hljs-title">maps</span>&quot;) = &#123;</span>    .type           = BPF_MAP_TYPE_PROG_ARRAY,    .id             = BPF_JMP_MAP_ID,    .size_key       = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>),    .size_value     = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>),    .pinning        = PIN_GLOBAL_NS,    .max_elem       = <span class="hljs-number">1</span>,&#125;;__section_tail(JMP_MAP_ID, <span class="hljs-number">0</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">looper</span><span class="hljs-params">(struct __sk_buff *skb)</span></span><span class="hljs-function"></span>&#123;    printk(<span class="hljs-string">&quot;skb cb: %u\n&quot;</span>, skb-&gt;cb[<span class="hljs-number">0</span>]++);    tail_call(skb, &amp;jmp_map, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> TC_ACT_OK;&#125;__section(<span class="hljs-string">&quot;prog&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">entry</span><span class="hljs-params">(struct __sk_buff *skb)</span></span><span class="hljs-function"></span>&#123;    skb-&gt;cb[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    tail_call(skb, &amp;jmp_map, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> TC_ACT_OK;&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre>上面的程序中，首先是创建了一个prog map <code>jmp_map</code>，并pin到global下的<code>jmp_map</code>中。其次，通过<code>__section_tail()</code>对looper设置id和key，设置的方式是对section进行特定的命名。可以看到<code>jmp_map</code>的ID和<code>__section_tail()</code>对<code>looper()</code>函数设定的ID一致，都是<code>JMP_MAP_ID</code>。在<code>entry()</code>中，进行尾调<code>tail_call</code>，尾调指定了key为0，正好是<code>looper()</code>的key。<pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">llvm-objdump</span> <span class="hljs-string">-S</span> <span class="hljs-string">--no-show-raw-insn</span> <span class="hljs-string">prog_array.o</span> <span class="hljs-string">|</span> <span class="hljs-string">less</span><span class="hljs-attr">prog_array.o:</span>   <span class="hljs-string">file</span> <span class="hljs-string">format</span> <span class="hljs-string">ELF64-BPF</span><span class="hljs-attr">Disassembly of section 1/0:</span><span class="hljs-attr">looper:</span>       <span class="hljs-attr">0:</span>       <span class="hljs-string">r6</span> <span class="hljs-string">=</span> <span class="hljs-string">r1</span>       <span class="hljs-attr">1:</span>       <span class="hljs-string">r2</span> <span class="hljs-string">=</span> <span class="hljs-string">*(u32</span> <span class="hljs-string">*)(r6</span> <span class="hljs-string">+</span> <span class="hljs-number">48</span><span class="hljs-string">)</span>       <span class="hljs-attr">2:</span>       <span class="hljs-string">r1</span> <span class="hljs-string">=</span> <span class="hljs-string">r2</span>       <span class="hljs-attr">3:</span>       <span class="hljs-string">r1</span> <span class="hljs-string">+=</span> <span class="hljs-number">1</span>       <span class="hljs-attr">4:</span>       <span class="hljs-string">*(u32</span> <span class="hljs-string">*)(r6</span> <span class="hljs-string">+</span> <span class="hljs-number">48</span><span class="hljs-string">)</span> <span class="hljs-string">=</span> <span class="hljs-string">r1</span>       <span class="hljs-attr">5:</span>       <span class="hljs-string">r1</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">ll</span>       <span class="hljs-attr">7:</span>       <span class="hljs-string">call</span> <span class="hljs-number">-1</span>       <span class="hljs-attr">8:</span>       <span class="hljs-string">r1</span> <span class="hljs-string">=</span> <span class="hljs-string">r6</span>       <span class="hljs-attr">9:</span>       <span class="hljs-string">r2</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">ll</span>      <span class="hljs-attr">11:</span>       <span class="hljs-string">r3</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>      <span class="hljs-attr">12:</span>       <span class="hljs-string">call</span> <span class="hljs-number">12</span>      <span class="hljs-attr">13:</span>       <span class="hljs-string">r0</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>      <span class="hljs-attr">14:</span>       <span class="hljs-string">exit</span><span class="hljs-attr">Disassembly of section prog:</span><span class="hljs-attr">entry:</span>       <span class="hljs-attr">0:</span>       <span class="hljs-string">r2</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>       <span class="hljs-attr">1:</span>       <span class="hljs-string">*(u32</span> <span class="hljs-string">*)(r1</span> <span class="hljs-string">+</span> <span class="hljs-number">48</span><span class="hljs-string">)</span> <span class="hljs-string">=</span> <span class="hljs-string">r2</span>       <span class="hljs-attr">2:</span>       <span class="hljs-string">r2</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span> <span class="hljs-string">ll</span>       <span class="hljs-attr">4:</span>       <span class="hljs-string">r3</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>       <span class="hljs-attr">5:</span>       <span class="hljs-string">call</span> <span class="hljs-number">12</span>       <span class="hljs-attr">6:</span>       <span class="hljs-string">r0</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span>       <span class="hljs-attr">7:</span>       <span class="hljs-string">exi</span></code></pre><blockquote><p>注：这里看到尾调都是<code>call 12</code>，是因为<code>BPF_FUN_tail_call</code>的ID为12。<br><code>include/uapi/linux/bpf.h</code></p><pre><code class="hljs sqf"><span class="hljs-comment">/* integer value in &#x27;imm&#x27; field of BPF_CALL instruction selects which helper</span><span class="hljs-comment">* function eBPF program intends to call</span><span class="hljs-comment">*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __BPF_ENUM_FN(x) BPF_FUNC_ ## x</span>enum bpf_func_id &#123;<span class="hljs-variable">__BPF_FUNC_MAPPER</span>(<span class="hljs-variable">__BPF_ENUM_FN</span>)<span class="hljs-variable">__BPF_FUNC_MAX_ID</span>,&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> __BPF_ENUM_FN</span></code></pre></blockquote></li></ul><p>上面的<code>section 1/0</code>表示是map id为1，key为0的函数，即<code>looper()</code>。<code>jmp_map</code>可以被用户空间的应用修改，也能被tc修改。更新是原子操作，比如：</p><pre><code class="hljs maxima"># tc exec bpf graft m:globals/jmp_map <span class="hljs-built_in">key</span> <span class="hljs-number">0</span> obj <span class="hljs-built_in">new</span>.o <span class="hljs-built_in">sec</span> foo</code></pre><p>上面使用了tc的<code>graft</code>命令，更新了<code>globals/jmp_map</code>key为0的方法，更新为<code>new.o</code>中的<code>section foo</code>。</p><p>8）<strong>栈空间最大限制为512bytes</strong><br>BPF程序栈空间的限制为512bytes，但是可以如上面第三条所述的，通过<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>去扩大栈的空间。</p><p>9）<strong>可以使用BPF嵌入汇编</strong><br>LLVM 6.0开始运行BPF程序使用嵌入汇编。比如下面是64位的原子加操作。相关文档在LLVM源码的<code>lib/Target/BPF/BPFInstrInfo.td</code>以及<code>test/CodeGen/BPF/</code>中。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>   __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>__section(<span class="hljs-string">&quot;prog&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_test</span><span class="hljs-params">(struct xdp_md *ctx)</span></span><span class="hljs-function"></span>&#123;    __u64 a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>, *c = &amp;a;    <span class="hljs-comment">/* just a toy xadd example to show the syntax */</span>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lock *(u64 *)(%0+0) += %1&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(c) : <span class="hljs-string">&quot;r&quot;</span>(b), <span class="hljs-string">&quot;0&quot;</span>(c))</span></span>;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre><p>上面的程序对应的BPF指令为：</p><pre><code class="hljs apache"><span class="hljs-attribute">Verifier</span> analysis:<span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">2</span><span class="hljs-attribute">1</span>: (<span class="hljs-number">7</span>b) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = r<span class="hljs-number">1</span><span class="hljs-attribute">2</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">3</span><span class="hljs-attribute">3</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span><span class="hljs-attribute">4</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span><span class="hljs-attribute">5</span>: (db) lock *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">2</span> +<span class="hljs-number">0</span>) += r<span class="hljs-number">1</span><span class="hljs-attribute">6</span>: (<span class="hljs-number">79</span>) r<span class="hljs-number">0</span> = *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>)<span class="hljs-attribute">7</span>: (<span class="hljs-number">95</span>) exit<span class="hljs-attribute">processed</span> <span class="hljs-number">8</span> insns (limit <span class="hljs-number">131072</span>), stack depth <span class="hljs-number">8</span></code></pre><blockquote><p>注：Cilium在tail call的实现上使用的是内嵌汇编，同样<code>call 12</code>表示<code>BPF_FUN_tail_call</code>。</p><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> __always_inline __maybe_unused <span class="hljs-keyword">void</span>tail_call_static(<span class="hljs-keyword">const</span> struct __ctx_buff *ctx, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *<span class="hljs-built_in">map</span>, <span class="hljs-keyword">const</span> __u32 slot)&#123;<span class="hljs-keyword">if</span> (!__builtin_constant_p(slot))__throw_build_bug();<span class="hljs-comment">/* Don&#x27;t gamble, but _guarantee_ that LLVM won&#x27;t optimize setting</span><span class="hljs-comment"> * r2 and r3 from different paths ending up at the same call insn as</span><span class="hljs-comment"> * otherwise we won&#x27;t be able to use the jmpq/nopl retpoline-free</span><span class="hljs-comment"> * patching by the x86-64 JIT in the kernel.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Note on clobber list: we need to stay in-line with BPF calling</span><span class="hljs-comment"> * convention, so even if we don&#x27;t end up using r0, r4, r5, we need</span><span class="hljs-comment"> * to mark them as clobber so that LLVM doesn&#x27;t end up using them</span><span class="hljs-comment"> * before / after the call.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;r1 = %[ctx]\n\t&quot;</span></span></span><span class="hljs-function"><span class="hljs-params">     <span class="hljs-string">&quot;r2 = %[map]\n\t&quot;</span></span></span><span class="hljs-function"><span class="hljs-params">     <span class="hljs-string">&quot;r3 = %[slot]\n\t&quot;</span></span></span><span class="hljs-function"><span class="hljs-params">     <span class="hljs-string">&quot;call 12\n\t&quot;</span></span></span><span class="hljs-function"><span class="hljs-params">     :: [ctx]<span class="hljs-string">&quot;r&quot;</span>(ctx), [<span class="hljs-built_in">map</span>]<span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-built_in">map</span>), [slot]<span class="hljs-string">&quot;i&quot;</span>(slot)</span></span><span class="hljs-function"><span class="hljs-params">     : <span class="hljs-string">&quot;r0&quot;</span>, <span class="hljs-string">&quot;r1&quot;</span>, <span class="hljs-string">&quot;r2&quot;</span>, <span class="hljs-string">&quot;r3&quot;</span>, <span class="hljs-string">&quot;r4&quot;</span>, <span class="hljs-string">&quot;r5&quot;</span>)</span></span>;&#125;</code></pre></blockquote><p>10）<strong>使用#pragma取消struct的填充</strong></p><pre><code class="hljs awk">struct called_info &#123;    u64 start;  <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte    u64 end;    <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte    u32 sector; <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>-byte&#125;; <span class="hljs-regexp">//</span> size of <span class="hljs-number">20</span>-byte ?printf(<span class="hljs-string">&quot;size of %d-byte\n&quot;</span>, sizeof(struct called_info)); <span class="hljs-regexp">//</span> size of <span class="hljs-number">24</span>-byte<span class="hljs-regexp">//</span> Actual compiled composition of struct called_info<span class="hljs-regexp">//</span> <span class="hljs-number">0</span>x0(<span class="hljs-number">0</span>)                   <span class="hljs-number">0</span>x8(<span class="hljs-number">8</span>)<span class="hljs-regexp">//</span>  ↓________________________↓<span class="hljs-regexp">//</span>  |        start (<span class="hljs-number">8</span>)       |<span class="hljs-regexp">//</span>  |________________________|<span class="hljs-regexp">//</span>  |         end  (<span class="hljs-number">8</span>)       |<span class="hljs-regexp">//</span>  |________________________|<span class="hljs-regexp">//</span>  |  sector(<span class="hljs-number">4</span>) |  PADDING  | &lt;= address aligned to <span class="hljs-number">8</span><span class="hljs-regexp">//</span>  |____________|___________|     with <span class="hljs-number">4</span>-byte PADDING.</code></pre><p>一般为了读取效率，struct会进行对齐填充，会导致BPF验证器的<code>bpf_prog_load()</code>报错<code>invalid indirect read from stack</code>。</p><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> called_info &#123;    u64 start;    u64 <span class="hljs-keyword">end</span>;    u32 sector;&#125;;<span class="hljs-keyword">struct</span> bpf_map_def <span class="hljs-constructor">SEC(<span class="hljs-string">&quot;maps&quot;</span>)</span> called_info_map = &#123;    .<span class="hljs-keyword">type</span> = BPF_MAP_TYPE_HASH,    .key_size = sizeof(long),    .value_size = sizeof(<span class="hljs-keyword">struct</span> called_info),    .max_entries = <span class="hljs-number">4096</span>,&#125;;<span class="hljs-constructor">SEC(<span class="hljs-string">&quot;kprobe/submit_bio&quot;</span>)</span><span class="hljs-built_in">int</span> submit<span class="hljs-constructor">_bio_entry(<span class="hljs-params">struct</span> <span class="hljs-params">pt_regs</span> <span class="hljs-operator">*</span><span class="hljs-params">ctx</span>)</span>&#123;    <span class="hljs-built_in">char</span> fmt<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;submit_bio(bio=0x%lx) called: %llu\n&quot;</span>;    u64 start_time = bpf<span class="hljs-constructor">_ktime_get_ns()</span>;    long bio_ptr = <span class="hljs-constructor">PT_REGS_PARM1(<span class="hljs-params">ctx</span>)</span>;    <span class="hljs-keyword">struct</span> called_info called_info = &#123;            .start = start_time,            .<span class="hljs-keyword">end</span> = <span class="hljs-number">0</span>,            .bi_sector = <span class="hljs-number">0</span>    &#125;;    bpf<span class="hljs-constructor">_map_update_elem(&amp;<span class="hljs-params">called_info_map</span>, &amp;<span class="hljs-params">bio_ptr</span>, &amp;<span class="hljs-params">called_info</span>, BPF_ANY)</span>;    bpf<span class="hljs-constructor">_trace_printk(<span class="hljs-params">fmt</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">fmt</span>)</span>, bio_ptr, start_time);    return <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// On bpf_load_program</span>bpf<span class="hljs-constructor">_load_program()</span> err=<span class="hljs-number">13</span><span class="hljs-number">0</span>: (bf) r6 = r1...<span class="hljs-number">19</span>: (b7) r1 = <span class="hljs-number">0</span><span class="hljs-number">20</span>: (<span class="hljs-number">7</span>b) *(u64 *)(r10 -<span class="hljs-number">72</span>) = r1<span class="hljs-number">21</span>: (<span class="hljs-number">7</span>b) *(u64 *)(r10 -<span class="hljs-number">80</span>) = r7<span class="hljs-number">22</span>: (<span class="hljs-number">63</span>) *(u32 *)(r10 -<span class="hljs-number">64</span>) = r1...<span class="hljs-number">30</span>: (<span class="hljs-number">85</span>) call bpf_map_update_elem#<span class="hljs-number">2</span>invalid indirect read from stack off -<span class="hljs-number">80</span>+<span class="hljs-number">20</span> size <span class="hljs-number">24</span></code></pre><p>比如上面的代码中，<code>bpf_prog_load()</code>会调用BPF验证器的<code>bpf_check()</code>，其中会调用 <code>check_func_arg() -&gt; check_stack_boundary()</code>。由于<code>called_info</code>被对齐，为24位大小，但报错中可以看到从+20处（实际上就是<code>PADDING</code>开始的地方）读取是禁止的。<br><code>check_stack_boundary()</code>内部循环遍历指针的每个<code>access_size</code>(24字节)，确保其在栈的范围内，并且已初始化。通过<code>#pragma</code>去除填充：</p><pre><code class="hljs awk"><span class="hljs-comment">#pragma pack(4)</span>struct called_info &#123;    u64 start;  <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte    u64 end;    <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte    u32 sector; <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>-byte&#125;; <span class="hljs-regexp">//</span> size of <span class="hljs-number">20</span>-byte ?printf(<span class="hljs-string">&quot;size of %d-byte\n&quot;</span>, sizeof(struct called_info)); <span class="hljs-regexp">//</span> size of <span class="hljs-number">20</span>-byte<span class="hljs-regexp">//</span> Actual compiled composition of packed struct called_info<span class="hljs-regexp">//</span> <span class="hljs-number">0</span>x0(<span class="hljs-number">0</span>)                   <span class="hljs-number">0</span>x8(<span class="hljs-number">8</span>)<span class="hljs-regexp">//</span>  ↓________________________↓<span class="hljs-regexp">//</span>  |        start (<span class="hljs-number">8</span>)       |<span class="hljs-regexp">//</span>  |________________________|<span class="hljs-regexp">//</span>  |         end  (<span class="hljs-number">8</span>)       |<span class="hljs-regexp">//</span>  |________________________|<span class="hljs-regexp">//</span>  |  sector(<span class="hljs-number">4</span>) |             &lt;= address aligned to <span class="hljs-number">4</span><span class="hljs-regexp">//</span>  |____________|                 with no PADDING.</code></pre><p>上面的<code>#pragma pack(4)</code>告诉编译器按照4字节进行对齐。但无PADDING会导致读取性能的下降，一般更好的解决方式是显示的填充。</p><pre><code class="hljs awk">struct called_info &#123;    u64 start;  <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte    u64 end;    <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>-byte    u32 sector; <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>-byte    u32 pad;    <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>-byte&#125;; <span class="hljs-regexp">//</span> size of <span class="hljs-number">24</span>-byte ?printf(<span class="hljs-string">&quot;size of %d-byte\n&quot;</span>, sizeof(struct called_info)); <span class="hljs-regexp">//</span> size of <span class="hljs-number">24</span>-byte<span class="hljs-regexp">//</span> Actual compiled composition of struct called_info with explicit padding<span class="hljs-regexp">//</span> <span class="hljs-number">0</span>x0(<span class="hljs-number">0</span>)                   <span class="hljs-number">0</span>x8(<span class="hljs-number">8</span>)<span class="hljs-regexp">//</span>  ↓________________________↓<span class="hljs-regexp">//</span>  |        start (<span class="hljs-number">8</span>)       |<span class="hljs-regexp">//</span>  |________________________|<span class="hljs-regexp">//</span>  |         end  (<span class="hljs-number">8</span>)       |<span class="hljs-regexp">//</span>  |________________________|<span class="hljs-regexp">//</span>  |  sector(<span class="hljs-number">4</span>) |  pad (<span class="hljs-number">4</span>)  | &lt;= address aligned to <span class="hljs-number">8</span><span class="hljs-regexp">//</span>  |____________|___________|     with explicit PADDING.</code></pre><p>11）<strong>通过无效的引用访问包中的数据</strong><br>BPF helper函数中有部分（例如：<code>bpf_skb_stort_bytes</code>）可能会改动数据包的大小。由于验证器服务跟踪这种变化，因此会认定之前的包引用为无效引用，因此在包变动后，访问包前需要更新引用。例如：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> iphdr *ip4 = (<span class="hljs-keyword">struct</span> iphdr *) skb-&gt;data + ETH_HLEN;skb<span class="hljs-constructor">_store_bytes(<span class="hljs-params">skb</span>, <span class="hljs-params">l3_off</span> + <span class="hljs-params">offsetof</span>(<span class="hljs-params">struct</span> <span class="hljs-params">iphdr</span>, <span class="hljs-params">saddr</span>)</span>, &amp;new_saddr, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (ip4-&gt;protocol<span class="hljs-operator"> == </span>IPPROTO_TCP) &#123;    <span class="hljs-comment">// do something</span>&#125;</code></pre><p>由于<code>skb_store_bytes</code>后<code>skb</code>发生变化，因此验证器会认定<code>ip4</code>无效。</p><pre><code class="hljs angelscript">R1=pkt_end(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">0</span>,imm=<span class="hljs-number">0</span>) R2=pkt(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">34</span>,r=<span class="hljs-number">34</span>,imm=<span class="hljs-number">0</span>) R3=inv0R6=ctx(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">0</span>,imm=<span class="hljs-number">0</span>) R7=inv(id=<span class="hljs-number">0</span>,umax_value=<span class="hljs-number">4294967295</span>,var_off=(<span class="hljs-number">0x0</span>; <span class="hljs-number">0xffffffff</span>))R8=inv4294967162 R9=pkt(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">0</span>,r=<span class="hljs-number">34</span>,imm=<span class="hljs-number">0</span>) R10=fp0,call_<span class="hljs-number">-1</span>...<span class="hljs-number">18</span>: (<span class="hljs-number">85</span>) call bpf_skb_store_bytes#<span class="hljs-number">9</span><span class="hljs-number">19</span>: (<span class="hljs-number">7</span>b) *(u64 *)(r10 <span class="hljs-number">-56</span>) = r7R0=inv(id=<span class="hljs-number">0</span>) R6=ctx(id=<span class="hljs-number">0</span>,off=<span class="hljs-number">0</span>,imm=<span class="hljs-number">0</span>) R7=inv(id=<span class="hljs-number">0</span>,umax_value=<span class="hljs-number">2</span>,var_off=(<span class="hljs-number">0x0</span>; <span class="hljs-number">0x3</span>))R8=inv4294967162 R9=inv(id=<span class="hljs-number">0</span>) R10=fp0,call_<span class="hljs-number">-1</span> fp<span class="hljs-number">-48</span>=mmmm???? fp<span class="hljs-number">-56</span>=mmmmmmmm<span class="hljs-number">21</span>: (<span class="hljs-number">61</span>) r1 = *(u32 *)(r9 +<span class="hljs-number">23</span>)R9 invalid mem access <span class="hljs-string">&#x27;inv&#x27;</span></code></pre><p>修复此问题需要在重新更新<code>ip4</code>：</p><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span></span> *ip4 = (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span></span> *) skb-&gt;data + ETH_HLEN;skb_store_bytes(skb, l3_off + offsetof(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span></span>, saddr), &amp;new_saddr, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>);ip4 = (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span></span> *) skb-&gt;data + ETH_HLEN;<span class="hljs-keyword">if</span> (ip4-&gt;protocol == IPPROTO_TCP) &#123;    <span class="hljs-comment">// do something</span>&#125;</code></pre><h3 id="iproute2"><a href="#iproute2" class="headerlink" title="iproute2"></a>iproute2</h3><p>BPF loader有多种工具，例如bbc、perf、iproute2等。perf主要使用内核中的<code>tools/lib/bpf/</code>库。bbc主要用于track，使用的是嵌有C的python编写BPF，编写逻辑和一般的BPF有细小区别（有专门函数，类似于BPF help函数）。另外还有如内核<code>samples/bpf</code>下的程序，编译为obj文件后，通过系统调用来加载。<br>本章主要介绍iproute2对tc、XDP、lwt类型的BPF程序的加载。因为Cilium使用的是iproute2，Cilium后面可能会实现自己原生的loader，但仍会兼容iproute2。支持iproute2的BPF程序都有相同的loader逻辑。</p><p>1）<strong>加载XDP BPF</strong><br>下面命令加载<code>prog.o</code>的BPF到<code>em1</code>设备上：</p><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp obj prog.o</span></code></pre><p>上面命令未指定section，默认使用<code>prog</code> section。也可以指定section，比如指定加载<code>foobar</code> section。</p><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp obj prog.o sec foobar</span></code></pre><p>也可以从<code>.text</code> section中加载程序，例如下面为指定<code>__section()</code>。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/bpf.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __section</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> __section(NAME)                  \</span>   __attribute__((section(NAME), used))<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">xdp_drop</span><span class="hljs-params">(struct xdp_md *ctx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> XDP_DROP;&#125;<span class="hljs-keyword">char</span> __license[] __section(<span class="hljs-string">&quot;license&quot;</span>) = <span class="hljs-string">&quot;GPL&quot;</span>;</code></pre><p>可以通过如下方式加载：</p><pre><code class="hljs css"># <span class="hljs-selector-tag">ip</span> <span class="hljs-selector-tag">link</span> <span class="hljs-selector-tag">set</span> <span class="hljs-selector-tag">dev</span> <span class="hljs-selector-tag">em1</span> <span class="hljs-selector-tag">xdp</span> <span class="hljs-selector-tag">obj</span> <span class="hljs-selector-tag">prog</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">sec</span> <span class="hljs-selector-class">.text</span></code></pre><p>默认情况下，通过<code>ip</code>加载XDP到某个已加载XDP程序的设备上时，会报错。需要使用<code>-force</code>选项进行替换。</p><pre><code class="hljs gams"># ip -force link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp obj prog.o</span></code></pre><p>大多数支持XDP的驱动在替换XDP时都是原子操作，不会中断流量。一个设备只会加载一个XDP，但你可以通过尾调或是BPF2BPF来实现复杂的逻辑。<br>通过<code>ip link | grep xdp</code>可以看到设备上是否有XDP程序，通过<code>ip -d link</code>以及<code>bpftool</code>可以获取更多的信息。<br>关闭XDP程序：</p><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp off</span></code></pre><p>在non-XDP与native  XDP切换过程中，设备会重新配置接收rings，确保接收的包线性的存储在单个页面，以供BPF程序读写。一旦配置完后，后续XDP程序的替换就是原子操作。<br>在iproute2中支持的XDP模式为<code>xdpdrv</code>、<code>xdpoffload</code>、<code>xdpgeneric</code>。<br><code>xdpdrv</code>需要驱动支持，其处理点在驱动的接收路径上，是软件层面能达到的最早处理点。</p><blockquote><p> 通过<code>lspci -vvv</code>可以查看网卡的驱动。比如我的驱动是<code>e1000e</code><br> <pre><code class="hljs routeros"> 00:1f.6<span class="hljs-built_in"> Ethernet </span>controller: Intel Corporation<span class="hljs-built_in"> Ethernet Connection </span>(7) I219-LM (rev 10) <span class="hljs-built_in">..</span>.Kernel driver <span class="hljs-keyword">in</span> use: e1000eKernel modules: e1000e</code></pre><br>在<a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</a> 中可以看到<code>e1000e</code>目前不支持XDP。</p></blockquote><p><code>xdpgeneric</code>是针对不支持XDP的驱动的一种实验性模式。<code>xdpgeneric</code>的hook点在包作为<code>skb</code>进入协议栈后，因此性能不如<code>xdpdrv</code>。一般<code>xdpgeneric</code>只作为实验场景，不作为生产场景。<br><code>xdpoffload</code>需要驱动支持<code>SmartNICs</code>，例如<code>Netronome</code>的nfp驱动。这种模式会将BPF程序加载到硬件上，由硬件处理数据包，并且<code>xdpoffload</code>中，并非所有的BPF map和BPF helper函数都是支持的，如果使用了不支持的BPF功能，BPF验证器会拒绝并指出。<br>在通过<code>ip link set dev em1 xdp obj [...]</code>命令进行XDP加载时，会先尝试<code>xdpdrv</code>模式，如果驱动不支持，则使用<code>xdpgeneric</code>模式。显示的使用<code>xdpdrv</code>代替<code>xdp</code>，会在驱动不支持时，直接报错，而避免使用<code>xdpgeneric</code>模式。<br>下面的例子中，强制以<code>xdpdrv</code>加载XDP程序，查看详情，卸载。</p><pre><code class="hljs routeros"><span class="hljs-comment"># ip -force link set dev em1 xdpdrv obj prog.o</span><span class="hljs-comment"># ip link show</span>[<span class="hljs-built_in">..</span>.]6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc mq state UP mode DORMANT<span class="hljs-built_in"> group default </span>qlen 1000    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff    prog/xdp id 1 tag 57cd311f2e27366b[<span class="hljs-built_in">..</span>.]<span class="hljs-comment"># ip link set dev em1 xdpdrv off</span></code></pre><p>下面的例子中，强制以<code>xdpgeneric</code>加载XDP，查看详情，获取汇编指令，卸载。</p><pre><code class="hljs routeros"><span class="hljs-comment"># ip -force link set dev em1 xdpgeneric obj prog.o</span><span class="hljs-comment"># ip link show</span>[<span class="hljs-built_in">..</span>.]6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpgeneric qdisc mq state UP mode DORMANT<span class="hljs-built_in"> group default </span>qlen 1000    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff    prog/xdp id 4 tag 57cd311f2e27366b                &lt;-- BPF program ID 4[<span class="hljs-built_in">..</span>.]<span class="hljs-comment"># bpftool prog dump xlated id 4                       &lt;-- Dump of instructions running on em1</span>0: (b7) r0 = 11: (95) exit<span class="hljs-comment"># ip link set dev em1 xdpgeneric off</span></code></pre><pre><code class="hljs angelscript"># ip -force link <span class="hljs-keyword">set</span> dev em1 xdpoffload obj prog.o# ip link show[...]<span class="hljs-number">6</span>: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="hljs-number">1500</span> xdpoffload qdisc mq state UP mode DORMANT group <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/ether be:<span class="hljs-number">08</span>:<span class="hljs-number">4</span>d:b6:<span class="hljs-number">85</span>:<span class="hljs-number">65</span> brd ff:ff:ff:ff:ff:ff    prog/xdp id <span class="hljs-number">8</span> tag <span class="hljs-number">57</span>cd311f2e27366b[...]# bpftool prog show id <span class="hljs-number">8</span><span class="hljs-number">8</span>: xdp  tag <span class="hljs-number">57</span>cd311f2e27366b dev em1                  &lt;-- Also indicates a BPF program offloaded to em1    loaded_at Apr <span class="hljs-number">11</span>/<span class="hljs-number">20</span>:<span class="hljs-number">38</span>  uid <span class="hljs-number">0</span>    xlated <span class="hljs-number">16</span>B  <span class="hljs-keyword">not</span> jited  memlock <span class="hljs-number">4096</span>B# ip link <span class="hljs-keyword">set</span> dev em1 xdpoffload off</code></pre><p>不同模式之间是不允许直接进行切换的，需要关闭之前的模式。</p><pre><code class="hljs sas"># ip -force <span class="hljs-meta">link</span> <span class="hljs-meta">set</span> dev em1 xdpgeneric obj prog.o# ip -force <span class="hljs-meta">link</span> <span class="hljs-meta">set</span> dev em1 xdpoffload obj prog.oRTNETLINK answers: <span class="hljs-meta">File</span> exists# ip -force <span class="hljs-meta">link</span> <span class="hljs-meta">set</span> dev em1 xdpdrv obj prog.oRTNETLINK answers: <span class="hljs-meta">File</span> exists# ip -force <span class="hljs-meta">link</span> <span class="hljs-meta">set</span> dev em1 xdpgeneric obj prog.o    &lt;-- Succeeds due to xdpgeneric#</code></pre><pre><code class="hljs routeros"><span class="hljs-comment"># ip -force link set dev em1 xdpgeneric obj prog.o</span><span class="hljs-comment"># ip -force link set dev em1 xdpgeneric off</span><span class="hljs-comment"># ip -force link set dev em1 xdpoffload obj prog.o</span><span class="hljs-comment"># ip l</span>[<span class="hljs-built_in">..</span>.]6: em1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc mq state UP mode DORMANT<span class="hljs-built_in"> group default </span>qlen 1000    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff    prog/xdp id 17 tag 57cd311f2e27366b[<span class="hljs-built_in">..</span>.]<span class="hljs-comment"># ip -force link set dev em1 xdpoffload off</span></code></pre><p>2）<strong>加载tc BPF obj文件</strong><br>tc BPF程序的加载不依赖驱动的支持：</p><pre><code class="hljs vim"># <span class="hljs-keyword">tc</span> qdisc <span class="hljs-built_in">add</span> dev em1 clsact# <span class="hljs-keyword">tc</span> <span class="hljs-built_in">filter</span> <span class="hljs-built_in">add</span> dev em1 ingress bpf da obj prog.<span class="hljs-keyword">o</span></code></pre><p><code>clsact</code>不进行排队，只保存分类或操作，<code>clsact</code>提供<code>ingress</code>和<code>egress</code>两个hooks。<code>ingress</code> hook在<code>__netif_receive_skb_core() -&gt; sch_handle_ingress()</code>中调用，<code>egress</code> hook在<code>__dev_queue_xmit() -&gt; sch_handle_egress()</code>中调用。添加<code>egress</code>：</p><pre><code class="hljs vim"># <span class="hljs-keyword">tc</span> <span class="hljs-built_in">filter</span> <span class="hljs-built_in">add</span> dev em1 egress bpf da obj prog.<span class="hljs-keyword">o</span></code></pre><p><code>clsact</code>还可以挂载在虚拟的、无队列的设备上，例如容器的<code>veth</code>设备。<br><code>tc filter</code>使用<code>da</code>（direct-action）模式加载BPF tc程序，因为BPF程序会处理数据包的转发或其他操作，不需要tc action模块。<br>section的指定类似于XDP：</p><pre><code class="hljs vim"># <span class="hljs-keyword">tc</span> <span class="hljs-built_in">filter</span> <span class="hljs-built_in">add</span> dev em1 egress bpf da obj prog.<span class="hljs-keyword">o</span> sec foobar</code></pre><p>列出加载的tc程序：</p><pre><code class="hljs routeros"><span class="hljs-comment"># tc filter show dev em1 ingress</span>filter protocol all pref 49152 bpffilter protocol all pref 49152 bpf handle 0x1 prog.o:[ingress] direct-action id 1 tag c5f7825e5dac396f<span class="hljs-comment"># tc filter show dev em1 egress</span>filter protocol all pref 49152 bpffilter protocol all pref 49152 bpf handle 0x1 prog.o:[egress] direct-action id 2 tag b2fd5adc0f262714</code></pre><p><code>prog.o:[ingress] direct-action</code>表示程序加载的是ingress section，使用da模式。后面的<code>id</code>是tc程序的唯一标识符，可以与<code>bpftool</code>一起使用来dump tc程序信息。<code>tag</code>是tc程序指令编码的hash，可以与<code>perf</code>的输出或obj文件进行对应。<br>虽然可以通过链式加载多个tc程序，但是一般使用一个BPF即可，因为da模式下，BPF程序本身就能返回tc active，比如<code>TC_ACT_OK</code>、<code>TC_ACT_SHOT</code>等。<br>上面的<code>perf 49152</code>与<code>handle 0x1</code>如果没显示的指定，就是自动生成的。<code>perf</code>表示优先级的编号，如果附加了多个分类器，则按照升序来依次执行，<code>hanler</code>用于表示在同一<code>perf</code>下的某个分类器的多个实例。这两个值仅建议在计划自动替换BPF程序的时候指定，例如：</p><pre><code class="hljs routeros"><span class="hljs-comment"># tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar</span><span class="hljs-comment"># tc filter show dev em1 ingress</span>filter protocol all pref 1 bpffilter protocol all pref 1 bpf handle 0x1 prog.o:[foobar] direct-action id 1 tag c5f7825e5dac396f</code></pre><p>原子的替换之前的tc：</p><pre><code class="hljs angelscript"># tc filter replace dev em1 ingress pref <span class="hljs-number">1</span> handle <span class="hljs-number">1</span> bpf da obj prog.o sec foobar</code></pre><p>删除所有的tc程序：</p><pre><code class="hljs vala"><span class="hljs-meta"># tc filter del dev em1 ingress</span><span class="hljs-meta"># tc filter del dev em1 egress</span></code></pre><p>也可以通过删除<code>clsact</code> qdisc，一次性删除所有的tc：</p><pre><code class="hljs vala"><span class="hljs-meta"># tc qdisc del dev em1 clsact</span></code></pre><p>如果网卡支持，tc也可以像XDP一样进行offload：</p><pre><code class="hljs subunit"># tc qdisc add dev em1 clsact# tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o<span class="hljs-keyword">Error: </span>TC offload is disabled on net device.We have an error talking to the kernel</code></pre><p>上面的报错表示需要开启设备的offload：</p><pre><code class="hljs routeros"><span class="hljs-comment"># ethtool -K em1 hw-tc-offload on</span><span class="hljs-comment"># tc qdisc add dev em1 clsact</span><span class="hljs-comment"># tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o</span><span class="hljs-comment"># tc filter show dev em1 ingress</span>filter protocol all pref 1 bpffilter protocol all pref 1 bpf handle 0x1 prog.o:[classifier] direct-action skip_sw in_hw id 19 tag 57cd311f2e27366b</code></pre><p><code>in_hw</code>表示tc程序已经offload到NIC上。另外，XDP与tc不能同时使用offload。</p><p>3）<strong>通过netdevsim测试BPF offload</strong><br>netdevsim作为内核一部分实现了XDP与tc的offload接口，可以用于测试。<br>创建一个netdevsim设备：</p><pre><code class="hljs pf"><span class="hljs-comment"># modprobe netdevsim</span>// [ID] [PORT_COUNT]<span class="hljs-comment"># echo &quot;1 1&quot; &gt; /sys/bus/netdevsim/new_device</span><span class="hljs-comment"># devlink dev</span>netdevsim/netdevsim1<span class="hljs-comment"># devlink port</span>netdevsim/netdevsim1/<span class="hljs-number">0</span>: type eth netdev eth0 flavour physical<span class="hljs-comment"># ip l</span>[...]<span class="hljs-number">4</span>: eth0: <span class="hljs-variable">&lt;BROADCAST,NOARP,UP,LOWER_UP&gt;</span> mtu <span class="hljs-number">1500</span> qdisc noqueue <span class="hljs-keyword">state</span> UNKNOWN mode DEFAULT <span class="hljs-keyword">group</span> <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/ether <span class="hljs-number">2</span>a:d5:cd:<span class="hljs-number">08</span>:d1:<span class="hljs-number">3</span>f brd ff:ff:ff:ff:ff:ff</code></pre><p>然后可以将XDP或tc offload到此设备上：</p><pre><code class="hljs routeros"><span class="hljs-comment"># ip -force link set dev eth0 xdpoffload obj prog.o</span><span class="hljs-comment"># ip l</span>[<span class="hljs-built_in">..</span>.]4: eth0: &lt;BROADCAST,NOARP,UP,LOWER_UP&gt; mtu 1500 xdpoffload qdisc noqueue state UNKNOWN mode<span class="hljs-built_in"> DEFAULT group default </span>qlen 1000    link/ether 2a:d5:cd:08:d1:3f brd ff:ff:ff:ff:ff:ff    prog/xdp id 16 tag a04f5eef06a7f555</code></pre><p>BPF的loader操作除了上面的命令外，还有一些高级选项，下面以XDP进行介绍，tc同样可用。<br>1）<strong>输出日志</strong><br>通过<code>verb</code>选项，可以输出验证器验证成功的日志或是验证失败的日志。</p><pre><code class="hljs awk"><span class="hljs-comment"># ip link set dev em1 xdp obj xdp-example.o verb</span>Prog section <span class="hljs-string">&#x27;prog&#x27;</span> loaded (<span class="hljs-number">5</span>)! - Type:         <span class="hljs-number">6</span> - Instructions: <span class="hljs-number">2</span> (<span class="hljs-number">0</span> over limit) - License:      GPLVerifier analysis:<span class="hljs-number">0</span>: (b7) r0 = <span class="hljs-number">1</span><span class="hljs-number">1</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span>processed <span class="hljs-number">2</span> insns</code></pre><p>2）<strong>加载BPF文件系统上的程序</strong><br>上面加载都是使用的obj文件，可通过如下命令加载BPF文件系统上的程序：</p><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp pinned</span> /sys/<span class="hljs-comment">fs</span>/bpf/<span class="hljs-comment">prog</span></code></pre><p>也可以使用简写：</p><pre><code class="hljs gams"># ip link <span class="hljs-keyword">set</span> dev <span class="hljs-comment">em1 xdp pinned m:prog</span></code></pre><p>当加载BPF程序时，iproute2会自动检测是否有BPF文件系统的实例（为了pinning BPF program或是BPF map），一旦未找BPF文件系统，就是自动在<code>/sys/fs/bpf</code>下mount一个。如果找到，则不会在进行mount，例如：</p><pre><code class="hljs gradle"># mkdir <span class="hljs-regexp">/var/</span>run/bpf# mount --bind <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/bpf /</span>var<span class="hljs-regexp">/run/</span>bpf# mount -t bpf bpf <span class="hljs-regexp">/var/</span>run/bpf# tc filter add dev em1 ingress bpf da obj tc-example.o sec prog# tree <span class="hljs-regexp">/var/</span>run/bpf<span class="hljs-regexp">/var/</span>run/bpf+-- ip -&gt; <span class="hljs-regexp">/run/</span>bpf<span class="hljs-regexp">/tc/</span>+-- tc|   +-- globals|       +-- jmp_map+-- xdp -&gt; <span class="hljs-regexp">/run/</span>bpf<span class="hljs-regexp">/tc/</span><span class="hljs-number">4</span> directories, <span class="hljs-number">1</span> <span class="hljs-keyword">file</span></code></pre><p>默认情况下，load tc程序将创建如上所示的初始化目录，各个子系统（XDP等）的目录通过链接的方式指向相同的globals空间，以便于BPF map在不同类型的BPF程序之间共享。但如果文件系统目录已经被创建，则loader不会重新修改已有的目录结构，这样可以分离<code>lwt</code>、<code>tc</code>和<code>XDP</code>的BPF map。<br>iproute2在安装时会安装头文件，可以在BPF程序中引用：</p><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iproute2/bpf_elf.h&gt;</span></span></code></pre><p>头文件提供了map的API以及BPF程序默认的section，iproute2中通过<code>struct bpf_elf_map</code>定义map。iproute2解析BPF obj文件的过程：</p><ul><li>遍历所有section，获取<code>map</code>与<code>license</code>。</li><li>验证<code>map</code>，并创建map对象。如果BPF文件系统中已存在pinned map，则使用，否则，创建新的map，并pin到BPF文件系统中。</li><li>处理包含ELF重定向（这里的重定向只包含map操作的）的section，将map的文件描述符编码为立即数。</li><li>通过系统调用创建BPF程序，如果提供了尾调的program map，更新其中程序的文件描述符。</li></ul><h3 id="bpftool"><a href="#bpftool" class="headerlink" title="bpftool"></a>bpftool</h3><p>bpftool是在内核<code>tools/bpf/bpftool/</code>下提供的debug工具。作用：</p><ul><li>dump已加载的BPF程序或map的信息，dump BPF程序使用的map信息。</li><li>dump BPF map的键值对，查询、删除、修改某个键值对，查询某个key的下一个key。</li><li>可以通过BPF程序或map的ID进行操作，也可以指定pin到的文件系统路径来操作。</li><li>pin BPF程序或map到某个文件系统上。</li></ul><h4 id="查询概况"><a href="#查询概况" class="headerlink" title="查询概况"></a>查询概况</h4><p>查看当前机器上所有的BPF程序概况：</p><pre><code class="hljs"><span class="hljs-comment"># bpftool prog</span><span class="hljs-attribute">398</span>: sched_cls  tag <span class="hljs-number">56207908</span>be<span class="hljs-number">8</span>ad<span class="hljs-number">877</span>   <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>   <span class="hljs-attribute">xlated</span> <span class="hljs-number">8800</span>B  jited <span class="hljs-number">6184</span>B  memlock <span class="hljs-number">12288</span>B  map_ids <span class="hljs-number">18</span>,<span class="hljs-number">5</span>,<span class="hljs-number">17</span>,<span class="hljs-number">14</span><span class="hljs-attribute">399</span>: sched_cls  tag abc<span class="hljs-number">95</span>fb<span class="hljs-number">4835</span>a<span class="hljs-number">6</span>ec<span class="hljs-number">9</span>   <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>   <span class="hljs-attribute">xlated</span> <span class="hljs-number">344</span>B  jited <span class="hljs-number">223</span>B  memlock <span class="hljs-number">4096</span>B  map_ids <span class="hljs-number">18</span><span class="hljs-attribute">400</span>: sched_cls  tag afd<span class="hljs-number">2</span>e<span class="hljs-number">542</span>b<span class="hljs-number">30</span>ff<span class="hljs-number">3</span>ec   <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>   <span class="hljs-attribute">xlated</span> <span class="hljs-number">1720</span>B  jited <span class="hljs-number">1001</span>B  memlock <span class="hljs-number">4096</span>B  map_ids <span class="hljs-number">17</span><span class="hljs-attribute">401</span>: sched_cls  tag <span class="hljs-number">2</span>dbbd<span class="hljs-number">74</span>ee<span class="hljs-number">5</span>d<span class="hljs-number">51</span>cc<span class="hljs-number">8</span>   <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>   <span class="hljs-attribute">xlated</span> <span class="hljs-number">3728</span>B  jited <span class="hljs-number">2099</span>B  memlock <span class="hljs-number">4096</span>B  map_ids <span class="hljs-number">17</span>[...]</code></pre><p>查询map概况：</p><pre><code class="hljs"><span class="hljs-comment"># bpftool map</span><span class="hljs-attribute">5</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>    <span class="hljs-attribute">key</span> <span class="hljs-number">20</span>B  value <span class="hljs-number">112</span>B  max_entries <span class="hljs-number">65535</span>  memlock <span class="hljs-number">13111296</span>B<span class="hljs-attribute">6</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>    <span class="hljs-attribute">key</span> <span class="hljs-number">20</span>B  value <span class="hljs-number">20</span>B  max_entries <span class="hljs-number">65536</span>  memlock <span class="hljs-number">7344128</span>B<span class="hljs-attribute">7</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>    <span class="hljs-attribute">key</span> <span class="hljs-number">10</span>B  value <span class="hljs-number">16</span>B  max_entries <span class="hljs-number">8192</span>  memlock <span class="hljs-number">790528</span>B<span class="hljs-attribute">8</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>    <span class="hljs-attribute">key</span> <span class="hljs-number">22</span>B  value <span class="hljs-number">28</span>B  max_entries <span class="hljs-number">8192</span>  memlock <span class="hljs-number">987136</span>B<span class="hljs-attribute">9</span>: hash  flags <span class="hljs-number">0</span>x<span class="hljs-number">0</span>    <span class="hljs-attribute">key</span> <span class="hljs-number">20</span>B  value <span class="hljs-number">8</span>B  max_entries <span class="hljs-number">512000</span>  memlock <span class="hljs-number">49352704</span>B[...]</code></pre><p>可以添加参数<code>--json</code>来输出json格式，参数<code>--pretty</code>来翻译为可读的信息。</p><pre><code class="hljs ada"># bpftool prog <span class="hljs-comment">--json --pretty</span></code></pre><h4 id="dump-BPF程序"><a href="#dump-BPF程序" class="headerlink" title="dump BPF程序"></a>dump BPF程序</h4><p>dump已经验证的BPF程序的image，先通过tc获取信息：</p><pre><code class="hljs routeros"><span class="hljs-comment"># tc filter show dev cilium_host egress</span>filter protocol all pref 1 bpf chain 0filter protocol all pref 1 bpf chain 0 handle 0x1 bpf_host.o:[from-netdev] \                    direct-action not_in_hw id 406 tag e0362f5bd9163a0a jited</code></pre><p>可以看出，BPF程序来着<code>bpf_host.o</code>文件，section为<code>from-netdev</code>，ID为<code>406</code>。使用bpftool获取更多元信息：</p><pre><code class="hljs apache"><span class="hljs-comment"># bpftool prog show id 406</span><span class="hljs-attribute">406</span>: sched_cls  tag e<span class="hljs-number">0362</span>f<span class="hljs-number">5</span>bd<span class="hljs-number">9163</span>a<span class="hljs-number">0</span>a     <span class="hljs-attribute">loaded_at</span> Apr <span class="hljs-number">09</span>/<span class="hljs-number">16</span>:<span class="hljs-number">24</span>  uid <span class="hljs-number">0</span>     <span class="hljs-attribute">xlated</span> <span class="hljs-number">11144</span>B  jited <span class="hljs-number">7721</span>B  memlock <span class="hljs-number">12288</span>B  map_ids <span class="hljs-number">18</span>,<span class="hljs-number">20</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span></code></pre><p>可以看到BPF程序类型为<code>sched_cls</code>（<code>BPF_PROG_TYPE_SCHED_CLS</code>），器tag为<code>e0362f5bd9163a0a</code>，由uid 0(<code>root</code>)在<code>Apr 09/16:24</code>加载，BPF指令大小为<code>11144B</code>，JIT编译后的image为<code>7721B</code>，程序本身（不包括map）占用了<code>12288B</code>的内存空间，在map方面，使用了id为<code>18,20,8,5,6,14</code>的这几个BPF map。<br>dump BPF程序的指令（输出对BPF map和BPF helper做了专门的注释）：</p><pre><code class="hljs"><span class="hljs-comment"># bpftool prog dump xlated id 406</span> <span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">7</span> = <span class="hljs-number">0</span> <span class="hljs-attribute">1</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">60</span>) = r<span class="hljs-number">7</span> <span class="hljs-attribute">2</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">56</span>) = r<span class="hljs-number">7</span> <span class="hljs-attribute">3</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">52</span>) = r<span class="hljs-number">7</span>[...]<span class="hljs-attribute">47</span>: (bf) r<span class="hljs-number">4</span> = r<span class="hljs-number">10</span><span class="hljs-attribute">48</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">4</span> += -<span class="hljs-number">40</span><span class="hljs-attribute">49</span>: (<span class="hljs-number">79</span>) r<span class="hljs-number">6</span> = *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">104</span>)<span class="hljs-attribute">50</span>: (bf) r<span class="hljs-number">1</span> = r<span class="hljs-number">6</span><span class="hljs-attribute">51</span>: (<span class="hljs-number">18</span>) r<span class="hljs-number">2</span> = map[id:<span class="hljs-number">18</span>]                    &lt;-- BPF map id <span class="hljs-number">18</span><span class="hljs-attribute">53</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">5</span> = <span class="hljs-number">32</span><span class="hljs-attribute">54</span>: (<span class="hljs-number">85</span>) call bpf_skb_event_output#<span class="hljs-number">5656112</span>  &lt;-- BPF helper call<span class="hljs-attribute">55</span>: (<span class="hljs-number">69</span>) r<span class="hljs-number">1</span> = *(u<span class="hljs-number">16</span> *)(r<span class="hljs-number">6</span> +<span class="hljs-number">192</span>)[...]</code></pre><p>交叉输出指令对应的opcodes的编码：</p><pre><code class="hljs angelscript"># bpftool prog dump xlated id <span class="hljs-number">406</span> opcodes <span class="hljs-number">0</span>: (b7) r7 = <span class="hljs-number">0</span>    b7 <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">60</span>) = r7    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">3</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">2</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">56</span>) = r7    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">38</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">3</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">52</span>) = r7    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">34</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">4</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">48</span>) = r7    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">30</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">5</span>: (<span class="hljs-number">63</span>) *(u32 *)(r1 +<span class="hljs-number">64</span>) = r7    <span class="hljs-number">63</span> <span class="hljs-number">71</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> [...]</code></pre><p>dump JIT编译过的image汇编信息：</p><pre><code class="hljs gcode"><span class="hljs-attr"># bpftool prog dump jited id 406</span> <span class="hljs-number">0</span>:        push   <span class="hljs-meta">%</span>rbp <span class="hljs-number">1</span>:        mov    <span class="hljs-meta">%</span>rsp,<span class="hljs-meta">%</span>rbp <span class="hljs-number">4</span>:        <span class="hljs-keyword">sub</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">228</span>,<span class="hljs-meta">%</span>rsp b:        <span class="hljs-keyword">sub</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">28</span>,<span class="hljs-meta">%</span>rbp f:        mov    <span class="hljs-meta">%</span>rbx,<span class="hljs-number">0</span>x<span class="hljs-number">0</span><span class="hljs-comment">(%rbp)</span><span class="hljs-number">13</span>:        mov    <span class="hljs-meta">%</span>r<span class="hljs-number">13</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span><span class="hljs-comment">(%rbp)</span><span class="hljs-number">17</span>:        mov    <span class="hljs-meta">%</span>r<span class="hljs-number">14</span>,<span class="hljs-number">0</span>x<span class="hljs-number">10</span><span class="hljs-comment">(%rbp)</span><span class="hljs-number">1</span>b:        mov    <span class="hljs-meta">%</span>r<span class="hljs-number">15</span>,<span class="hljs-number">0</span>x<span class="hljs-number">18</span><span class="hljs-comment">(%rbp)</span><span class="hljs-number">1</span>f:        <span class="hljs-keyword">xor</span>    <span class="hljs-meta">%</span>eax,<span class="hljs-meta">%</span>eax<span class="hljs-number">21</span>:        mov    <span class="hljs-meta">%</span>rax,<span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-comment">(%rbp)</span><span class="hljs-number">25</span>:        mov    <span class="hljs-number">0</span>x<span class="hljs-number">80</span><span class="hljs-comment">(%rdi)</span>,<span class="hljs-meta">%</span>r<span class="hljs-number">9</span>d[...]</code></pre><p>交叉输出opcodes的编码：</p><pre><code class="hljs angelscript"># bpftool prog dump jited id <span class="hljs-number">406</span> opcodes <span class="hljs-number">0</span>:        push   %rbp           <span class="hljs-number">55</span> <span class="hljs-number">1</span>:        mov    %rsp,%rbp           <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5 <span class="hljs-number">4</span>:        sub    $<span class="hljs-number">0x228</span>,%rsp           <span class="hljs-number">48</span> <span class="hljs-number">81</span> ec <span class="hljs-number">28</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> b:        sub    $<span class="hljs-number">0x28</span>,%rbp           <span class="hljs-number">48</span> <span class="hljs-number">83</span> ed <span class="hljs-number">28</span> f:        mov    %rbx,<span class="hljs-number">0x0</span>(%rbp)           <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">5</span>d <span class="hljs-number">00</span><span class="hljs-number">13</span>:        mov    %r13,<span class="hljs-number">0x8</span>(%rbp)           <span class="hljs-number">4</span>c <span class="hljs-number">89</span> <span class="hljs-number">6</span>d <span class="hljs-number">08</span><span class="hljs-number">17</span>:        mov    %r14,<span class="hljs-number">0x10</span>(%rbp)           <span class="hljs-number">4</span>c <span class="hljs-number">89</span> <span class="hljs-number">75</span> <span class="hljs-number">10</span><span class="hljs-number">1</span>b:        mov    %r15,<span class="hljs-number">0x18</span>(%rbp)           <span class="hljs-number">4</span>c <span class="hljs-number">89</span> <span class="hljs-number">7</span>d <span class="hljs-number">18</span>[...]</code></pre><p>可以通过bpftool与graphviz进行指令的可视化，生成相应的png：</p><pre><code class="hljs lua"># bpftool prog <span class="hljs-built_in">dump</span> xlated id <span class="hljs-number">406</span> visual &amp;&gt; <span class="hljs-built_in">output</span>.dot$ dot -Tpng <span class="hljs-built_in">output</span>.dot -o <span class="hljs-built_in">output</span>.png</code></pre><p><img src="/img/bpf_dot_2020032901.png"></p><p>需要注意的是<code>xlated</code>是验证器验证后的程序，因此dump的指令与通过解释器的BPF指令一样。在内核中，验证器会对BPF loader提供的原生指令进行重写。比如对内联的BPF helper函数进行重写，以map lookup为例：</p><pre><code class="hljs"><span class="hljs-comment"># bpftool prog dump xlated id 3</span> <span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">2</span> <span class="hljs-attribute">1</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">4</span>) = r<span class="hljs-number">1</span> <span class="hljs-attribute">2</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span> <span class="hljs-attribute">3</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">4</span> <span class="hljs-attribute">4</span>: (<span class="hljs-number">18</span>) r<span class="hljs-number">1</span> = map[id:<span class="hljs-number">2</span>]                      &lt;-- BPF map id <span class="hljs-number">2</span> <span class="hljs-attribute">6</span>: (<span class="hljs-number">85</span>) call __htab_map_lookup_elem#<span class="hljs-number">77408</span>   &lt;-+ BPF helper inlined rewrite <span class="hljs-attribute">7</span>: (<span class="hljs-number">15</span>) if r<span class="hljs-number">0</span> == <span class="hljs-number">0</span>x<span class="hljs-number">0</span> goto pc+<span class="hljs-number">2</span>                | <span class="hljs-attribute">8</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">0</span> += <span class="hljs-number">56</span>                              | <span class="hljs-attribute">9</span>: (<span class="hljs-number">79</span>) r<span class="hljs-number">0</span> = *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">0</span>)                &lt;-+<span class="hljs-attribute">10</span>: (<span class="hljs-number">15</span>) if r<span class="hljs-number">0</span> == <span class="hljs-number">0</span>x<span class="hljs-number">0</span> goto pc+<span class="hljs-number">24</span><span class="hljs-attribute">11</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span><span class="hljs-attribute">12</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">4</span>[...]</code></pre><p>bpftool通过kallsyms来关联bpf helper函数以及bpf2bpf，因此需要确保如下参数开启：</p><pre><code class="hljs gradle"># echo <span class="hljs-number">0</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>kptr_restrict# echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_kallsyms</code></pre><p>对于BPF2BPF，JIT编译后的dump信息，与使用解释器的dump信息是一样的，只不过JIT中使用tag来代替请求的目标函数，如下下面，<code>pc+2</code>表示子程序的偏移量：</p><pre><code class="hljs awk"><span class="hljs-comment"># bpftool prog dump xlated id 1</span><span class="hljs-number">0</span>: (<span class="hljs-number">85</span>) call pc+<span class="hljs-number">2</span><span class="hljs-comment">#__bpf_prog_run_args32</span><span class="hljs-number">1</span>: (b7) r0 = <span class="hljs-number">1</span><span class="hljs-number">2</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span><span class="hljs-number">3</span>: (b7) r0 = <span class="hljs-number">2</span><span class="hljs-number">4</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span></code></pre><p>上面是通过解释器加载的BPF程序，下面是通过JIT编译后的：</p><pre><code class="hljs awk"><span class="hljs-comment"># bpftool prog dump xlated id 1</span><span class="hljs-number">0</span>: (<span class="hljs-number">85</span>) call pc+<span class="hljs-number">2</span><span class="hljs-comment">#bpf_prog_3b185187f1855c4c_F</span><span class="hljs-number">1</span>: (b7) r0 = <span class="hljs-number">1</span><span class="hljs-number">2</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span><span class="hljs-number">3</span>: (b7) r0 = <span class="hljs-number">2</span><span class="hljs-number">4</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span></code></pre><p>对于尾调，与BPF helper函数类似，会映射为一条call指令：</p><pre><code class="hljs angelscript"># bpftool prog dump xlated id <span class="hljs-number">2</span>[...]<span class="hljs-number">10</span>: (b7) r2 = <span class="hljs-number">8</span><span class="hljs-number">11</span>: (<span class="hljs-number">85</span>) call bpf_trace_printk#<span class="hljs-number">-41312</span><span class="hljs-number">12</span>: (bf) r1 = r6<span class="hljs-number">13</span>: (<span class="hljs-number">18</span>) r2 = map[id:<span class="hljs-number">1</span>]<span class="hljs-number">15</span>: (b7) r3 = <span class="hljs-number">0</span><span class="hljs-number">16</span>: (<span class="hljs-number">85</span>) call bpf_tail_call#<span class="hljs-number">12</span><span class="hljs-number">17</span>: (b7) r1 = <span class="hljs-number">42</span><span class="hljs-number">18</span>: (<span class="hljs-number">6</span>b) *(u16 *)(r6 +<span class="hljs-number">46</span>) = r1<span class="hljs-number">19</span>: (b7) r0 = <span class="hljs-number">0</span><span class="hljs-number">20</span>: (<span class="hljs-number">95</span>) exit# bpftool map show id <span class="hljs-number">1</span><span class="hljs-number">1</span>: prog_array  flags <span class="hljs-number">0x0</span>      key <span class="hljs-number">4</span>B  value <span class="hljs-number">4</span>B  max_entries <span class="hljs-number">1</span>  memlock <span class="hljs-number">4096</span>B</code></pre><h4 id="dump-BPF-map"><a href="#dump-BPF-map" class="headerlink" title="dump BPF map"></a>dump BPF map</h4><p>可以通过<code>map dump</code>子命令来dump map中的所有数据：</p><pre><code class="hljs angelscript"># bpftool map dump id <span class="hljs-number">5</span>key:f0 <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">0</span>a <span class="hljs-number">66</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">8</span>a d6<span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>value:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>key:<span class="hljs-number">0</span>a <span class="hljs-number">66</span> <span class="hljs-number">1</span>c ee <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>value:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>[...]Found <span class="hljs-number">6</span> elements</code></pre><p>结合BTF，还能输出map的结构体。例如结合BTF与iproute2中的<code>BPF_ANNOTATE_KV_PAIR()</code>宏：<br>程序源码：</p><pre><code class="hljs rust"># cat tools/testing/selftests/bpf/test_xdp_noinline.c  [...]   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_value</span></span> &#123;         <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                 __<span class="hljs-built_in">u64</span> value;                 __<span class="hljs-built_in">u32</span> ifindex;                 __<span class="hljs-built_in">u8</span> mac[<span class="hljs-number">6</span>];         &#125;;   &#125;;   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map_def</span></span> __attribute__ ((section(<span class="hljs-string">&quot;maps&quot;</span>), used)) ctl_array = &#123;          .<span class="hljs-keyword">type</span>            = BPF_MAP_TYPE_ARRAY,          .key_size        = sizeof(__<span class="hljs-built_in">u32</span>),          .value_size      = sizeof(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_value</span></span>),          .max_entries     = <span class="hljs-number">16</span>,          .map_flags       = <span class="hljs-number">0</span>,   &#125;;   BPF_ANNOTATE_KV_PAIR(ctl_array, __<span class="hljs-built_in">u32</span>, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_value</span></span>);   [...]</code></pre><p><code>BPF_ANNOTATE_KV_PAIR()</code>宏用于生成一个map专用的ELF section，其中保存了一组空的键值对。通过这个section，iproute2可以与BTF中的数据对应起来，从而从BTF中选择相应的类型，来进行映射输出。<br>通过clang进行编译，并通过pahole生成BTF信息：</p><pre><code class="hljs routeros"><span class="hljs-comment"># clang [...] -O2 -target bpf -g -emit-llvm -c test_xdp_noinline.c -o - |</span>  llc <span class="hljs-attribute">-march</span>=bpf <span class="hljs-attribute">-mcpu</span>=probe <span class="hljs-attribute">-mattr</span>=dwarfris <span class="hljs-attribute">-filetype</span>=obj -o test_xdp_noinline.o<span class="hljs-comment"># pahole -J test_xdp_noinline.o</span></code></pre><p>加载到内核中，然后dump map：</p><pre><code class="hljs angelscript"># ip -force link <span class="hljs-keyword">set</span> dev lo xdp obj test_xdp_noinline.o sec xdp-test# ip a<span class="hljs-number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="hljs-number">65536</span> xdpgeneric/id:<span class="hljs-number">227</span> qdisc noqueue state UNKNOWN group <span class="hljs-keyword">default</span> qlen <span class="hljs-number">1000</span>    link/loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>    inet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">8</span> scope host lo       valid_lft forever preferred_lft forever    inet6 ::<span class="hljs-number">1</span>/<span class="hljs-number">128</span> scope host       valid_lft forever preferred_lft forever[...]# bpftool prog show id <span class="hljs-number">227</span><span class="hljs-number">227</span>: xdp  tag a85e060c275c5616  gpl    loaded_at <span class="hljs-number">2018</span><span class="hljs-number">-07</span><span class="hljs-number">-17</span>T14:<span class="hljs-number">41</span>:<span class="hljs-number">29</span>+<span class="hljs-number">0000</span>  uid <span class="hljs-number">0</span>    xlated <span class="hljs-number">8152</span>B  <span class="hljs-keyword">not</span> jited  memlock <span class="hljs-number">12288</span>B  map_ids <span class="hljs-number">381</span>,<span class="hljs-number">385</span>,<span class="hljs-number">386</span>,<span class="hljs-number">382</span>,<span class="hljs-number">384</span>,<span class="hljs-number">383</span># bpftool map dump id <span class="hljs-number">386</span> [&#123;      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-number">0</span>,      <span class="hljs-string">&quot;value&quot;</span>: &#123;          <span class="hljs-string">&quot;&quot;</span>: &#123;              <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">0</span>,              <span class="hljs-string">&quot;ifindex&quot;</span>: <span class="hljs-number">0</span>,              <span class="hljs-string">&quot;mac&quot;</span>: []          &#125;      &#125;  &#125;,&#123;      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-number">1</span>,      <span class="hljs-string">&quot;value&quot;</span>: &#123;          <span class="hljs-string">&quot;&quot;</span>: &#123;              <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">0</span>,              <span class="hljs-string">&quot;ifindex&quot;</span>: <span class="hljs-number">0</span>,              <span class="hljs-string">&quot;mac&quot;</span>: []          &#125;      &#125;  &#125;,&#123;[...]</code></pre><p>还可以通过bpftool对map指定key进行查询、更改或删除。如果BPF程序成功添加了BTF信息，在<code>prog show</code>中可以查看到<code>btf_id</code>：</p><pre><code class="hljs apache"><span class="hljs-comment"># bpftool prog show id 72</span><span class="hljs-attribute">72</span>: xdp  name balancer_ingres  tag acf<span class="hljs-number">44</span>cabb<span class="hljs-number">48385</span>ed  gpl   <span class="hljs-attribute">loaded_at</span> <span class="hljs-number">2020</span>-<span class="hljs-number">04</span>-<span class="hljs-number">13</span>T<span class="hljs-number">23</span>:<span class="hljs-number">12</span>:<span class="hljs-number">08</span>+<span class="hljs-number">0900</span>  uid <span class="hljs-number">0</span>   <span class="hljs-attribute">xlated</span> <span class="hljs-number">19104</span>B  jited <span class="hljs-number">10732</span>B  memlock <span class="hljs-number">20480</span>B  map_ids <span class="hljs-number">126</span>,<span class="hljs-number">130</span>,<span class="hljs-number">131</span>,<span class="hljs-number">127</span>,<span class="hljs-number">129</span>,<span class="hljs-number">128</span>   <span class="hljs-attribute">btf_id</span> <span class="hljs-number">60</span></code></pre><p>通过<code>btf show</code>命令也能查看：</p><pre><code class="hljs angelscript"># bpftool btf show<span class="hljs-number">60</span>: size <span class="hljs-number">12243</span>B  prog_ids <span class="hljs-number">72</span>  map_ids <span class="hljs-number">126</span>,<span class="hljs-number">130</span>,<span class="hljs-number">131</span>,<span class="hljs-number">127</span>,<span class="hljs-number">129</span>,<span class="hljs-number">128</span></code></pre><p>通过<code>btf dump</code>可以输出btf的信息，可以是c或是raw：</p><pre><code class="hljs crystal"><span class="hljs-comment"># bpftool btf dump id 60 format c</span>  [...]   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ctl_value</span> &#123;</span>         <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>                 __u64 value;                 __u32 ifindex;                 __u8 mac[<span class="hljs-number">6</span>];         &#125;;   &#125;;   typedef unsigned int u32;   [...]</code></pre><h3 id="BPF-sysctls"><a href="#BPF-sysctls" class="headerlink" title="BPF sysctls"></a>BPF sysctls</h3><p>BPF相关的内核参数：</p><ul><li><code>/proc/sys/net/core/bpf_jit_enable</code>：开启或关闭BPF JIT</li></ul><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>关闭JIT，使用内核解释器（默认值）</td></tr><tr><td>1</td><td>开启JIT</td></tr><tr><td>2</td><td>开启JIT，并产生debug信息到内核日志中</td></tr><tr><td>当设置为2时，可以使用<code>bpf_jit_disasm</code>进行调试。</td><td></td></tr></tbody></table><ul><li><code>/proc/sys/net/core/bpf_jit_harden</code>：开启或关闭BPF JIT加固。注意开启后会损耗性能，并且会盲化BPF中的立即数。对于通过解释器处理的BPF程序，无需加固。</li></ul><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>关闭JIT加固（默认值）</td></tr><tr><td>1</td><td>对非特权用户启用JIT加固</td></tr><tr><td>2</td><td>对所有用户启动JIT加固</td></tr></tbody></table><ul><li><code>/proc/sys/net/core/bpf_jit_kallsyms</code>：控制是否将JIT编译的BPF程序作为内核符号输出到<code>/proc/kallsyms</code>中，以便与<code>perf</code>一起使用，或是提供堆栈展开的功能。符号名称包含BPF程序的tag（<code>bpf_prog_&lt;tag&gt;</code>）。如果开启<code>bpf_jit_harden</code>，则此特性需要关闭：</li></ul><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>关闭JIT的kallsyms输出（默认值）</td></tr><tr><td>1</td><td>对特权用户开启JIT的kallsyms输出</td></tr></tbody></table><ul><li><code>/proc/sys/kernel/unprivileged_bpf_disabled</code>：开启或关闭非特权用户的<code>bpf(2)</code>系统调用。默认是开启了非特权用户的使用的，这个值是一次性开关，一旦切换，会永久禁用，除非重启。开关不影响其他使用非<code>bpf(2)</code>进行加载的BPF程序，比如seccomp和传统套接字过滤。</li></ul><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>允许非特权用户进行bpf系统调用 （默认值）</td></tr><tr><td>1</td><td>禁止非特权用户进行bpf系统调用</td></tr></tbody></table><h3 id="内核测试"><a href="#内核测试" class="headerlink" title="内核测试"></a>内核测试</h3><p>内核提供了BPF的自测，在<code>tools/testing/selftests/bpf/</code>中：</p><pre><code class="hljs awk">$ cd tools<span class="hljs-regexp">/testing/</span>selftests<span class="hljs-regexp">/bpf/</span>$ make<span class="hljs-comment"># make run_tests</span></code></pre><p>测试涉及：</p><ul><li>BPF验证器</li><li>BPF程序tags</li><li>各种BPF map接口与各类型的BPF map</li><li>检测LLVM后端的C代码</li><li>检测解释器与JIT的eBPF与cBPF汇编代码</li></ul><h3 id="JIT-debug"><a href="#JIT-debug" class="headerlink" title="JIT debug"></a>JIT debug</h3><p>通过修改<code>bpf_jit_enable</code>可以将每次编译的JIT image信息发送到内核日志中：</p><pre><code class="hljs gradle"># echo <span class="hljs-number">2</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_enable</code></pre><p>当BPF程序load后，可以通过<code>dmesg</code>输出：</p><pre><code class="hljs angelscript">[ <span class="hljs-number">3389.935842</span>] flen=<span class="hljs-number">6</span> proglen=<span class="hljs-number">70</span> pass=<span class="hljs-number">3</span> image=ffffffffa0069c8f <span class="hljs-keyword">from</span>=tcpdump pid=<span class="hljs-number">20583</span>[ <span class="hljs-number">3389.935847</span>] JIT code: <span class="hljs-number">00000000</span>: <span class="hljs-number">55</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5 <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">60</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">5</span>d f8 <span class="hljs-number">44</span> <span class="hljs-number">8</span>b <span class="hljs-number">4f</span> <span class="hljs-number">68</span>[ <span class="hljs-number">3389.935849</span>] JIT code: <span class="hljs-number">00000010</span>: <span class="hljs-number">44</span> <span class="hljs-number">2</span>b <span class="hljs-number">4f</span> <span class="hljs-number">6</span>c <span class="hljs-number">4</span>c <span class="hljs-number">8</span>b <span class="hljs-number">87</span> d8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> be <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>[ <span class="hljs-number">3389.935850</span>] JIT code: <span class="hljs-number">00000020</span>: e8 <span class="hljs-number">1</span>d <span class="hljs-number">94</span> ff e0 <span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">75</span> <span class="hljs-number">16</span> be <span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>[ <span class="hljs-number">3389.935851</span>] JIT code: <span class="hljs-number">00000030</span>: <span class="hljs-number">00</span> e8 <span class="hljs-number">28</span> <span class="hljs-number">94</span> ff e0 <span class="hljs-number">83</span> f8 <span class="hljs-number">01</span> <span class="hljs-number">75</span> <span class="hljs-number">07</span> b8 ff ff <span class="hljs-number">00</span> <span class="hljs-number">00</span>[ <span class="hljs-number">3389.935852</span>] JIT code: <span class="hljs-number">00000040</span>: eb <span class="hljs-number">02</span> <span class="hljs-number">31</span> c0 c9 c3</code></pre><p><code>flen</code>表示程序BFP指令的数量（6条BPF指令），<code>proglen</code>表示JIT生成image的大小（70字节），<code>pass=3</code>表示image经过了3个编译器passes（例如<code>x86_64</code>中为了减小image的大小，会有多种进行优化的passes）。<code>image</code>表示JIT image的地址，<code>from</code>与<code>pid</code>表示触发此次编译的用户空间的程序与PID。下面的JIT code可以使用<code>tools/bpf/</code>中的<code>bpf_jit_disasm</code>来反汇编。</p><pre><code class="hljs angelscript"># ./bpf_jit_disasm<span class="hljs-number">70</span> bytes emitted <span class="hljs-keyword">from</span> JIT compiler (pass:<span class="hljs-number">3</span>, flen:<span class="hljs-number">6</span>)ffffffffa0069c8f + &lt;x&gt;:   <span class="hljs-number">0</span>:       push   %rbp   <span class="hljs-number">1</span>:       mov    %rsp,%rbp   <span class="hljs-number">4</span>:       sub    $<span class="hljs-number">0x60</span>,%rsp   <span class="hljs-number">8</span>:       mov    %rbx,<span class="hljs-number">-0x8</span>(%rbp)   c:       mov    <span class="hljs-number">0x68</span>(%rdi),%r9d  <span class="hljs-number">10</span>:       sub    <span class="hljs-number">0x6c</span>(%rdi),%r9d  <span class="hljs-number">14</span>:       mov    <span class="hljs-number">0xd8</span>(%rdi),%r8  <span class="hljs-number">1</span>b:       mov    $<span class="hljs-number">0xc</span>,%esi  <span class="hljs-number">20</span>:       callq  <span class="hljs-number">0xffffffffe0ff9442</span>  <span class="hljs-number">25</span>:       cmp    $<span class="hljs-number">0x800</span>,%eax  <span class="hljs-number">2</span>a:       jne    <span class="hljs-number">0x0000000000000042</span>  <span class="hljs-number">2</span>c:       mov    $<span class="hljs-number">0x17</span>,%esi  <span class="hljs-number">31</span>:       callq  <span class="hljs-number">0xffffffffe0ff945e</span>  <span class="hljs-number">36</span>:       cmp    $<span class="hljs-number">0x1</span>,%eax  <span class="hljs-number">39</span>:       jne    <span class="hljs-number">0x0000000000000042</span>  <span class="hljs-number">3</span>b:       mov    $<span class="hljs-number">0xffff</span>,%eax  <span class="hljs-number">40</span>:       jmp    <span class="hljs-number">0x0000000000000044</span>  <span class="hljs-number">42</span>:       <span class="hljs-keyword">xor</span>    %eax,%eax  <span class="hljs-number">44</span>:       leaveq  <span class="hljs-number">45</span>:       retq</code></pre><p>还可以插上opcode：</p><pre><code class="hljs angelscript"># ./bpf_jit_disasm -o<span class="hljs-number">70</span> bytes emitted <span class="hljs-keyword">from</span> JIT compiler (pass:<span class="hljs-number">3</span>, flen:<span class="hljs-number">6</span>)ffffffffa0069c8f + &lt;x&gt;:   <span class="hljs-number">0</span>:       push   %rbp    <span class="hljs-number">55</span>   <span class="hljs-number">1</span>:       mov    %rsp,%rbp    <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5   <span class="hljs-number">4</span>:       sub    $<span class="hljs-number">0x60</span>,%rsp    <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">60</span>   <span class="hljs-number">8</span>:       mov    %rbx,<span class="hljs-number">-0x8</span>(%rbp)    <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">5</span>d f8   c:       mov    <span class="hljs-number">0x68</span>(%rdi),%r9d    <span class="hljs-number">44</span> <span class="hljs-number">8</span>b <span class="hljs-number">4f</span> <span class="hljs-number">68</span>  <span class="hljs-number">10</span>:       sub    <span class="hljs-number">0x6c</span>(%rdi),%r9d    <span class="hljs-number">44</span> <span class="hljs-number">2</span>b <span class="hljs-number">4f</span> <span class="hljs-number">6</span>c  <span class="hljs-number">14</span>:       mov    <span class="hljs-number">0xd8</span>(%rdi),%r8    <span class="hljs-number">4</span>c <span class="hljs-number">8</span>b <span class="hljs-number">87</span> d8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">1</span>b:       mov    $<span class="hljs-number">0xc</span>,%esi    be <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">20</span>:       callq  <span class="hljs-number">0xffffffffe0ff9442</span>    e8 <span class="hljs-number">1</span>d <span class="hljs-number">94</span> ff e0  <span class="hljs-number">25</span>:       cmp    $<span class="hljs-number">0x800</span>,%eax    <span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">2</span>a:       jne    <span class="hljs-number">0x0000000000000042</span>    <span class="hljs-number">75</span> <span class="hljs-number">16</span>  <span class="hljs-number">2</span>c:       mov    $<span class="hljs-number">0x17</span>,%esi    be <span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">31</span>:       callq  <span class="hljs-number">0xffffffffe0ff945e</span>    e8 <span class="hljs-number">28</span> <span class="hljs-number">94</span> ff e0  <span class="hljs-number">36</span>:       cmp    $<span class="hljs-number">0x1</span>,%eax    <span class="hljs-number">83</span> f8 <span class="hljs-number">01</span>  <span class="hljs-number">39</span>:       jne    <span class="hljs-number">0x0000000000000042</span>    <span class="hljs-number">75</span> <span class="hljs-number">07</span>  <span class="hljs-number">3</span>b:       mov    $<span class="hljs-number">0xffff</span>,%eax    b8 ff ff <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">40</span>:       jmp    <span class="hljs-number">0x0000000000000044</span>    eb <span class="hljs-number">02</span>  <span class="hljs-number">42</span>:       <span class="hljs-keyword">xor</span>    %eax,%eax    <span class="hljs-number">31</span> c0  <span class="hljs-number">44</span>:       leaveq    c9  <span class="hljs-number">45</span>:       retq    c3</code></pre><p>最新的<code>bpftool</code>已经可以通过指定BPF程序的ID来dump JITed BPF程序（上面bpftool中介绍了）。<br>可以使用<code>perf</code>对JITed BPF程序进行性能分析，需要kallsyms信息的支持：</p><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_enable# echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core/bpf_jit_kallsyms</code></pre><p>切换<code>bpf_jit_kallsyms</code>不需要重新加载BPF程序。下面的例子中：perf记录<code>bpf_clone_redirect()</code>helper函数中的分配失败。因为直接写，<code>bpf_clone_redirect()</code>中调用的<code>bpf_try_make_head_writable()</code>会失败，然后会释放克隆的<code>skb</code>，并返回错。<code>perf</code>记录了所有的<code>kfree_skb</code>事件。</p><pre><code class="hljs awk"><span class="hljs-comment"># tc qdisc add dev em1 clsact</span><span class="hljs-comment"># tc filter add dev em1 ingress bpf da obj prog.o sec main</span><span class="hljs-comment"># tc filter show dev em1 ingress</span>filter protocol all pref <span class="hljs-number">49152</span> bpffilter protocol all pref <span class="hljs-number">49152</span> bpf handle <span class="hljs-number">0</span>x1 prog.o:[main] direct-action id <span class="hljs-number">1</span> tag <span class="hljs-number">8227</span>addf251b7543<span class="hljs-comment"># cat /proc/kallsyms</span>[...]ffffffffc00349e0 t fjes_hw_init_command_registers    [fjes]ffffffffc003e2e0 d __tracepoint_fjes_hw_stop_debug_err    [fjes]ffffffffc0036190 t fjes_hw_epbuf_tx_pkt_send    [fjes]ffffffffc004b000 t bpf_prog_8227addf251b7543<span class="hljs-comment"># perf record -a -g -e skb:kfree_skb sleep 60</span><span class="hljs-comment"># perf script --kallsyms=/proc/kallsyms</span>[...]ksoftirqd/<span class="hljs-number">0</span>     <span class="hljs-number">6</span> [<span class="hljs-number">000</span>]  <span class="hljs-number">1004.578402</span>:    skb:kfree_skb: skbaddr=<span class="hljs-number">0</span>xffff9d4161f20a00 protocol=<span class="hljs-number">2048</span> location=<span class="hljs-number">0</span>xffffffffc004b52c   <span class="hljs-number">7</span>fffb8745961 bpf_clone_redirect (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffc004e52c bpf_prog_8227addf251b7543 (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffc05b6283 cls_bpf_classify (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb875957a tc_classify (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb8729840 __netif_receive_skb_core (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb8729e38 __netif_receive_skb (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb872ae05 process_backlog (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb872a43e net_rx_action (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb886176c __do_softirq (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb80ac5b9 run_ksoftirqd (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb80ca7fa smpboot_thread_fn (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb80c6831 kthread (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)   <span class="hljs-number">7</span>fffb885e09c ret_from_fork (<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/4.10.0+/</span>build/vmlinux)</code></pre><p>从上面perf的输出可以看出，<code>bpf_prog_8227addf251b7543</code>是调用栈中的一层，表示tag为<code>8227addf251b7543</code>的BPF程序与<code>kfree_skb</code>事件相关。</p><h3 id="内省（Introspection"><a href="#内省（Introspection" class="headerlink" title="内省（Introspection)"></a>内省（Introspection)</h3><p>内核提供了关于BPF和XDP的各种跟踪点，可以用于内省。BPF的跟踪点：</p><pre><code class="hljs less"># <span class="hljs-selector-tag">perf</span> <span class="hljs-selector-tag">list</span> | <span class="hljs-selector-tag">grep</span> <span class="hljs-selector-tag">bpf</span>:<span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_create</span>                                 <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_delete_elem</span>                            <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_lookup_elem</span>                            <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_next_key</span>                               <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_map_update_elem</span>                            <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_obj_get_map</span>                                <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_obj_get_prog</span>                               <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_obj_pin_map</span>                                <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_obj_pin_prog</span>                               <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_prog_get_type</span>                              <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_prog_load</span>                                  <span class="hljs-selector-attr">[Tracepoint event]</span><span class="hljs-selector-tag">bpf</span><span class="hljs-selector-pseudo">:bpf_prog_put_rcu</span>                               <span class="hljs-selector-attr">[Tracepoint event]</span></code></pre><p>比如使用perf（这里可以用tc程序代替sleep）</p><pre><code class="hljs angelscript"># perf record -a -e bpf:* sleep <span class="hljs-number">10</span># perf scriptsock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">283.980322</span>:      bpf:bpf_map_create: map type=ARRAY ufd=<span class="hljs-number">4</span> key=<span class="hljs-number">4</span> val=<span class="hljs-number">8</span> max=<span class="hljs-number">256</span> flags=<span class="hljs-number">0</span>sock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">283.980721</span>:       bpf:bpf_prog_load: prog=a5ea8fa30ea6849c type=SOCKET_FILTER ufd=<span class="hljs-number">5</span>sock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">283.988423</span>:   bpf:bpf_prog_get_type: prog=a5ea8fa30ea6849c type=SOCKET_FILTERsock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">283.988443</span>: bpf:bpf_map_lookup_elem: map type=ARRAY ufd=<span class="hljs-number">4</span> key=[<span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>] val=[<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>][...]sock_example  <span class="hljs-number">6197</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">288.990868</span>: bpf:bpf_map_lookup_elem: map type=ARRAY ufd=<span class="hljs-number">4</span> key=[<span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>] val=[<span class="hljs-number">14</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>]     swapper     <span class="hljs-number">0</span> [<span class="hljs-number">005</span>]   <span class="hljs-number">289.338243</span>:    bpf:bpf_prog_put_rcu: prog=a5ea8fa30ea6849c type=SOCKET_FILTER</code></pre><p>对于BPF程序，会显示单独的程序tag。<br>perf还能捕获XDP引发的异常事件：</p><pre><code class="hljs apache"><span class="hljs-comment"># perf list | grep xdp:</span><span class="hljs-attribute">xdp</span>:xdp_exception                                 <span class="hljs-meta"> [Tracepoint event]</span></code></pre><p>异常触发的场景包括：</p><ul><li>BPF程序返回了无效的XDP action code</li><li>BPF程序返回<code>XDP_ABORTED</code>表示为能优雅退出</li><li>BPF程序返回<code>XDP_TX</code>，但传输过程中出现错误，比如端口未运行、分配失败、传输ring已满等</li></ul><p>还可以将BPF程序加载到一个或多个跟踪点（tracepoints），从而进一步收集信息存储在map中，或是通过<code>bpf_pert_event_output()</code> helper函数来发送到用户空间。</p><h3 id="跟踪管道（tracing-pipe）"><a href="#跟踪管道（tracing-pipe）" class="headerlink" title="跟踪管道（tracing pipe）"></a>跟踪管道（tracing pipe）</h3><p>BPF可以使用<code>bpf_trace_printk()</code>将输出发送到内核的tracing pipe中，用户可以通过如下命令获取其中的内容：</p><pre><code class="hljs gradle"># tail -f <span class="hljs-regexp">/sys/</span>kernel<span class="hljs-regexp">/debug/</span>tracing/trace_pipe...</code></pre><blockquote><p><code>bpf_trace_printk()</code>方法是全局的，并且操作是加锁的，生产环境一般使用。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>与perf类似，BPF程序和map也是受<code>RLIMIT_MEMLOCK</code>限制的，可以通过<code>ulimit -l</code>查看当前可用的系统页数量。<br>默认的限制可能不足以加载复杂的BPF程序或是较大的BPF map，会导致BPF系统调用返回<code>EPERM</code>的<code>errno</code>。可以设置更大的limit或通过<code>RLIMIT_MEMLOCK</code>取消限制。<code>RLIMIT_MEMLOCK</code>通常是针对非特权用户的，一般可以为特权用户设置更高的限制。</p><h2 id="程序类型"><a href="#程序类型" class="headerlink" title="程序类型"></a>程序类型</h2><p>目前，BPF共有18种程序类型，其中网络主要是两类：XDP与tc。</p><h3 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h3><p>XDP是eXpress Data Path的缩写，处理点在软件层面能达到的最早的地方，即驱动收到数据包的时候。因此，XDP处理的数据包未进行<code>skb</code>的构建，也未经过GRO的处理。<br>XDP将数据留在内核中处理的优点（相比于DPDK）：</p><ul><li>XDP可以利用上游的内核网络驱动程序、用户空间的工具，以及BPF helper函数（可以访问路由表、socket这些内核网络基础设施）。</li><li>由于在内核中，因此可以和内核其余模块一样，使用类似的安全模型来访问硬件设备。</li><li>无需进行内核与用户空间的跨越，另外由于处理的数据包不出内核，可以灵活地转发到另外的Namespace中。</li><li>可以从XDP中向内核转发数据包，利用内核的TCP/IP协议栈。</li><li>完全的可编程，并且ABI的稳定性可以得到保证。相比于一般的内核模块，由于使用了BPF验证器，安全更能得到保证。</li><li>可以在运行时原子的替换BPF程序，而不中断流量。</li><li>XDP可以灵活得到集成到内核中，比如可以运行在“busy polling”与”interrupt driven”两种模式 （前者轮询，后者中断），不需要占用单独的CPU，也不需要特殊的硬件支持或是hugepages。</li><li>无需第三方的内核模块或许可。</li><li>主流发行版中，内核4.8+的版本都支持XDP，支持主流的万兆网络驱动。</li></ul><p>作为驱动程序中运行的BPF，XDP确保数据包以线性的方式存储在单个DMA页上，以供BPF程序读写。XDP还能使用256字节的额外的headroom，可以通过<code>bpf_xdp_adjust_head()</code>实现自定义的数据包封装，或是通过<code>bpf_xdp_adjust_meta()</code>来在数据包前添加自定义的元数据。<br>XDP允许直接对数据包进行访问，程序可以将指向数据包的指针保存在寄存器中，加载数据包的数据到寄存器，将寄存器中的数据写入数据包。</p><h4 id="XDP的上下文"><a href="#XDP的上下文" class="headerlink" title="XDP的上下文"></a>XDP的上下文</h4><p>XDP的上下文（ctx）：</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xdp_buff</span> &#123;</span>    <span class="hljs-keyword">void</span> *data;    <span class="hljs-keyword">void</span> *data_end;    <span class="hljs-keyword">void</span> *data_meta;    <span class="hljs-keyword">void</span> *data_hard_start;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xdp_rxq_info</span> *<span class="hljs-title">rxq</span>;</span>&#125;;</code></pre><p><code>data</code>指向页中数据包的开始位置，<code>data_end</code>指向数据包结束位置，<code>data_hard_start</code>指向可能的最大headroom开始的地方，封装后通过<code>bpf_xdp_adjust_head()</code>调整<code>data</code>，解封后也一样。</p><blockquote><p>headroom与tailroom分别是包data前后分配的空间，封装时，会在data前添加封装头，data指针向headroom靠近，反之远离。</p></blockquote><p><code>data_meta</code>开始时与<code>data</code>指向相同的地方，可以通过<code>bpf_xdp_adjust_meta()</code>来将指针向<code>data_hard_start</code>方向进行调整，来保存自定义的元数据。<code>data_meta</code>与<code>data</code>之间保存的自定义元数据在常规内核网络协议栈中是不可见的，只可用于tc BPF读取。相同的，使用<code>bpf_xdp_adjust_meta()</code>将指针向<code>data</code>方向移动，能删除自定义的元数据。<code>data_meta</code>可以用于在尾调的函数之间传递状态，类似于tc BPF用<code>skb-&gt;cb[]</code>传递状态。<br>上面指针之间的关系：<code>data_hard_start</code> &lt;= <code>data_meta</code> &lt;= <code>data</code> &lt; <code>data_end</code>。<br><code>rxq</code>保存单个接收队列的元数据。</p><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xdp_rxq_info</span></span> &#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span></span> *dev;    <span class="hljs-built_in">u32</span> queue_index;    <span class="hljs-built_in">u32</span> reg_state;&#125; ____cacheline_aligned;</code></pre><p>BPF程序可以通过<code>netdevice</code>获取<code>queue_index</code>或其他信息，比如<code>ifindex</code>等。</p><h4 id="XDP的返回值"><a href="#XDP的返回值" class="headerlink" title="XDP的返回值"></a>XDP的返回值</h4><p>XDP的返回值用于指示下一步如何处理数据包，定义在<code>linux/bpf.h</code>中：</p><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">xdp_action</span> &#123;</span>    XDP_ABORTED = <span class="hljs-number">0</span>,    XDP_DROP,    XDP_PASS,    XDP_TX,    XDP_REDIRECT,&#125;;</code></pre><ul><li><code>XDP_DROP</code>丢弃不再浪费资源进行处理。DDoS中常用。</li><li><code>XDP_PASS</code>继续进入内核协议栈进行处理，是没有XDP程序时，数据包的默认行为。<code>XDP_PASS</code>意味着当前CPU会转而去处理数据包的<code>skb</code>分配，传递数据包到GRO中。</li><li><code>XDP_TX</code>从接收的网卡中发出，可用于实现负载均衡（在XDP BPF中对数据包进行重写）</li><li><code>XDP_REDIRECT</code>类似于<code>XDP_TX</code>，但是是从其他NIC中发出，类似于转发。另外<code>XDP_REDIRECT</code>可以将数据包转发到BPF cpumap中，意味着用于处理XDP的CPU会仍然处理XDP，而将需要进入内核协议栈的数据包交由其它CPU处理，这种情况类似于<code>XDP_PASS</code>，但CPU不会处理发送数据包到内核协议栈的工作，因此XDP处理性能会更高。</li><li><code>XDP_ABORTED</code>用于表示程序中的异常状态，与<code>XDP_DROP</code>的行为相同，但会传递到<code>trace_xdp_exception</code>的tracepoint中。</li></ul><h4 id="XDP主要使用场景"><a href="#XDP主要使用场景" class="headerlink" title="XDP主要使用场景"></a>XDP主要使用场景</h4><ul><li><p><strong>DDoS防御，防火墙</strong><br>由于可以通过<code>XDP_DROP</code>在早期就丢弃数据包，因此很适合处理DDoS攻击。更普遍的情况是使用BPF实现任何类型的防火墙。比如作为独立式设备（stand alone appliance），通过<code>XDP_TX</code>进行流量“清理”，或是广泛部署节点上来保护终端设备。offload XDP通过NIC线性速率的处理，提供更高的性能。</p></li><li><p><strong>转发或负载均衡</strong><br>可以通过<code>XDP_TX</code>与<code>XDP_REDIRECT</code>来转发或进行负载均衡。XDP BPF可以对数据包进行任意的处理，可以在发送之前进行封装或解封。<code>XDP_REDIRECT</code>可以与BPF cpumap使用，将数据包负载均衡到本地的协议栈中。</p></li><li><p><strong>协议栈之前的过滤或处理</strong><br>可以在协议栈之前过滤掉无关的数据包，比如我们已知此节点只处理TCP，那么就能DROP掉UDP、SCTP以及其他4层协议的包。此外，如果在内核接收路径上存在某个潜在的BUG可能会导致“ping of death”，可以通过XDP来过滤掉这些可能触发BUG的数据包。<br>另一个使用场景是在数据包进入协议栈前对数据包进行修改。比如这种自定义封装协议的场景下，可能由于GRO对封装协议的不支持而导致无法进行数据包的聚合，则可以通过XDP进行先解封。或者是通过写入元数据（对内核协议栈不可见），来与tc BPF协调处理。</p></li><li><p><strong>流量的采样与监控</strong><br>XDP可以用于流量的采样、监控或者网络分析。可以将数据包（截断的或是完整的payload）或者是用户自定义的元数据发送到无锁、per CPU的内存映射缓冲区，缓冲区由linux perf基础设施提供，供用户空间的应用读取。<br>此外还可以对流量的初始数据包进行分析，一旦判定是正常流量后，对此流量不再进行监控。</p></li></ul><p>XDP生产环境使用案例：Facebooks的SHIV和Droplet，前者用于4层负载，后者用于抗DDoS，相比IPVS性能提升了10倍以上。</p><ul><li>Slides: <a href="https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf">https://netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf</a></li><li>Video:<a href="https://youtu.be/YEU2ClcGqts">https://youtu.be/YEU2ClcGqts</a></li></ul><p>另一个案例：Cloudflare的抗DDoS使用了XDP，原来使用的是cBPF与iptables的<code>xt_bpf</code>，由于使用了iptables，在面临DDoS时，会有性能的下降。</p><ul><li>Slides：<a href="https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf">https://netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf</a></li><li>Video：<a href="https://youtu.be/7OuOukmuivg">https://youtu.be/7OuOukmuivg</a></li></ul><h4 id="XDP的操作模式"><a href="#XDP的操作模式" class="headerlink" title="XDP的操作模式"></a>XDP的操作模式</h4><ul><li><p><strong>Native XDP</strong><br>默认模式，运行在网络驱动的早期接收路径上。需要网卡的支持。</p></li><li><p><strong>Offloaded XDP</strong><br>将XDP offload到NIC上，使用NIC处理，而非本机的CPU，性能最高。需要支持多线程、多核处理的SmartNIC支持。可能不支持部分BPF helper。一般支持此模式的NIC，都支持Native XDP。</p></li><li><p><strong>Generic XDP</strong><br>一般用于不支持Native XDP的场景，代码运行的位置在协议栈靠后部分。</p></li></ul><h4 id="驱动支持"><a href="#驱动支持" class="headerlink" title="驱动支持"></a>驱动支持</h4><p>从内核4.17支持的情况：<br>** 支持native XDP**</p><ul><li><p><strong>Broadcom</strong></p><ul><li>bnxt</li></ul></li><li><p><strong>Cavium</strong></p><ul><li>thunderx</li></ul></li><li><p><strong>Intel</strong></p><ul><li>ixgbe</li><li>ixgbevf</li><li>i40e</li></ul></li><li><p><strong>Mellanox</strong></p><ul><li>mlx4</li><li>mlx5</li></ul></li><li><p><strong>Netronome</strong></p><ul><li>nfp</li></ul></li><li><p><strong>Others</strong></p><ul><li>tun</li><li>virtio_net</li></ul></li><li><p><strong>Qlogic</strong></p><ul><li>qede</li></ul></li><li><p><strong>Solarflare</strong></p><ul><li>sfc <a href="https://docs.cilium.io/en/stable/bpf/#id4">[1]</a></li></ul></li></ul><p><strong>支持offloaded XDP</strong></p><ul><li><strong>Netronome</strong><ul><li>nfp <a href="https://docs.cilium.io/en/stable/bpf/#id5">[2]</a></li></ul></li></ul><h3 id="TC"><a href="#TC" class="headerlink" title="TC"></a>TC</h3><p>除了XDP外，BPF还可以在tc层运行 ，两者的区别在于：</p><ul><li><p>上下文不一样，tc的是<code>sk_buff</code>，而XDP是<code>xdp_buff</code>。内核在收到数据包，经过XDP那一层后，需要为数据包分配空间、解析并存储到<code>sk_buff</code>结构中。因此tc可以利用<code>sk_buff</code>中包含的数据包的元数据，但<code>sk_buff</code>的创建也会带来性能的损耗。XDP由于在<code>sk_buff</code>生成之前，因此无法利用<code>sk_buff</code>中的数据包元数据。<br>  tc BPF可以读写<code>sk_buff</code>中的<code>mark</code>, <code>pkt_type</code>, <code>protocol</code>, <code>priority</code>, <code>queue_mapping</code>, <code>napi_id</code>, <code>cb[]</code>,<code>hash</code>, <code>tc_classid</code>或者<code>tc_index</code>,vlan数据,XDP写入的自定义元数据等。<code>sk_buff</code>的定义在<code>linux/bpf.h</code>下。<br>  <code>sk_buff</code>与<code>xdp_buff</code>各有优劣势：<code>sk_buff</code>可以方便的处理相关的数据包元数据，而<code>xdp_buff</code>则不行。但<code>sk_buff</code>很难通过重写数据包字段来切换协议，因为协议栈处理数据包时依据其元数据，而非每次都读取数据包来判断协议。因此需要额外的BPF helper函数来处理元数据。而<code>xdp_buff</code>则可以直接对数据包进行重写 ，因为此时还不存在 <code>sk_buff</code>以及其中的元数据。一般可以XDP与tc配合使用（通过XDP的自定义元数据来与tc进行数据传递）。</p><ul><li><p>XDP只能在ingress路径上触发，tc能在ingress和egress路径上触发。tc中的两个hook：<code>sch_handle_ingress()</code>和<code>sch_handle_egress()</code>分别由内核中的<code>__netif_receive_skb_core()</code>和<code>__dev_queue_xmit()</code>触发。不考虑XDP，后面两个函数是每个数据包进入和发出都会经过的。</p></li><li><p>tc不需要NIC的支持。对于ingress，tc在内核的处于GRO之后，但在任何协议处理、iptable防火墙（例如PREROUTING、nftable ingress hook、或其他数据包处理）之前；对于egress，tc在数据包交于driver传输之前的最后一段，即在iptables防火墙（例如POSTROUTING）之后，但在GSO之前。唯一需要驱动支持的tc是offload的场景，与XDP offload类似，但两者的上下文、支持的helper函数以及返回值不一样。</p></li></ul></li></ul><h4 id="tc-bpf的分类器"><a href="#tc-bpf的分类器" class="headerlink" title="tc bpf的分类器"></a>tc bpf的分类器</h4><p>tc BPF运行在<code>cls_bpf</code>分类器中，虽然<code>cls_bpf</code>也称为分类器，但它可以做到完全的可编程的数据包处理，包括对<code>skb</code>元数据和包数据进行读取、更改、返回tc action。<code>cls_bpf</code>可被认为是一个用于管理tc BPF程序的独立的实体。</p><p><code>cls_bpf</code>可以包含一个或多个tc bpf程序。Cilium中<code>cls_bpf</code>在<code>direct-action</code>模式下，只包含一个tc bpf程序。传统的，分类器classifier与动作action是分开的，一个分类器可以有多个action，即当分类器匹配成功后实施多个action。这种模式不适合扩展复杂的处理逻辑 ，而tc bpf可以将解析（类似分类匹配）和action结合在一起，并且在<code>cls_bpf</code>的<code>direct-action</code>模式下，只会获取tc bpf返回的tc action，然后终止程序，这样可以通过编程来扩展复杂的处理逻辑。<code>cls_bpf</code>是唯一支持这种模式的“分类器”。</p><p>与XDP BPF相同，tc BPF也可以无缝切换，无需重启或中断流量。</p><p><code>cls_bpf</code>可以被attach到ingress或egress hook上，而ingress hook与egress hook是由<code>sch_clsact</code>  qdisc管理的，它可以直接替换ingress qdisc，是ingress qdisc的超集。对于<code>__dev_queue_xmit()</code>中的tc egresss hook，它不在qdisc root lock下执行，因此tc的ingress和egress都是在无锁下执行，且禁止抢占，在RCU读侧运行。</p><p>在典型的egress qdiscs中，比如 <code>sch_mq</code>, <code>sch_fq</code>, <code>sch_fq_codel</code> 或 <code>sch_htb</code>，有些是分类型qdiscs，他们包含一些子类，利用数据包的分类机制来对数据包进行分类，这个过程是由<code>tcf_classify()</code>调用相应的分类器来实现的。<code>cls_bpf</code>也可作为分类器被调用，但这种过程一般是在qdisc root lock下执行的，会产生锁的竞争。而<code>sch_clsact</code>的egress hook处于处理流程中更早的阶段，不在qdisc root lock的范围内。因此对于<code>sch_htb</code>来说，<code>sch_clsact</code>可以无锁下通过tc BPF进行复杂的数据包分类，将分类结果记录到<code>skb-&gt;mark</code>或是<code>skb-&gt;priority</code>中，而<code>sch_htb</code>只需要在qdisc root lock下，实现简单的映射，从而减少了锁的竞争。</p><p><code>sch_clsact</code>与<code>cls_bpf</code>结合使用的场景也支持offload tc bpf，bpf会通过JIT编译，然后运行在NIC上。只有<code>cls_bpf</code>的<code>direct-action</code>支持offload，并且只支持包含单个bpf程序，只支持ingress。</p><p>当一个<code>cls_bpf</code>内包含多个bpf程序时，当bpf返回<code>TC_ACT_UNSPEC</code>，则会继续执行下一个tc bpf。但这样做的缺点是各个BPF程序需要各自解析数据包 ，从而导致性能下降。</p><h4 id="TC-BPF的返回值"><a href="#TC-BPF的返回值" class="headerlink" title="TC BPF的返回值"></a>TC BPF的返回值</h4><p>ingress和egress共用返回值，在<code>linux/pkg_cls.h</code>下定义：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_UNSPEC         (-1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_OK               0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_SHOT             2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_STOLEN           4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TC_ACT_REDIRECT         7</span></code></pre><p>在头文件中还提供了一些其他的<code>TC_ACT_*</code>的返回值，也可以用于ingress和egress。但他们语义相同，<code>TC_ACT_OK</code>和<code>TC_ACT_RECLASSIFY</code>的语义相同，<code>TC_ACT_STOLEN</code>、<code>TC_ACT_QUEUED</code>和<code>TC_ACT_TRAP</code>的语义相同。</p><ul><li><p><code>TC_ACT_UNSPEC</code>，表示”unspecified action”，用于以下三种情况：</p><p>i）加载了offload tc BPF，且运行了tc ingress hook，则代表offload  tc BPF的<code>cls_bpf</code>将返回<code>TC_ACT_UNSPEC</code></p><p>ii）在<code>cls_bpf</code>包含多个bpf程序的情况下，为了执行下一个bpf程序。这种情况可以与第一点中的offload tc bpf一起使用。执行完offload tc BPF后，再执行下一个非offload的tc BPF。</p><p>iii）在单bpf程序下，表示数据包<code>skb</code>继续进行内核的处理。此时<code>TC_ACT_UNSPEC</code>类似于<code>TC_ACT_OK</code>，都是将<code>skb</code>发送到上层内核协议栈进行进一步处理，或是发送给网络驱动来发出数据包。不同的地方在于<code>TC_ACK_OK</code>会根据tc BPF程序的classid设置<code>skb-&gt;tc_index</code>，而<code>TC_ACT_UNSPEC</code>是在tc BPF程序外，根据BPF  ctx中的<code>skb-&gt;tc_classid</code>设置。</p></li><li><p><code>TC_ACT_SHOT</code>表示Drop。<code>TC_ACT_SHOT</code>与<code>TC_ACT_STOLEN</code>相似，但有区别：前者通过<code>kfree_skb()</code>来释放<code>skb</code>，并返回<code>NET_XMIT_DROP</code>。后者通过<code>consume_skb()</code>来释放<code>skb</code>，然后返回<code>NET_XMIT_SUCCESS</code>来假装传输成功。因此监视<code>kfree_skb()</code>的perf不会记录到<code>TC_ACK_STOLEN</code>引起的drop，因为语义上，<code>skb</code>不是”dropped”，而是”consumed”。</p></li><li><p><code>TC_ACT_REDIRECT</code>用于转发，结合<code>bpf_redirect()</code> helper函数，将<code>skb</code>转发到相同的、或是不同的设备的ingress、或是egress。对于转发的目标设备来说，不需要设备上运行BPF或是有其他限制要求，只需要是个网络设备</p></li></ul><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p><strong>作为tc action模块的<code>act_bpf</code>是否可用？</strong></p><p>不常用。虽然<code>act_bpf</code>与<code>cls_bpf</code>对tc BPF来说功能是一样的，但<code>cls_bpf</code>作为<code>act_bpf</code>的超集，使用起来更灵活。tc action需要挂载到某个tc classifiers上，为了和<code>cls_bpf</code>一样，<code>act_bpf</code>需要挂载到<code>cls_matchall</code>的分类器上，这种分类器会匹配任何流量，发送到action中进行处理。这种使用方式性能不如<code>cls_bpf</code>，如果<code>act_bpf</code>使用除<code>cls_bpf</code>和<code>cls_matchall</code>以外的分类器，则会更糟。因为数据包可能需要经过多个分类器后才会被匹配，从而发送给<code>act_bpf</code>处理。因此<code>act_bpf</code>没有太大的使用场景，另外，<code>act_bpf</code>没有实现tc offload的接口。</p></li></ul><ul><li><p><strong>推荐使用<code>cls_bpf</code>的非<code>direct-action</code>模式吗？</strong></p><p>不推荐。主要是考虑复杂处理逻辑的扩展。tc BPF本身已经能够高效地完成各种处理，因此没有必要使用除了<code>direct-action</code>以外的其他action。</p></li></ul><ul><li><p><strong>offload <code>cls_bpf</code>与offload XDP的性能差异</strong></p><p>没有性能差异。两者都是通过内核JIT进行编译，offload到SmartNIC中，加载机制也类似。BPF程序会被转换成相同的目标指令集，以便在NIC上本地运行。两者有不同的特性，可能会为了在offload场景中使用特定的helper函数，而相互替换。</p></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>虽然tc的许多使用场景与XDP是重合的，但是两者大多时候是互补的作用。</p><ul><li><p><strong>容器网络策略的执行</strong></p><p>tc BPF可以用于容器或pod的安全策略、防火墙。通常，容器是使用namespace进行资源隔离，通过veth pair将容器的namespace与宿主机的namespace相连，因此进出的流量都会通过宿主机端的veth，可以在veth设备的ingress hook和egress hook上加载tc BPF，则发送给容器的流量会触发egress，容器发出的流量会触发ingress（注意这里是相反的）。</p><p>对于veth设备使用XDP是不合适的，因为这里内核的操作仅仅是对<code>skb</code>进行的，而XDP会有限制，不能操作克隆的<code>skb</code>。而在TCP/IP协议栈中，为了重传会持有数据片（data segments），使用克隆的<code>skb</code>，这种情况下会直接绕过XDP。其次，XDP处理时需要将<code>skb</code>线性化（linearize，将分页的<code>skb</code>线性化为一个对象），而导致性能下降。tc BPF则是专门用于处理<code>skb</code>的，没有XDP的那些限制。</p></li></ul><ul><li><p><strong>转发或负载均衡</strong></p><p>转发或负载均衡的使用案例和XDP相似，但tc bpf会更倾向于东西向的容器流量，而非南北向流量，虽然两种流量都可以使用XDP和tc。XDP只能作用于ingress，tc则可以作用于egress。例如可以在宿主机上通过BPF对容器的egress流量进行NAT与负载均衡。由于内核网络栈的属性，egress流量是基于<code>sk_buff</code>的，因此tc适合对数据包进行重写或重定向。通过利用<code>bpf_redirect()</code> helper函数，BPF可以将数据包转发到其他设备上，因此也无需使用网桥类的设备。</p></li></ul><ul><li><p><strong>流量的采样与监控</strong></p><p>类似于XDP，采样与监控也是通过一个高性能的、无锁的、per-CPU的内存映射缓冲区实现，tc BPF程序会通过<code>bpf_skb_event_output()</code> helper函数将数据push到缓冲区中，<code>bpf_skb_event_output()</code>功能与<code>bpf_xdp_event_output()</code>是相同的。同样的，tc也能加载到ingress和egress上 ，这样就能监控节点双向的所有流量。这与tcpdump和Wireshark有些类似，但不需要克隆<code>skb</code>，而且更加灵活的处理<code>skb</code>。例如BPF可以在内核里进行聚合，而不是将所有内容都推送到用户空间，或者是推送自定义的注释。在Cilium中使用了大量的自定义注释，用于关联容器标签以及为何需要Drop数据包等，以提供更丰富的信息。</p></li></ul><ul><li><p><strong>数据包调度前的预处理</strong></p><p><code>sch_clsact</code>的egress hook被称为<code>sch_handle_egress()</code>，它在获取qdisc root lock之前调用，因此在数据包进入到真正的例如<code>sch_htb</code>之类的qdisc前，可以通过tc BPF来执行复杂繁重的数据包分类与处理。因为tc BPF的执行是无锁的，通过<code>sch_clsact</code>与真正的qdisc结合使用（比如上面提到的<code>sch_htb</code>），可以提高处理性能。</p></li></ul><p>生产环境的使用案例：Cilium。</p><ul><li>Slides: <a href="https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp">https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp</a></li><li>Video: <a href="https://youtu.be/ilKlmTDdFgk">https://youtu.be/ilKlmTDdFgk</a></li><li>Github: <a href="https://github.com/cilium/cilium">https://github.com/cilium/cilium</a></li></ul><h4 id="驱动支持-1"><a href="#驱动支持-1" class="headerlink" title="驱动支持"></a>驱动支持</h4><p>因为tc BPF是由内核网络协议栈触发的，而非网络驱动触发，因此不依赖与网络驱动。唯一的例外是offload tc BPF。</p><p><strong>支持offload tc BPF的驱动</strong></p><ul><li>Netronome<ul><li>nfp</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JIT技术的介绍：<a href="https://developer.ibm.com/zh/articles/j-lo-just-in-time/#:~:text=JIT%20%E6%98%AFjust%20in%20time,Java%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E3%80%82&text=%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6JIT%20%E4%BC%9A,%E7%9C%8B%EF%BC%8CJIT%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E3%80%82">深入浅出 JIT 编译器</a></p><p><a href="https://zhuanlan.zhihu.com/p/104697246">dwarf格式</a></p><p><a href="https://tech.meituan.com/2015/01/22/linker.html">高级语言的编译：链接及装载过程介绍</a></p><p><a href="http://chuquan.me/2018/05/21/elf-introduce/">计算机那些事(4)——ELF文件结构</a></p><p><a href="https://linux.cn/article-6073-1.html">为什么人人都该懂点LLVM</a></p><p><a href="https://zhuanlan.zhihu.com/p/140462815">LLVM基本概念入门</a></p><p>bbc介绍：<a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md</a><br><a href="https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md">https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md</a></p><p>介绍内核各种track技术的文章：<a href="https://jvns.ca/blog/2017/07/05/linux-tracing-systems/#kprobes">https://jvns.ca/blog/2017/07/05/linux-tracing-systems/#kprobes</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Controller开发利器:controller-runtime</title>
    <link href="/2021/02/26/Kubernetes-Controller%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-controller-runtime/"/>
    <url>/2021/02/26/Kubernetes-Controller%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8-controller-runtime/</url>
    
    <content type="html"><![CDATA[<p>Controller-runtime是一个用于开发Kubernetes Controller的库，包含了各种Controller常用的模块，兼顾了灵活性和模块化。本文使用V0.8.0版本做介绍。</p><a id="more"></a><p>一开始做Kubernetes Controller开发时，是学习<a href="https://github.com/kubernetes/sample-controller">simple-controller</a>使用<a href="https://github.com/kubernetes/client-go">client-go</a>进行开发，中间会有很多与业务无关的重复工作。后来社区推出了<a href="https://github.com/kubernetes-sigs/kubebuilder">kubebuilder</a>，它可以方便的渲染出Controller的整个框架，让开发者只用专注Controller本身的业务逻辑，特别是在开发CRD时，极为方便，而kubebuilder渲染出的框架使用的则是<a href="https://github.com/kubernetes-sigs/controller-runtime">controller-runtime</a>。</p><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><p>Controller-runtime中为Controller的开发提供了各种功能模块，主要包括：</p><ul><li><code>Client</code>：用于读写Kubernetes资源</li><li><code>Cache</code>：本地缓存，可供Client直接读取资源。</li><li><code>Manager</code>：可以管理协调多个Controller，提供Controller共用的依赖。</li><li><code>Controller</code>：“组装”多个模块（例如<code>Source</code>、<code>Queue</code>、<code>Reconciler</code>），实现Kubernetes Controller的通用逻辑：<ul><li>1）监听k8s资源，缓存资源，并根据<code>EventHandler</code>入队事件；</li><li>2）启动多个goroutine，每个goroutine会从队列中获取event，并调用<code>Reconciler</code>方法处理。</li></ul></li><li><code>Reconciler</code>：状态同步的逻辑所在，是开发者需要实现的主要接口，供Controller调用。Reconciler的重点在于“状态同步”，由于Reconciler传入的参数是资源的<code>Namespace</code>和<code>Name</code>，而非event，Reconciler并非用于“处理事件”，而是根据指定资源的状态，来同步“预期集群状态”与“当前集群状态”。</li><li><code>Webhook</code>：用于开发webhook server，实现Kubernetes Admission Webhooks机制。</li><li><code>Source</code>：source of event，Controller从中获取event。</li><li><code>EventHandler</code>：顾名思义，event的处理方法，决定了一个event是否需要入队列、如何入队列。</li><li><code>Predicate</code>：相当于event的过滤器。</li></ul><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="/img/controller-runtime-2021022602.jpg"></p><p>Controller-runtime目的是提供一系列Kubernetes Controller开发的工具，可以从三方面去了解整个Controller-runtime：</p><ul><li>Controller是如何生成与管理？</li><li>开发者如何与集群交互？</li><li>有哪些额外工具可用？</li></ul><h2 id="Controller的生成与管理"><a href="#Controller的生成与管理" class="headerlink" title="Controller的生成与管理"></a>Controller的生成与管理</h2><p>总的来说，<strong>生成Controller用<code>pkg/builder</code>，管理Controller用<code>pkg/manager</code>。</strong></p><h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><p><code>pkg/builder</code>下的<code>Builder</code>可以用于生成Controller，并提供了一系列配置Controller的方法，通过优雅的链式调用，可以组装出自己需要的Controller。</p><p>一般来说，在创建Controller之前，需要先创建manager，因为需要manager提供了创建Controller所需的依赖。下面是一个样例，组装了一个<code>ReplicaSet</code>的<code>Controller</code>，<code>Controller</code>除了监听<code>ReplicaSet</code>外，还会监听Pod，根据Pod的<code>ownerReferences</code>入队相应的<code>ReplicaSet</code>。具体的，先通过<code>ControllerManagerBy()</code>中传入manager，在<code>ControllerManagedBy()</code>和<code>Complete()</code>之间，是一系列对Controller的配置（样例中调用<code>For()</code>和<code>Owns()</code>进行配置），最后在<code>Complete()</code>中，会从manager中获取Controller的依赖，然后和传入的<code>Reconciler</code>一起，用于创建Controller，并将创建的Controller注册到manager中。</p><pre><code class="hljs go">err = builder.ControllerManagedBy(mgr).                  <span class="hljs-comment">// Create the ControllerManagedBy</span>For(&amp;appsv1.ReplicaSet&#123;&#125;).                 <span class="hljs-comment">// ReplicaSet is the Application API</span>Owns(&amp;corev1.Pod&#123;&#125;, builder.OnlyMetadata). <span class="hljs-comment">// ReplicaSet owns Pods created by it, and caches them as metadata only</span>Complete(reconcile.Func(myReconcile))</code></pre><p>除了上面的<code>For()</code>和<code>Owns()</code>外，你还可以对Controller进行更多的配置，比如用<code>WithEventFilter()</code>对Controller的事件进行过滤；用<code>Named()</code>配置Controller的名称等；用<code>Watches()</code>配置其他需要监听的资源。但整体上，你只需要“告诉”Controller “<strong>what to do</strong>“（监听什么资源？对应各种event做何种反应？），而”<strong>how to do</strong>“（如何监听事件，如何缓存对象，如何维护队列）都是由Controller以及其相关依赖完成的。</p><p>在开发复杂的Controller中，你可能要监听多个资源，并且监听的资源与”主资源“（主资源是指<code>For()</code>中配置的资源类型，也是传入<code>Reconciler</code>的元数据所指的资源类型）不存在附属关系，此时<code>Watches()</code>就给了很大的灵活性。<code>Watches()</code>有三个参数，分别为<code>Source</code>、<code>EventHandler</code>、<code>WatchesOption</code>。</p><p>1）<code>Source</code>负责watch相应的资源，将资源的event发送到队列中。其接口只包含一个<code>Start()</code>方法，由Controller调用，用于初始化watch操作所需的相关结构，比如<code>eventHandler</code>、<code>queue</code>等。接口的几个实现在<code>pkg/source/source.go</code>里，开发常使用的，是用于监听K8s的<code>Source</code>实现：<code>Kind</code>。</p><pre><code class="hljs go"><span class="hljs-comment">// Kind is used to provide a source of events originating inside the cluster from Watches (e.g. Pod Create)</span><span class="hljs-keyword">type</span> Kind <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// Type is the type of object to watch.  e.g. &amp;v1.Pod&#123;&#125;</span>Type client.Object<span class="hljs-comment">// cache used to watch APIs</span>cache cache.Cache&#125;</code></pre><p>实际上<code>Kind</code>不实现真正的watch操作，而是通过<code>cache</code>（下面会详细介绍）来watch指定的资源，<code>Kind</code>只是将<code>eventHandler</code>、<code>queue</code>等注册到cache中。使用<code>Kind</code>时，你只需要设置完<code>Type</code>就可以传递给<code>Watches()</code>了，而在后续执行<code>Controller.Watch()</code>时（在<code>Complete()</code>中会调用），会自动调用 manager的<code>SetFields</code>方法注入<code>cache</code>，整个过程对开发人员是透明的。顺便说下，<code>SetFields</code>是Controller用于从manager提取依赖的主要方法，每个Controller都会保存所属的manager的<code>SetFields</code>函数引用。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cm *controllerManager)</span> <span class="hljs-title">SetFields</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> _, err := inject.InjectorInto(cm.SetFields, i); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">if</span> _, err := inject.StopChannelInto(cm.internalProceduresStop, i); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">if</span> _, err := inject.LoggerInto(cm.logger, i); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;  <span class="hljs-comment">// cluster.SetFields可以将cluster内的cache，注入到i中</span><span class="hljs-keyword">if</span> err := cm.cluster.SetFields(i); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><p>2）<code>EventHandler</code>是一个处理各种Event的接口，需要实现的是“对指定事件如何入队列”的逻辑。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> EventHandler <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Create is called in response to an create event - e.g. Pod Creation.</span>Create(event.CreateEvent, workqueue.RateLimitingInterface)<span class="hljs-comment">// Update is called in response to an update event -  e.g. Pod Updated.</span>Update(event.UpdateEvent, workqueue.RateLimitingInterface)<span class="hljs-comment">// Delete is called in response to a delete event - e.g. Pod Deleted.</span>Delete(event.DeleteEvent, workqueue.RateLimitingInterface)<span class="hljs-comment">// Generic is called in response to an event of an unknown type or a synthetic event triggered as a cron or</span><span class="hljs-comment">// external trigger request - e.g. reconcile Autoscaling, or a Webhook.</span>Generic(event.GenericEvent, workqueue.RateLimitingInterface)&#125;</code></pre><p>Controller-runtime已经在<code>pkg/handler</code>下，提供了四类handler：</p><ul><li><code>EnqueueRequestForObject</code>：一个简单的实现，直接将Object的metadata入队列。上面的<code>For()</code>就使用的它。</li><li><code>Enqueue_mapped</code>：用的较多。Object在入队前使用用户实现的映射方法<code>MapFunc()</code>做映射，将映射后的结果入队列。例如可以将<code>Endpoint Event</code>映射为对应的Service，从而入队Service。</li></ul><pre><code class="hljs go"><span class="hljs-keyword">type</span> MapFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(client.Object)</span> []<span class="hljs-title">reconcile</span>.<span class="hljs-title">Request</span></span></code></pre><ul><li><code>Enqueue_owner</code>：将Object的Owner资源入队列，上面的<code>Owns()</code>就使用的它。</li><li><code>Funcs</code>：一个空的父类，需要你实现接口的四个方法。</li></ul><p>3）最后<code>WatchesOption</code>用于修改Watch配置，目前在<code>pkg/builder/options.go</code>中提供两种：</p><ul><li><code>Predicates</code>：用于过滤事件。你可以自己实现，或者在<code>pkg/predicate/predicate.go</code>中有些预设类型，比如<code>AnnotationChangedPredicate</code>只过滤Annotation发生变化的event。</li></ul><pre><code class="hljs go"><span class="hljs-keyword">type</span> Predicate <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Create returns true if the Create event should be processed</span>Create(event.CreateEvent) <span class="hljs-keyword">bool</span><span class="hljs-comment">// Delete returns true if the Delete event should be processed</span>Delete(event.DeleteEvent) <span class="hljs-keyword">bool</span><span class="hljs-comment">// Update returns true if the Update event should be processed</span>Update(event.UpdateEvent) <span class="hljs-keyword">bool</span><span class="hljs-comment">// Generic returns true if the Generic event should be processed</span>Generic(event.GenericEvent) <span class="hljs-keyword">bool</span>&#125;</code></pre><ul><li><code>OnlyMetadate</code>：用于告诉Controller，只缓存Watch对象的Metadata数据，用于提升性能。</li></ul><h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><p>manager主要是提供了Controller的依赖，并控制Controller的运行，通过如下函数创建。manager对Controller提供的许多依赖都包含在<code>Cluster</code>中，我们后面介绍，这里先介绍manager对Controller运行的控制。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(config *rest.Config, options Options)</span> <span class="hljs-params">(Manager, error)</span></span>&#123;&#125;</code></pre><p>准确的来说，manager不是控制Controller，而是控制更广泛意义上的“可运行程序”，向manager中注册的都是接口<code>Runnable</code>，你可以注册一个http server到manager中，用manager来启动http server，只要http server实现了对应的<code>Start()</code>接口。要向一个manager中注册<code>Runnable</code>可以使用接口<code>Manager.Add()</code>，上面的<code>Builder.Complete()</code>就调用了此接口。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Runnable <span class="hljs-keyword">interface</span> &#123;Start(context.Context) error&#125;</code></pre><p>当一个Runnable通过<code>Manager.Add()</code>方法注册到manager中后，manger会根据<code>Runnable</code>是否受“选举机制”的影响，将其分类到<code>leaderElectionRunnables</code>或<code>nonLeaderElectionRunnables</code>两个数组中，依据<code>Runnable</code>可能实现的<code>func NeedLeaderElection() bool</code>方法的返回值进行划分，未实现此方法的会被归类到<code>leaderElectionRunnables</code>中。</p><p>在调用<code>Manager.Start()</code>方法以启动manager后，manager会通过goroutine运行所有注册的<code>Runnable</code>，对于<code>nonLeaderElectionRunnables</code>会直接运行，对于<code>leaderElectionRunnables</code>会根据选举结果运行。在启动manager后，仍然可以通过<code>Manager.Add()</code>方法将其他的<code>Runnable</code>注册到manager中，一旦注册，<code>Runnable</code>就会进入到上面的运行流程。</p><p>manager的选举机制使用<code>k8s.io/client-go/tools/leaderelection</code>实现，可以通过创建manager时传入的<code>manager.Options</code>参数设置，其他更详细的实现可以查看<code>pkg/manager/internal.go</code>。</p><h2 id="与集群的交互"><a href="#与集群的交互" class="headerlink" title="与集群的交互"></a>与集群的交互</h2><p>一般开发Controller需要涉及到与集群的交互，例如从集群或缓存中的操作某个资源；生成K8s Event并记录到集群中。这些功能主要由<code>Cluster</code>接口提供，而<code>Manager</code>接口直接继承了<code>Cluster</code>接口，因此，一般直接使用<code>Manager</code>调用相应的方法。另外，各个Controller也会通过<code>Manager</code>从<code>Cluster</code>中获取集群相关的依赖，例如<code>Scheme</code>、<code>RESTMapper</code>等。</p><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p><code>Cluster</code>提供各种与集群相关的方法，开发者常用的接口包括：</p><ul><li>通过<code>Cluster.GetEventRecorderFor()</code>获取用于记录K8s Event的Recorder。</li><li>通过<code>Cluster.GetClient()</code>获取K8s的Client，用于读写。</li><li>通过<code>Cluster.GetCache()</code>获取后端的Cache。</li></ul><p>另外，<code>Cluster</code>也会为Controller的创建提供共同的依赖，例如：</p><ul><li>在<code>Controller.Watch()</code>中，会通过<code>Cluster.SetFields()</code>注入<code>cache</code>、<code>RESTMapper</code>等。</li><li>在<code>Builder.Complate()</code>中，会通过<code>Cluster.Scheme()</code>获取<code>Scheme</code>，从而获取<code>Source</code>对应的<code>GroupVersionKind</code>。</li></ul><p><code>Cluster</code>的详细实现在<code>pkg/cluster</code>下，里面主要涉及两个关键类型：<code>Client</code>和<code>Cache</code>。</p><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p><code>Cache</code>开发者很少直接使用，因为一般不会直接对<code>Cache</code>进行操作。在Controller-runtime中，<code>Cache</code>的实现是<code>InformerCache</code>，当然，你也可以不使用自定义的Cache实现，通过创建manager时，设置<code>manager.Options.NewCache</code>参数，传入Cache的创建函数。</p><p>从下图可以看到，<code>InformerCache</code>中包含了三组<code>specificInformersMap</code>，分别用于支持<code>structured</code>、<code>unstructured</code>、<code>metadata</code>三种资源类型，实现三类资源的List-watch。而<code>specificInformersMap</code>中包含了一个key为<code>GroupVersionKind</code>、value为<code>MapEntry</code>的Map类型，是为了支持多种资源的监听。<code>MapEntry</code>类似于<code>Client-go</code>中的<code>GenericInformer</code>，里面包含了<code>Client-go</code>中的<code>SharedIndexInformer</code>和<code>Index</code>，因此最终仍然是使用<code>SharedIndexInformer</code>实现资源的List-watch ，使用<code>Index</code>作为本地的缓存。</p><p><img src="/img/controller-runtime-2021022601.jpg"></p><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>Controller-runtime实现了多种Client，开发人员一般可以通过<code>Manager.GetClient()</code>与<code>Manager.GetAPIReader()</code>获取manager的Client，区别在于:</p><p>1）<code>Manager.GetClient()</code>返回的Client可以用于Get、Update、Patch、Create等多种操作，但在Get、List时，优先从<code>cache</code>中的读取；</p><p>2）<code>Manager.GetAPIReader()</code>返回的Reader对象用于读操作，但会直接通过请求Kube-apiserver来获取结果。</p><p>与Cache一样，<code>Manager.GetClient()</code>返回的Client也支持操作<code>structured</code>、<code>unstructured</code>、<code>metadata</code>三种资源类型。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> client <span class="hljs-keyword">struct</span> &#123;typedClient        typedClientunstructuredClient unstructuredClientmetadataClient     metadataClient...&#125;</code></pre><p>开发人员还可以自己定义manager使用的Client，或者自定义Client是否使用Cache，通过创建manager时，设置<code>manager.Options</code>相关的参数。</p><pre><code class="hljs go"><span class="hljs-comment">// manager.Options健康检查的配置</span><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;  ...  <span class="hljs-comment">// 自定义Client的创建方法</span>ClientBuilder ClientBuilder<span class="hljs-comment">// 设置哪些类型的资源不使用Cache</span>ClientDisableCacheFor []client.Object    ...&#125;</code></pre><h2 id="额外工具"><a href="#额外工具" class="headerlink" title="额外工具"></a>额外工具</h2><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>在manager中集成了健康检查的功能，你可以通过<code>Manager.AddHealthzCheck()</code>与<code>Manager.AddReadyzCheck()</code>方法，注册自己的监控检查逻辑。在<code>Manager.Start()</code>中，会启动一个HTTP Server，提供监控检查的返回结果，HTTP Server的端口、URL可以在创建Manager时，通过<code>manager.Options</code>进行配置。</p><pre><code class="hljs go"><span class="hljs-comment">// manager.Options健康检查的配置</span><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;...  <span class="hljs-comment">// HealthProbeBindAddress is the TCP address that the controller should bind to</span><span class="hljs-comment">// for serving health probes</span>HealthProbeBindAddress <span class="hljs-keyword">string</span><span class="hljs-comment">// Readiness probe endpoint name, defaults to &quot;readyz&quot;</span>ReadinessEndpointName <span class="hljs-keyword">string</span><span class="hljs-comment">// Liveness probe endpoint name, defaults to &quot;healthz&quot;</span>LivenessEndpointName <span class="hljs-keyword">string</span>    ...&#125;</code></pre><h3 id="metric"><a href="#metric" class="headerlink" title="metric"></a>metric</h3><p>Controller-runtime内置了许多<code>prometheus</code>的监控指标，主要在<code>pkg/metrics</code>下，定义了<code>Client</code>、<code>Refecltor</code>（Informer中的模块，负责List-Watch资源，并存储到缓存中）以及<code>workQueue</code>相关的监控指标。除此之外在<code>pkg/internal/controller/metrics</code>下还定义Controller状态同步的相关监控指标。</p><p>在manager启动时，会相应的启动metrics server，开发人员还可以通过<code>manager.Options</code>配置metrics server的端口，或是通过<code>pkg/metrics</code>下的<code>Registry</code>方法自定义监控指标。</p><pre><code class="hljs go"><span class="hljs-comment">// manager.Options监控的配置</span><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;  ...    MetricsBindAddress <span class="hljs-keyword">string</span>    ...&#125;</code></pre><h3 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h3><blockquote><p>webhook模块目前我还未使用过，后续使用后再补充。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Controller</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[笔记]Linux Socket Filtering aka Berkeley Packet Filter (BPF)</title>
    <link href="/2021/02/24/%E7%AC%94%E8%AE%B0-Linux-Socket-Filtering-aka-Berkeley-Packet-Filter-BPF/"/>
    <url>/2021/02/24/%E7%AC%94%E8%AE%B0-Linux-Socket-Filtering-aka-Berkeley-Packet-Filter-BPF/</url>
    
    <content type="html"><![CDATA[<p>本文是阅读<a href="https://www.kernel.org/doc/Documentation/networking/filter.txt">linux/Documentation/networking/filter.txt</a>文档的笔记。</p><p>学习BPF的过程：</p><ul><li>阅读相关文献，记录两篇的笔记。另一篇的链接<a href="https://maao.cloud/2021/03/01/%E7%AC%94%E8%AE%B0-BPF-and-XDP-Reference-Guide-cilium/">[笔记]BPF and XDP Reference Guide(cilium)</a></li></ul><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>BPF(Berkeley Packet Filter)允许用户空间程序将过滤器（filter）附加到任何套接字（socket）上，来允许或禁止某些类型的数据通过套接字。可以通过<code>SO_DETACH_FILTER</code>从套接字中卸载filter，但一般使用不到，因为一旦socket关闭，其上的filter也会自动移除。</p><p>可以通过<code>SO_LOCK_FILTER</code>选项为某个filter加锁，加锁后，filter不可在更改或移除，直到socket关闭。</p><p><code>tcpdump</code>通过<code>libpcap</code>的内部编译器生成可加载的指令，通过调用<code>SO_ATTACH_FILTER</code>加载到内核中。</p><p>除socket外，BPF可附加到内核其他地方：netfilter的xt_bpf，内核qdisc层的cls_bpf。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><pre><code class="hljs rust"><span class="hljs-comment">// 在&lt;linux/filter.h&gt;中</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span></span> &#123;<span class="hljs-comment">/* Filter block */</span>__<span class="hljs-built_in">u16</span>code;   <span class="hljs-comment">/* Actual filter code */</span>__<span class="hljs-built_in">u8</span>jt;<span class="hljs-comment">/* Jump true */</span>__<span class="hljs-built_in">u8</span>jf;<span class="hljs-comment">/* Jump false */</span>__<span class="hljs-built_in">u32</span>k;      <span class="hljs-comment">/* Generic multiuse field (一般为code需要使用的value）*/</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog</span></span> &#123;<span class="hljs-comment">/* Required for SO_ATTACH_FILTER. */</span>unsigned short   len;<span class="hljs-comment">/* Number of filter blocks */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span></span> __user *filter;&#125;;</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="hljs angelscript">#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;linux/if_ether.h&gt;<span class="hljs-comment">/* ... */</span><span class="hljs-comment">/* From the example above: tcpdump -i em1 port 22 -dd */</span>struct sock_filter code[] = &#123;&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000000c</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">0x000086dd</span> &#125;,&#123; <span class="hljs-number">0x30</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000014</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000084</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000006</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0x00000011</span> &#125;,&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000036</span> &#125;,&#123; <span class="hljs-number">0x15</span>, <span class="hljs-number">14</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000016</span> &#125;,&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000038</span> &#125;,&#123; <span class="hljs-number">0x15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0x00000016</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0x00000800</span> &#125;,&#123; <span class="hljs-number">0x30</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000017</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000084</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000006</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">0x00000011</span> &#125;,&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000014</span> &#125;,&#123; <span class="hljs-number">0x45</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00001fff</span> &#125;,&#123; <span class="hljs-number">0xb1</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000000e</span> &#125;,&#123; <span class="hljs-number">0x48</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000000e</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000016</span> &#125;,&#123; <span class="hljs-number">0x48</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000010</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0x00000016</span> &#125;,&#123; <span class="hljs-number">0x06</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000ffff</span> &#125;,&#123; <span class="hljs-number">0x06</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x00000000</span> &#125;,&#125;;struct sock_fprog bpf = &#123;.len = ARRAY_SIZE(code),.filter = code,&#125;;  <span class="hljs-comment">/*创建PF_PACKET socket*/</span> sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));<span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">/* ... bail out ... */</span>ret = setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;bpf, sizeof(bpf));<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<span class="hljs-comment">/* ... bail out ... */</span><span class="hljs-comment">/* ... */</span>close(sock);</code></pre><p><code>setsockopt</code>系统调用，调用<code>SO_DETACH_FILTER</code>时无需参数，调用<code>SO_LOCK_FILTER</code>时，参数为1或0：</p><pre><code class="hljs lisp">* setsockopt(<span class="hljs-name">sockfd</span>, SOL_SOCKET, SO_ATTACH_FILTER, <span class="hljs-symbol">&amp;val</span>, sizeof(<span class="hljs-name">val</span>))<span class="hljs-comment">;</span>* setsockopt(<span class="hljs-name">sockfd</span>, SOL_SOCKET, SO_DETACH_FILTER, <span class="hljs-symbol">&amp;val</span>, sizeof(<span class="hljs-name">val</span>))<span class="hljs-comment">; </span>* setsockopt(<span class="hljs-name">sockfd</span>, SOL_SOCKET, SO_LOCK_FILTER,   <span class="hljs-symbol">&amp;val</span>, sizeof(<span class="hljs-name">val</span>))<span class="hljs-comment">;</span></code></pre><p><code>libpcap</code>覆盖了绝大多数socket filter的用例，一般直接使用<code>libpcap</code>进行开发。</p><h2 id="BPF引擎（engine）和指令集"><a href="#BPF引擎（engine）和指令集" class="headerlink" title="BPF引擎（engine）和指令集"></a>BPF引擎（engine）和指令集</h2><p><code>tool/bpf/</code>目录下的<code>bgf_asm</code>可以用来编写底层的filter。</p><p>BPF包含一个32位累加器A、32位寄存器X、16 x  32位的临时存储：</p><pre><code class="hljs lsl">Element          DescriptionA                <span class="hljs-number">32</span> bit wide accumulatorX                <span class="hljs-number">32</span> bit wide X registerM[]              <span class="hljs-number">16</span> x <span class="hljs-number">32</span> bit wide misc registers aka <span class="hljs-string">&quot;scratch memory</span><span class="hljs-string">                 store&quot;</span>, addressable from <span class="hljs-number">0</span> to <span class="hljs-number">15</span></code></pre><p><code>bpf_asm</code>转换生成的程序是一个如下结构的数组。</p><pre><code class="hljs angelscript">op:<span class="hljs-number">16</span>, jt:<span class="hljs-number">8</span>, jf:<span class="hljs-number">8</span>, k:<span class="hljs-number">32</span></code></pre><ul><li><code>op</code> ： 16位的指令</li><li><code>jt</code> <code>jf</code>:  jump if true, jump if false</li><li><code>k</code>：参数</li></ul><p>在<code> linux/filter.h</code>下的指令以及相应的寻址方式：</p><pre><code class="hljs angelscript">Instruction      Addressing mode      Description  ld               <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>       Load word <span class="hljs-built_in">int</span>o A  ldi              <span class="hljs-number">4</span>                    Load word <span class="hljs-built_in">int</span>o A  ldh              <span class="hljs-number">1</span>, <span class="hljs-number">2</span>                 Load half-word <span class="hljs-built_in">int</span>o A  ldb              <span class="hljs-number">1</span>, <span class="hljs-number">2</span>                 Load byte <span class="hljs-built_in">int</span>o A  ldx              <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">12</span>          Load word <span class="hljs-built_in">int</span>o X  ldxi             <span class="hljs-number">4</span>                    Load word <span class="hljs-built_in">int</span>o X  ldxb             <span class="hljs-number">5</span>                    Load byte <span class="hljs-built_in">int</span>o X  st               <span class="hljs-number">3</span>                    Store A <span class="hljs-built_in">int</span>o M[]  stx              <span class="hljs-number">3</span>                    Store X <span class="hljs-built_in">int</span>o M[]  jmp              <span class="hljs-number">6</span>                    Jump to label  ja               <span class="hljs-number">6</span>                    Jump to label  jeq              <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>          Jump on A == &lt;x&gt;  jneq             <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                Jump on A != &lt;x&gt;  jne              <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                Jump on A != &lt;x&gt;  jlt              <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                Jump on A &lt;  &lt;x&gt;  jle              <span class="hljs-number">9</span>, <span class="hljs-number">10</span>                Jump on A &lt;= &lt;x&gt;  jgt              <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>          Jump on A &gt;  &lt;x&gt;  jge              <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>          Jump on A &gt;= &lt;x&gt;  jset             <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>          Jump on A &amp;  &lt;x&gt;  add              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A + &lt;x&gt;  sub              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A - &lt;x&gt;  mul              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A * &lt;x&gt;  div              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A / &lt;x&gt;  mod              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A % &lt;x&gt;  neg                                   !A  <span class="hljs-keyword">and</span>              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A &amp; &lt;x&gt;  <span class="hljs-keyword">or</span>               <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A | &lt;x&gt;  <span class="hljs-keyword">xor</span>              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A ^ &lt;x&gt;  lsh              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A &lt;&lt; &lt;x&gt;  rsh              <span class="hljs-number">0</span>, <span class="hljs-number">4</span>                 A &gt;&gt; &lt;x&gt;  tax                                   Copy A <span class="hljs-built_in">int</span>o X  txa                                   Copy X <span class="hljs-built_in">int</span>o A  ret              <span class="hljs-number">4</span>, <span class="hljs-number">11</span>                Return</code></pre><pre><code class="hljs angelscript">Addressing mode  Syntax               Description <span class="hljs-number">0</span>               x/%x                 Register X <span class="hljs-number">1</span>               [k]                  BHW at byte offset k <span class="hljs-keyword">in</span> the packet（BHW,二进制半字，<span class="hljs-number">32</span>位） <span class="hljs-number">2</span>               [x + k]              BHW at the offset X + k <span class="hljs-keyword">in</span> the packet <span class="hljs-number">3</span>               M[k]                 Word at offset k <span class="hljs-keyword">in</span> M[] <span class="hljs-number">4</span>               #k                   Literal value stored <span class="hljs-keyword">in</span> k <span class="hljs-number">5</span>               <span class="hljs-number">4</span>*([k]&amp;<span class="hljs-number">0xf</span>)          Lower nibble * <span class="hljs-number">4</span> at byte offset k <span class="hljs-keyword">in</span> the packet <span class="hljs-number">6</span>               L                    Jump label L <span class="hljs-number">7</span>               #k,Lt,Lf             Jump to Lt <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>, otherwise jump to Lf <span class="hljs-number">8</span>               x/%x,Lt,Lf           Jump to Lt <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>, otherwise jump to Lf <span class="hljs-number">9</span>               #k,Lt                Jump to Lt <span class="hljs-keyword">if</span> predicate <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span><span class="hljs-number">10</span>               x/%x,Lt              Jump to Lt <span class="hljs-keyword">if</span> predicate <span class="hljs-keyword">is</span> <span class="hljs-literal">true</span><span class="hljs-number">11</span>               a/%a                 Accumulator A<span class="hljs-number">12</span>               extension            BPF extension</code></pre><p>BPF extension寻址配合load指令使用，将查询的结果放到累加器A中。可能的BPF extension包括：</p><pre><code class="hljs routeros">Extension                             Descriptionlen                                   skb-&gt;lenproto                                 skb-&gt;protocoltype                                  skb-&gt;pkt_typepoff                                  Payload start offsetifidx                                 skb-&gt;dev-&gt;ifindexnla                                   Netlink attribute of<span class="hljs-built_in"> type </span>X with offset Anlan                                  Nested Netlink attribute of<span class="hljs-built_in"> type </span>X with offset Amark                                  skb-&gt;markqueue                                 skb-&gt;queue_mappinghatype                                skb-&gt;dev-&gt;typerxhash                                skb-&gt;hashcpu                                   raw_smp_processor_id()vlan_tci                              skb_vlan_tag_get(skb)vlan_avail                            skb_vlan_tag_present(skb)vlan_tpid                             skb-&gt;vlan_protorand                                  prandom_u32()</code></pre><p>一些例子：</p><pre><code class="hljs avrasm">** ARP packets:  ldh [<span class="hljs-number">12</span>]          <span class="hljs-comment">/*以太网首部跳过12byte，load half-word，也就是2byte，是以太网的类型字段*/</span>  jne <span class="hljs-meta">#0x806, drop  /* 不等于0x806则跳转 */</span>  <span class="hljs-keyword">ret</span> <span class="hljs-meta">#-1</span>  drop: <span class="hljs-keyword">ret</span> <span class="hljs-meta">#0</span>** IPv4 TCP packets:  ldh [<span class="hljs-number">12</span>]  jne <span class="hljs-meta">#0x800, drop</span>  ldb [<span class="hljs-number">23</span>] <span class="hljs-comment">/*以太网frame跳过14byte的首部，在到9byte（1byte是8bit）的ip首部，load 1byte，是IP数据包的协议类型*/</span>  jneq <span class="hljs-meta">#6, drop</span>  <span class="hljs-keyword">ret</span> <span class="hljs-meta">#-1</span>  drop: <span class="hljs-keyword">ret</span> <span class="hljs-meta">#0</span>** (Accelerated) VLAN w/ id <span class="hljs-number">10</span>:  <span class="hljs-keyword">ld</span> vlan_tci  <span class="hljs-comment">/*这里用的是extensions的寻址，skb_vlan_tag_get(skb)*/</span>  jneq <span class="hljs-meta">#10, drop</span>  <span class="hljs-keyword">ret</span> <span class="hljs-meta">#-1</span>  drop: <span class="hljs-keyword">ret</span> <span class="hljs-meta">#0</span></code></pre><p>上面的代码可以由<code>bpf_asm</code>进行转换，生成<code>xt_bpf</code>和<code>cls_bpf</code>可以直接加载的code</p><pre><code class="hljs angelscript">$ ./bpf_asm foo<span class="hljs-number">4</span>,<span class="hljs-number">40</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">12</span>,<span class="hljs-number">21</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2054</span>,<span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">4294967295</span>,<span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>,In copy <span class="hljs-keyword">and</span> paste C-like output:$ ./bpf_asm -c foo&#123; <span class="hljs-number">0x28</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0x0000000c</span> &#125;,&#123; <span class="hljs-number">0x15</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">0x00000806</span> &#125;,&#123; <span class="hljs-number">0x06</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0xffffffff</span> &#125;,&#123; <span class="hljs-number">0x06</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0000000000</span> &#125;,</code></pre><p><code>tools/bpf/bpf_dbg</code>可以使用pcap文件来调试bpf程序。</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core<span class="hljs-regexp">/bpf_jit_enable  /</span>*启动*/echo <span class="hljs-number">2</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span>core<span class="hljs-regexp">/bpf_jit_enable  /</span>*编译的opcode会输入到内核日志中*/</code></pre><p>当开启<code>CONFIG_BPF_JIT_ALWAYS_ON</code>时，<code>bpf_jit_enable</code>始终为1。</p><p><code>tools/bpf/</code>下的<code>bpf_jit_disasm</code>可以将内核日志中的十六进制转换成反汇编。</p><pre><code class="hljs angelscript"># ./bpf_jit_disasm -o<span class="hljs-number">70</span> bytes emitted <span class="hljs-keyword">from</span> JIT compiler (pass:<span class="hljs-number">3</span>, flen:<span class="hljs-number">6</span>)ffffffffa0069c8f + &lt;x&gt;:   <span class="hljs-number">0</span>:push   %rbp<span class="hljs-number">55</span>   <span class="hljs-number">1</span>:mov    %rsp,%rbp<span class="hljs-number">48</span> <span class="hljs-number">89</span> e5   <span class="hljs-number">4</span>:sub    $<span class="hljs-number">0x60</span>,%rsp<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">60</span>   <span class="hljs-number">8</span>:mov    %rbx,<span class="hljs-number">-0x8</span>(%rbp)<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">5</span>d f8   c:mov    <span class="hljs-number">0x68</span>(%rdi),%r9d<span class="hljs-number">44</span> <span class="hljs-number">8</span>b <span class="hljs-number">4f</span> <span class="hljs-number">68</span>  <span class="hljs-number">10</span>:sub    <span class="hljs-number">0x6c</span>(%rdi),%r9d<span class="hljs-number">44</span> <span class="hljs-number">2</span>b <span class="hljs-number">4f</span> <span class="hljs-number">6</span>c  <span class="hljs-number">14</span>:mov    <span class="hljs-number">0xd8</span>(%rdi),%r8<span class="hljs-number">4</span>c <span class="hljs-number">8</span>b <span class="hljs-number">87</span> d8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">1</span>b:mov    $<span class="hljs-number">0xc</span>,%esibe <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">20</span>:callq  <span class="hljs-number">0xffffffffe0ff9442</span>e8 <span class="hljs-number">1</span>d <span class="hljs-number">94</span> ff e0  <span class="hljs-number">25</span>:cmp    $<span class="hljs-number">0x800</span>,%eax<span class="hljs-number">3</span>d <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">2</span>a:jne    <span class="hljs-number">0x0000000000000042</span><span class="hljs-number">75</span> <span class="hljs-number">16</span>  <span class="hljs-number">2</span>c:mov    $<span class="hljs-number">0x17</span>,%esibe <span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">31</span>:callq  <span class="hljs-number">0xffffffffe0ff945e</span>e8 <span class="hljs-number">28</span> <span class="hljs-number">94</span> ff e0  <span class="hljs-number">36</span>:cmp    $<span class="hljs-number">0x1</span>,%eax<span class="hljs-number">83</span> f8 <span class="hljs-number">01</span>  <span class="hljs-number">39</span>:jne    <span class="hljs-number">0x0000000000000042</span><span class="hljs-number">75</span> <span class="hljs-number">07</span>  <span class="hljs-number">3</span>b:mov    $<span class="hljs-number">0xffff</span>,%eaxb8 ff ff <span class="hljs-number">00</span> <span class="hljs-number">00</span>  <span class="hljs-number">40</span>:jmp    <span class="hljs-number">0x0000000000000044</span>eb <span class="hljs-number">02</span>  <span class="hljs-number">42</span>:<span class="hljs-keyword">xor</span>    %eax,%eax<span class="hljs-number">31</span> c0  <span class="hljs-number">44</span>:leaveqc9  <span class="hljs-number">45</span>:retqc3</code></pre><h2 id="BPF内核实现"><a href="#BPF内核实现" class="headerlink" title="BPF内核实现"></a>BPF内核实现</h2><p>内核中解释器使用的指令和上面描述的BPF指令集不同，更接近底层架构，以便获得更高的性能，被称为eBPF或internal BPF。新指令集可以通过“受限C语言”编写程序，并通过GCC/LLVM编译为eBPF，<strong>C -&gt; eBPF -&gt; native code</strong></p><p>内核调用<code>bpf_prog_create()</code>和<code>bpf_prog_destroy()</code>来创建和销毁filter，调用<code>BPG_PROG_RUN(filter,ctx)</code>宏进行解释与运行，这些都是透明的。参数filter为<code>bpf_prog</code>结构体，由<code>bpf_prog_create()</code>返回，ctx为给定的上下文，例如skb的指针。<code>bpf_check_classic()</code>的所有约束和限制会在转换之前执行。</p><p>eBPF的主要变化：</p><ul><li><p>寄存器数量由2变为10</p><ul><li>R0：保存eBPF或辅助函数的返回值</li><li>R1-R5：存储调用辅助函数需要传递的参数</li><li>R6-R9：用于存储中间值，辅助函数将保持这些寄存器不改变</li><li>R10：只读寄存器，包含访问BPF stack的指针</li></ul><p>只有一个主eBPF程序，它只能调用其他辅助函数，而非其他BPF程序（注：现在应该支持BPF之间的调用）</p></li><li><p>寄存器由32位变为64位</p><ul><li>仍然保留了32位的ALU操作语义，使用64位寄存器的32位子寄存器保存</li></ul></li><li><p>条件jt/jf替换为jt/fall-through</p></li><li><p>引入<code>bpf_call</code>和寄存器传递约定</p><ul><li><p>调用辅助函数前，根据辅助函数规定，将参数存储至R1-R5上。R1-R5寄存器映射到CPU的寄存器上，调用无性能损耗。</p></li><li><p>调用辅助函数后，R1-R5不可读，R0存储返回的值，R6-R9正在调用期间不会改变。eBPF程序只有1一个<code>ctx</code>，保存在R1上。</p></li></ul><pre><code class="hljs armasm"><span class="hljs-symbol">u64</span> <span class="hljs-built_in">f1</span>() &#123; return (*_<span class="hljs-built_in">f2</span>)(<span class="hljs-number">1</span>)<span class="hljs-comment">; &#125;</span><span class="hljs-symbol">u64</span> <span class="hljs-built_in">f2</span>(u64 a) &#123; return <span class="hljs-built_in">f3</span>(a + <span class="hljs-number">1</span>, a)<span class="hljs-comment">; &#125;</span><span class="hljs-symbol">u64</span> <span class="hljs-built_in">f3</span>(u64 a, u64 b) &#123; return a - b<span class="hljs-comment">; &#125;</span><span class="hljs-comment">// f2的eBPF看起来类似</span><span class="hljs-symbol"> f2:</span>  bpf_mov <span class="hljs-built_in">R2</span>, <span class="hljs-built_in">R1</span>  bpf_add <span class="hljs-built_in">R1</span>, <span class="hljs-number">1</span>  bpf_call <span class="hljs-built_in">f3</span>  bpf_exit</code></pre></li></ul><p>x86_64中，64位寄存器与HW寄存器的对应：</p><pre><code class="hljs x86asm"><span class="hljs-built_in">R0</span> - <span class="hljs-built_in">rax</span><span class="hljs-built_in">R1</span> - <span class="hljs-built_in">rdi</span><span class="hljs-built_in">R2</span> - <span class="hljs-built_in">rsi</span><span class="hljs-built_in">R3</span> - <span class="hljs-built_in">rdx</span><span class="hljs-built_in">R4</span> - <span class="hljs-built_in">rcx</span><span class="hljs-built_in">R5</span> - <span class="hljs-built_in">r8</span><span class="hljs-built_in">R6</span> - <span class="hljs-built_in">rbx</span><span class="hljs-built_in">R7</span> - <span class="hljs-built_in">r13</span><span class="hljs-built_in">R8</span> - <span class="hljs-built_in">r14</span><span class="hljs-built_in">R9</span> - <span class="hljs-built_in">r15</span><span class="hljs-built_in">R10</span> - <span class="hljs-built_in">rbp</span></code></pre><p>x86_64下，C语言</p><pre><code class="hljs angelscript">u64 bpf_filter(u64 ctx)&#123;    <span class="hljs-keyword">return</span> foo(ctx, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) + bar(ctx, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);&#125;</code></pre><p>对应的BPF</p><pre><code class="hljs apache"><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">6</span>, R<span class="hljs-number">1</span> /* save ctx */<span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">2</span>, <span class="hljs-number">2</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">3</span>, <span class="hljs-number">3</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">4</span>, <span class="hljs-number">4</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">5</span>, <span class="hljs-number">5</span><span class="hljs-attribute">bpf_call</span> foo<span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">7</span>, R<span class="hljs-number">0</span> /* save foo() return value */<span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">1</span>, R<span class="hljs-number">6</span> /* restore ctx for next call */<span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">2</span>, <span class="hljs-number">6</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">3</span>, <span class="hljs-number">7</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">4</span>, <span class="hljs-number">8</span><span class="hljs-attribute">bpf_mov</span> R<span class="hljs-number">5</span>, <span class="hljs-number">9</span><span class="hljs-attribute">bpf_call</span> bar<span class="hljs-attribute">bpf_add</span> R<span class="hljs-number">0</span>, R<span class="hljs-number">7</span><span class="hljs-attribute">bpf_exit</span></code></pre><p>对应的JIT编译结果</p><pre><code class="hljs mel">push %rbpmov %rsp,%rbpsub $0x228,%rspmov %rbx,<span class="hljs-number">-0x228</span>(%rbp)mov %r13,<span class="hljs-number">-0x220</span>(%rbp)mov %rdi,%rbxmov $0x2,%esimov $0x3,%edxmov $0x4,%ecxmov $0x5,%r8dcallq foomov %rax,%r13mov %rbx,%rdimov $0x6,%esimov $0x7,%edxmov $0x8,%ecxmov $0x9,%r8dcallq baradd %r13,%raxmov <span class="hljs-number">-0x228</span>(%rbp),%rbxmov <span class="hljs-number">-0x220</span>(%rbp),%r13leaveqretq</code></pre><p>为了保证eBPF程序迅速停止，eBPF程序限制只能有4096条指令。（注：现在限制扩到了100W）</p><p>根据不同用例，ctx中的内容不同。对于seccomp，R1指向<code>seccomp_data</code>；对于BPF filters，R1指向<code>skb</code>。</p><blockquote><p>注：Seccomp(全称：secure computing mode)在2.6.12版本中引入linux内核，作为一种安全机制，主要用于限制用户态程序对系统调用的滥用。由于限制太强，后引入seccomp-bpf，借助bpf规则来过滤系统调用。</p></blockquote><p>指令的转换：</p><pre><code class="hljs apache"><span class="hljs-attribute">op</span>:<span class="hljs-number">16</span>, jt:<span class="hljs-number">8</span>, jf:<span class="hljs-number">8</span>, k:<span class="hljs-number">32</span>    ==&gt;    op:<span class="hljs-number">8</span>, dst_reg:<span class="hljs-number">4</span>, src_reg:<span class="hljs-number">4</span>, <span class="hljs-literal">off</span>:<span class="hljs-number">16</span>, imm:<span class="hljs-number">32</span></code></pre><ul><li>目前内部BPF（eBPF）指令已有87条。</li><li>内部BPF是一个通用的RISC指令集。复杂的过滤器可能耗尽寄存器，需要使用到堆栈。</li><li>程序的安全性通过两个步骤确定：深度优先搜索，禁止循环，并进行其他CFG验证；从第一个指令开始，探测所有可能的路径，观察寄存器和堆栈的状态变化。</li></ul><h2 id="eBPF-opcode"><a href="#eBPF-opcode" class="headerlink" title="eBPF opcode"></a>eBPF opcode</h2><pre><code class="hljs asciidoc"><span class="hljs-code">+----------------+</span>--------<span class="hljs-code">+--------------------+</span>|   4 bits       |  1 bit |   3 bits           || operation code | source | instruction class  |<span class="hljs-code">+----------------+</span>--------<span class="hljs-code">+--------------------+</span>(MSB)                                      (LSB)</code></pre><p>最后3bit的LSB存储指令类别：</p><pre><code class="hljs apache"><span class="hljs-attribute">Classic</span> BPF classes:    eBPF classes: <span class="hljs-attribute">BPF_LD</span>    <span class="hljs-number">0</span>x<span class="hljs-number">00</span>          BPF_LD    <span class="hljs-number">0</span>x<span class="hljs-number">00</span> <span class="hljs-attribute">BPF_LDX</span>   <span class="hljs-number">0</span>x<span class="hljs-number">01</span>          BPF_LDX   <span class="hljs-number">0</span>x<span class="hljs-number">01</span> <span class="hljs-attribute">BPF_ST</span>    <span class="hljs-number">0</span>x<span class="hljs-number">02</span>          BPF_ST    <span class="hljs-number">0</span>x<span class="hljs-number">02</span> <span class="hljs-attribute">BPF_STX</span>   <span class="hljs-number">0</span>x<span class="hljs-number">03</span>          BPF_STX   <span class="hljs-number">0</span>x<span class="hljs-number">03</span> <span class="hljs-attribute">BPF_ALU</span>   <span class="hljs-number">0</span>x<span class="hljs-number">04</span>          BPF_ALU   <span class="hljs-number">0</span>x<span class="hljs-number">04</span> <span class="hljs-attribute">BPF_JMP</span>   <span class="hljs-number">0</span>x<span class="hljs-number">05</span>          BPF_JMP   <span class="hljs-number">0</span>x<span class="hljs-number">05</span> <span class="hljs-attribute">BPF_RET</span>   <span class="hljs-number">0</span>x<span class="hljs-number">06</span>          BPF_JMP<span class="hljs-number">32</span> <span class="hljs-number">0</span>x<span class="hljs-number">06</span> <span class="hljs-attribute">BPF_MISC</span>  <span class="hljs-number">0</span>x<span class="hljs-number">07</span>          BPF_ALU<span class="hljs-number">64</span> <span class="hljs-number">0</span>x<span class="hljs-number">07</span></code></pre><h3 id="对于逻辑运算和跳转指令"><a href="#对于逻辑运算和跳转指令" class="headerlink" title="对于逻辑运算和跳转指令"></a>对于逻辑运算和跳转指令</h3><ul><li>当PF_CLASS(code) == BPF_ALU或BPF_JMP时，第四位（source部分）可以为</li></ul><pre><code class="hljs mipsasm"><span class="hljs-keyword">BPF_K </span>    <span class="hljs-number">0x00</span> <span class="hljs-keyword">BPF_X </span>    <span class="hljs-number">0x08</span>* in classic <span class="hljs-keyword">BPF, </span>this means: <span class="hljs-keyword">BPF_SRC(code) </span>== <span class="hljs-keyword">BPF_X </span>- use register X as source operand <span class="hljs-keyword">BPF_SRC(code) </span>== <span class="hljs-keyword">BPF_K </span>- use <span class="hljs-number">32</span>-<span class="hljs-keyword">bit </span>immediate as source operand* in eBPF, this means: <span class="hljs-keyword">BPF_SRC(code) </span>== <span class="hljs-keyword">BPF_X </span>- use <span class="hljs-string">&#x27;src_reg&#x27;</span> register as source operand <span class="hljs-keyword">BPF_SRC(code) </span>== <span class="hljs-keyword">BPF_K </span>- use <span class="hljs-number">32</span>-<span class="hljs-keyword">bit </span>immediate as source operand</code></pre><ul><li>当BPF_CLASS(code) == BPF_ALU或BPF_ALU64 ，前四位BPF_OP(code)可以为：</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">BPF_ADD</span>   <span class="hljs-number">0</span>x<span class="hljs-number">00</span><span class="hljs-attribute">BPF_SUB</span>   <span class="hljs-number">0</span>x<span class="hljs-number">10</span><span class="hljs-attribute">BPF_MUL</span>   <span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-attribute">BPF_DIV</span>   <span class="hljs-number">0</span>x<span class="hljs-number">30</span><span class="hljs-attribute">BPF_OR</span>    <span class="hljs-number">0</span>x<span class="hljs-number">40</span><span class="hljs-attribute">BPF_AND</span>   <span class="hljs-number">0</span>x<span class="hljs-number">50</span><span class="hljs-attribute">BPF_LSH</span>   <span class="hljs-number">0</span>x<span class="hljs-number">60</span><span class="hljs-attribute">BPF_RSH</span>   <span class="hljs-number">0</span>x<span class="hljs-number">70</span><span class="hljs-attribute">BPF_NEG</span>   <span class="hljs-number">0</span>x<span class="hljs-number">80</span><span class="hljs-attribute">BPF_MOD</span>   <span class="hljs-number">0</span>x<span class="hljs-number">90</span><span class="hljs-attribute">BPF_XOR</span>   <span class="hljs-number">0</span>xa<span class="hljs-number">0</span><span class="hljs-attribute">BPF_MOV</span>   <span class="hljs-number">0</span>xb<span class="hljs-number">0</span>  /* eBPF only: mov reg to reg */<span class="hljs-attribute">BPF_ARSH</span>  <span class="hljs-number">0</span>xc<span class="hljs-number">0</span>  /* eBPF only: sign extending shift right */<span class="hljs-attribute">BPF_END</span>   <span class="hljs-number">0</span>xd<span class="hljs-number">0</span>  /* eBPF only: endianness conversion */</code></pre><p>当BPF_CLASS(code) == BPF_JMP或BPF_JMP32，前四位BPF_OP(code)可以为：</p><pre><code class="hljs apache"><span class="hljs-attribute">BPF_JA</span>    <span class="hljs-number">0</span>x<span class="hljs-number">00</span>  /* BPF_JMP only */<span class="hljs-attribute">BPF_JEQ</span>   <span class="hljs-number">0</span>x<span class="hljs-number">10</span><span class="hljs-attribute">BPF_JGT</span>   <span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-attribute">BPF_JGE</span>   <span class="hljs-number">0</span>x<span class="hljs-number">30</span><span class="hljs-attribute">BPF_JSET</span>  <span class="hljs-number">0</span>x<span class="hljs-number">40</span><span class="hljs-attribute">BPF_JNE</span>   <span class="hljs-number">0</span>x<span class="hljs-number">50</span>  /* eBPF only: jump != */<span class="hljs-attribute">BPF_JSGT</span>  <span class="hljs-number">0</span>x<span class="hljs-number">60</span>  /* eBPF only: signed &#x27;&gt;&#x27; */<span class="hljs-attribute">BPF_JSGE</span>  <span class="hljs-number">0</span>x<span class="hljs-number">70</span>  /* eBPF only: signed &#x27;&gt;=&#x27; */<span class="hljs-attribute">BPF_CALL</span>  <span class="hljs-number">0</span>x<span class="hljs-number">80</span>  /* eBPF BPF_JMP only: function call */<span class="hljs-attribute">BPF_EXIT</span>  <span class="hljs-number">0</span>x<span class="hljs-number">90</span>  /* eBPF BPF_JMP only: function return */<span class="hljs-attribute">BPF_JLT</span>   <span class="hljs-number">0</span>xa<span class="hljs-number">0</span>  /* eBPF only: unsigned &#x27;&lt;&#x27; */<span class="hljs-attribute">BPF_JLE</span>   <span class="hljs-number">0</span>xb<span class="hljs-number">0</span>  /* eBPF only: unsigned &#x27;&lt;=&#x27; */<span class="hljs-attribute">BPF_JSLT</span>  <span class="hljs-number">0</span>xc<span class="hljs-number">0</span>  /* eBPF only: signed &#x27;&lt;&#x27; */<span class="hljs-attribute">BPF_JSLE</span>  <span class="hljs-number">0</span>xd<span class="hljs-number">0</span>  /* eBPF only: signed &#x27;&lt;=&#x27; */</code></pre><ul><li><code>BPF_XOR | BPF_K | BPF_ALU </code>在cBPF中表示<code>A^=imm32</code>，在eBPF中表示<code>src_reg = (u32) src_reg ^ (u32) imm32</code>（这段看代码，应该是<code>dst_reg = (u32) dst_reg ^ (u32) imm32</code>?） BPF_JMP | BPF_EXIT表示直接退出。</li></ul><h3 id="对于加载和存储指令"><a href="#对于加载和存储指令" class="headerlink" title="对于加载和存储指令"></a>对于加载和存储指令</h3><pre><code class="hljs asciidoc"><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+-------------------+</span>| 3 bits | 2 bits |   3 bits          ||  mode  |  size  | instruction class |<span class="hljs-code">+--------+</span>--------<span class="hljs-code">+-------------------+</span>(MSB)                             (LSB)</code></pre><p>size部分</p><pre><code class="hljs mipsasm"> <span class="hljs-keyword">BPF_W </span>  <span class="hljs-number">0x00</span>    <span class="hljs-comment">/* word */</span> <span class="hljs-keyword">BPF_H </span>  <span class="hljs-number">0x08</span>    <span class="hljs-comment">/* half word */</span> <span class="hljs-keyword">BPF_B </span>  <span class="hljs-number">0x10</span>    <span class="hljs-comment">/* byte */</span> <span class="hljs-keyword">BPF_DW </span> <span class="hljs-number">0x18</span>    <span class="hljs-comment">/* eBPF only, double word */</span> <span class="hljs-keyword">B </span> - <span class="hljs-number">1</span> <span class="hljs-keyword">byte</span><span class="hljs-keyword">H </span> - <span class="hljs-number">2</span> <span class="hljs-keyword">byte</span><span class="hljs-keyword">W </span> - <span class="hljs-number">4</span> <span class="hljs-keyword">byte</span><span class="hljs-keyword">DW </span>- <span class="hljs-number">8</span> <span class="hljs-keyword">byte </span>(eBPF only)</code></pre><p>mode部分</p><pre><code class="hljs apache"><span class="hljs-attribute">BPF_IMM</span>  <span class="hljs-number">0</span>x<span class="hljs-number">00</span>  /* used for <span class="hljs-number">32</span>-bit mov in classic BPF and <span class="hljs-number">64</span>-bit in eBPF */<span class="hljs-attribute">BPF_ABS</span>  <span class="hljs-number">0</span>x<span class="hljs-number">20</span><span class="hljs-attribute">BPF_IND</span>  <span class="hljs-number">0</span>x<span class="hljs-number">40</span><span class="hljs-attribute">BPF_MEM</span>  <span class="hljs-number">0</span>x<span class="hljs-number">60</span><span class="hljs-attribute">BPF_LEN</span>  <span class="hljs-number">0</span>x<span class="hljs-number">80</span>  /* classic BPF only, reserved in eBPF */<span class="hljs-attribute">BPF_MSH</span>  <span class="hljs-number">0</span>xa<span class="hljs-number">0</span>  /* classic BPF only, reserved in eBPF */<span class="hljs-attribute">BPF_XADD</span> <span class="hljs-number">0</span>xc<span class="hljs-number">0</span>  /* eBPF only, exclusive add */</code></pre><p>两个非通用指令<code>BPF_ABS | &lt;size&gt; | BPF_LD</code>和<code>BPF_IND | &lt;size&gt; | BPF_LD</code>，用于访问数据包中的字段。使用条件：</p><p>1）ctx是指向<code>sk_buff</code>的指针</p><p>2）R0-R6规定为：R0保存获取的结果，R6保存<code>sk_buff</code>指针，R1-R5为暂存器，不可存储需要跨指令的数据（即执行完指令后R1-R5中的数据不可用）</p><p>3）访问超出<code>sk_buff-&gt;data</code>范围 ，自动跳出</p><pre><code class="hljs armasm"><span class="hljs-symbol">BPF_IND</span> <span class="hljs-title">| BPF_W |</span> BPF_LD means:  <span class="hljs-built_in">R0</span> = ntohl(*(u32 *) (((struct sk_buff *) <span class="hljs-built_in">R6</span>)-&gt;<span class="hljs-meta">data</span> + src_reg + imm32))  <span class="hljs-keyword">and</span> <span class="hljs-built_in">R1</span> - <span class="hljs-built_in">R5</span> were scratched.</code></pre><p>其他的一些例子</p><pre><code class="hljs gcode">BPF_MEM | &lt;size&gt; | BPF_STX:  *<span class="hljs-comment">(size *)</span> <span class="hljs-comment">(dst_reg + off)</span> = src_regBPF_MEM | &lt;size&gt; | BPF_ST:   *<span class="hljs-comment">(size *)</span> <span class="hljs-comment">(dst_reg + off)</span> = im<span class="hljs-name">m32</span>BPF_MEM | &lt;size&gt; | BPF_LDX:  dst_reg = *<span class="hljs-comment">(size *)</span> <span class="hljs-comment">(src_reg + off)</span>BPF_XADD | BPF_W  | BPF_STX: lock xadd *<span class="hljs-comment">(u32 *)</span><span class="hljs-comment">(dst_reg + off16)</span> += src_regBPF_XADD | BPF_DW | BPF_STX: lock xadd *<span class="hljs-comment">(u64 *)</span><span class="hljs-comment">(dst_reg + off16)</span> += src_reg</code></pre><blockquote><p>注：在<a href="https://elixir.bootlin.com/linux/v5.8.7/source/include/linux/filter.h#L265">linux/filter.h</a>下都有。ST是从dst到src，LD是从src到dst</p></blockquote><p>BPF_LD | BPF_DW | BPF_IMM（获取一个8字节的立即数）会跨两个指令。</p><pre><code class="hljs livescript"><span class="hljs-comment">#define BPF_LD_IMM64_RAW(DST, SRC, IMM)\</span>((struct bpf_insn) &#123;<span class="hljs-string">\</span>.code  = BPF_LD | BPF_DW | BPF_IMM,<span class="hljs-string">\</span>.dst_reg = DST,<span class="hljs-string">\</span>.src_reg = SRC,<span class="hljs-string">\</span>.<span class="hljs-literal">off</span>   = <span class="hljs-number">0</span>,<span class="hljs-string">\</span>.imm   = (__u32) (IMM) &#125;),<span class="hljs-string">\</span>((struct bpf_insn) &#123;<span class="hljs-string">\</span>.code  = <span class="hljs-number">0</span>, <span class="hljs-comment">/* zero is reserved opcode */</span><span class="hljs-string">\</span>.dst_reg = <span class="hljs-number">0</span>,<span class="hljs-string">\</span>.src_reg = <span class="hljs-number">0</span>,<span class="hljs-string">\</span>.<span class="hljs-literal">off</span>   = <span class="hljs-number">0</span>,<span class="hljs-string">\</span>.imm   = ((__u64) (IMM)) &gt;&gt; <span class="hljs-number">32</span> &#125;)</code></pre><h2 id="eBPF验证器"><a href="#eBPF验证器" class="headerlink" title="eBPF验证器"></a>eBPF验证器</h2><p>两步：</p><p>1）做DAG（有向无环图）检测，确保无循环以及CFG（控制流保护）</p><p>2）从第一条指令开始，模拟执行所有可能的指令路径，观察寄存器和堆栈状态</p><p>一些检测规则：</p><p>1）不允许指针相加</p><p>2）不允许读未初始化的寄存器</p><p>3）辅助函数调用后R1-R5为不可读状态</p><p>4）load/store指令需要相应的寄存器类型为<code>PTR_TO_CTX</code>、 <code>PTR_TO_MAP</code>、<code>PTR_TO_STACK</code>是才有效 （比如不能是标量），并且会有边界和对齐检测</p><p>5）程序开始时，R1类型为<code>PTR_TO_CTX</code>（ctx指针）。可以通过<code>is_valid_access()</code>回调函数，自定义验证方式，来进行边界与对齐检测。另外类型为<code>PTR_TO_STACK</code>（堆栈指针）时，访问边界为[-MAX_BPF_STACK, 0)</p><p>6）堆栈只有在写入才能读取（对应<code>PTR_TO_STACK</code>类型寄存器的操作）</p><p>7）<code>bpf_verifier_ops-&gt;get_func_proto()</code>可以用来自定义“函数调用”时的“参数检测”（检测寄存器），返回值保存在R0</p><p>8）eBPF对seccomp与socket filter的验证方式是相同的，而cBPF对于seccomp，需要先进行<code>seccomp verifier</code>，在进行其他的验证。</p><p>详细代码<code>kernel/bpf/verifier.c</code></p><h2 id="寄存器值追踪"><a href="#寄存器值追踪" class="headerlink" title="寄存器值追踪"></a>寄存器值追踪</h2><p>验证器追踪寄存器中的值，检测值可能的范围。追踪由<code>include/linux/bpf_verifier.h</code>下的<code>struct bpf_reg_state</code>完成，寄存器值可能的类型：<code>NOT_INIT</code>、<code>SCALAR_VALUE</code>、<code>point</code>。<code>point</code>由分为：</p><pre><code class="hljs livecodeserver">PTR_TO_CTX          Pointer <span class="hljs-built_in">to</span> bpf_context. CONST_PTR_TO_MAP    Pointer <span class="hljs-built_in">to</span> struct bpf_map.  <span class="hljs-string">&quot;Const&quot;</span> because arithmetic                     <span class="hljs-keyword">on</span> <span class="hljs-title">these</span> <span class="hljs-title">pointers</span> <span class="hljs-title">is</span> <span class="hljs-title">forbidden</span>. PTR_TO_MAP_VALUE    Pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">value</span> stored <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> map <span class="hljs-keyword">element</span>. PTR_TO_MAP_VALUE_OR_NULL                     Either <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> map <span class="hljs-built_in">value</span>, <span class="hljs-keyword">or</span> <span class="hljs-literal">NULL</span>; map accesses                     (see section <span class="hljs-string">&#x27;eBPF maps&#x27;</span>, below) <span class="hljs-literal">return</span> this type,                     which becomes <span class="hljs-keyword">a</span> PTR_TO_MAP_VALUE when checked != <span class="hljs-literal">NULL</span>.                     Arithmetic <span class="hljs-keyword">on</span> <span class="hljs-title">these</span> <span class="hljs-title">pointers</span> <span class="hljs-title">is</span> <span class="hljs-title">forbidden</span>. PTR_TO_STACK        Frame pointer. PTR_TO_PACKET       skb-&gt;data. PTR_TO_PACKET_END   skb-&gt;data + headlen; arithmetic forbidden. PTR_TO_SOCKET       Pointer <span class="hljs-built_in">to</span> struct bpf_sock_ops, implicitly refcounted. PTR_TO_SOCKET_OR_NULL                     Either <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">socket</span>, <span class="hljs-keyword">or</span> <span class="hljs-literal">NULL</span>; <span class="hljs-built_in">socket</span> lookup                     returns this type, which becomes <span class="hljs-keyword">a</span> PTR_TO_SOCKET when                     checked != <span class="hljs-literal">NULL</span>. PTR_TO_SOCKET is reference-counted,                     so programs must release <span class="hljs-keyword">the</span> reference through <span class="hljs-keyword">the</span>                     <span class="hljs-built_in">socket</span> release <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">before</span> <span class="hljs-title">the</span> <span class="hljs-title">end</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">program</span>.</span>                     Arithmetic <span class="hljs-keyword">on</span> <span class="hljs-title">these</span> <span class="hljs-title">pointers</span> <span class="hljs-title">is</span> <span class="hljs-title">forbidden</span>.</code></pre><blockquote><p>对于PTR_TO_SOCKET和PTR_TO_SOCKET_OR_NULL，在程序结束前需要使用socket release方法，释放引用</p></blockquote><p>对于指针偏移的验证：</p><p>1）分<code>fixed offset</code>和<code>variable offset</code></p><p>2）验证器对<code>vaiable offset</code>需要记录的状态：</p><pre><code class="hljs angelscript">* minimum <span class="hljs-keyword">and</span> maximum values as unsigned* minimum <span class="hljs-keyword">and</span> maximum values as signed* 一个<span class="hljs-string">&#x27;tnum&#x27;</span>值，由两个u64组成，第一个为value，是具体的值；第二个为mask，用<span class="hljs-number">1</span>标记未知的位。比如知道寄存器前<span class="hljs-number">56</span>位为<span class="hljs-number">0</span>，后<span class="hljs-number">8</span>位不知道，则表示为tnum(<span class="hljs-number">0x0</span>,<span class="hljs-number">0xff</span>)，表示省略了高位的<span class="hljs-number">0</span></code></pre><ul><li>状态可以通过逻辑运算更新，例如上的<code>tnum(0x0,0xff)</code>寄存器与<code>0x40</code>取或，则变为<code>tnum(0x40,0xbf)</code></li><li>状态可以根据条件分支判断，例如在<code>SCALAR_VALUE</code>(offset)大于8为true的分支，寄存器的<code>umin_value</code>为9</li><li>对<code>PTR_TO_PACKET</code>类型的寄存器，使用id标识某个偏移量。例如寄存器A拷贝到寄存器B，两者有相同偏移量，因此offset id相同，一次验证即可。</li><li><code>PTR_TO_MAP_VALUE_OR_NULL</code>类寄存器（存储bgp  map中查询返回的指针），也使用id标识，一旦验证某个id标识非NULL，其他副本也相同。除此外，可以做对齐验证。</li><li><code>PTR_TO_SOCKET</code>和<code>PTR_TO_SOCKET_OR_NULL</code>类寄存器（存储socket中查询返回的指针）也使用id标识，与<code>PTR_TO_MAP_VALUE_OR_NULL</code>类似。另外，对非NULL的id，可将其副本调用socket release方法。</li></ul><h2 id="数据包的直接访问"><a href="#数据包的直接访问" class="headerlink" title="数据包的直接访问"></a>数据包的直接访问</h2><p>对于<code>cls_bpf</code>与<code>act_bpf</code>，允许通过<code>skb-&gt;date</code>和<code>skb-&gt;data_end</code>直接访问数据包。</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span>:  r<span class="hljs-number">4</span> = *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">80</span>)  /* load skb-&gt;data_end */<span class="hljs-attribute">2</span>:  r<span class="hljs-number">3</span> = *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">1</span> +<span class="hljs-number">76</span>)  /* load skb-&gt;data */<span class="hljs-attribute">3</span>:  r<span class="hljs-number">5</span> = r<span class="hljs-number">3</span><span class="hljs-attribute">4</span>:  r<span class="hljs-number">5</span> += <span class="hljs-number">14</span><span class="hljs-attribute">5</span>:  if r<span class="hljs-number">5</span> &gt; r<span class="hljs-number">4</span> goto pc+<span class="hljs-number">16</span><span class="hljs-attribute">R1</span>=ctx R<span class="hljs-number">3</span>=pkt(id=<span class="hljs-number">0</span>,<span class="hljs-literal">off</span>=<span class="hljs-number">0</span>,r=<span class="hljs-number">14</span>) R<span class="hljs-number">4</span>=pkt_end R<span class="hljs-number">5</span>=pkt(id=<span class="hljs-number">0</span>,<span class="hljs-literal">off</span>=<span class="hljs-number">14</span>,r=<span class="hljs-number">14</span>) R<span class="hljs-number">10</span>=fp<span class="hljs-attribute">6</span>:  r<span class="hljs-number">0</span> = *(u<span class="hljs-number">16</span> *)(r<span class="hljs-number">3</span> +<span class="hljs-number">12</span>) /* access <span class="hljs-number">12</span> and <span class="hljs-number">13</span> bytes of the packet */</code></pre><p>根据第5行的判断，验证器可以标记R3为<code>pkg(id=0,off=0,r=14)</code>，其中id=0表示未向寄存器添加<code>variablle offset</code>，off=0表示未向寄存器添加<code>fixed  offset</code>，r=14表示安全访问范围为[R3,R3+14]。同理R5标记为<code>pkt(id=0,off=14,r=14)</code></p><h2 id="eBPF-maps"><a href="#eBPF-maps" class="headerlink" title="eBPF maps"></a>eBPF maps</h2><p><code>map</code>用于内核和用户空间之间共享不同类型的数据。<code>map</code>存储使用BPF系统调用：</p><pre><code class="hljs sql">- <span class="hljs-keyword">create</span> a <span class="hljs-keyword">map</span> <span class="hljs-keyword">with</span> given <span class="hljs-keyword">type</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">attributes</span>  map_fd = bpf(BPF_MAP_CREATE, <span class="hljs-keyword">union</span> bpf_attr *<span class="hljs-keyword">attr</span>, u32 <span class="hljs-keyword">size</span>)  <span class="hljs-keyword">using</span> <span class="hljs-keyword">attr</span>-&gt;map_type, <span class="hljs-keyword">attr</span>-&gt;key_size, <span class="hljs-keyword">attr</span>-&gt;value_size, <span class="hljs-keyword">attr</span>-&gt;max_entries  <span class="hljs-keyword">returns</span> process-<span class="hljs-keyword">local</span> <span class="hljs-keyword">file</span> <span class="hljs-keyword">descriptor</span> <span class="hljs-keyword">or</span> negative <span class="hljs-keyword">error</span>- lookup <span class="hljs-keyword">key</span> <span class="hljs-keyword">in</span> a given <span class="hljs-keyword">map</span>  err = bpf(BPF_MAP_LOOKUP_ELEM, <span class="hljs-keyword">union</span> bpf_attr *<span class="hljs-keyword">attr</span>, u32 <span class="hljs-keyword">size</span>)  <span class="hljs-keyword">using</span> <span class="hljs-keyword">attr</span>-&gt;map_fd, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">key</span>, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">value</span>  <span class="hljs-keyword">returns</span> zero <span class="hljs-keyword">and</span> stores <span class="hljs-keyword">found</span> elem <span class="hljs-keyword">into</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">or</span> negative <span class="hljs-keyword">error</span>- <span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">update</span> <span class="hljs-keyword">key</span>/<span class="hljs-keyword">value</span> pair <span class="hljs-keyword">in</span> a given <span class="hljs-keyword">map</span>  err = bpf(BPF_MAP_UPDATE_ELEM, <span class="hljs-keyword">union</span> bpf_attr *<span class="hljs-keyword">attr</span>, u32 <span class="hljs-keyword">size</span>)  <span class="hljs-keyword">using</span> <span class="hljs-keyword">attr</span>-&gt;map_fd, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">key</span>, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">value</span>  <span class="hljs-keyword">returns</span> zero <span class="hljs-keyword">or</span> negative <span class="hljs-keyword">error</span>- find <span class="hljs-keyword">and</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">element</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">in</span> a given <span class="hljs-keyword">map</span>  err = bpf(BPF_MAP_DELETE_ELEM, <span class="hljs-keyword">union</span> bpf_attr *<span class="hljs-keyword">attr</span>, u32 <span class="hljs-keyword">size</span>)  <span class="hljs-keyword">using</span> <span class="hljs-keyword">attr</span>-&gt;map_fd, <span class="hljs-keyword">attr</span>-&gt;<span class="hljs-keyword">key</span>- <span class="hljs-keyword">to</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">map</span>: <span class="hljs-keyword">close</span>(fd)  Exiting process will <span class="hljs-keyword">delete</span> maps automatically</code></pre><p><code>map</code>类型：hash、array、bloom  filter、redix-tree等；<code>map</code>定义：</p><pre><code class="hljs routeros">. type. max number of elements. key size <span class="hljs-keyword">in</span> bytes. value size <span class="hljs-keyword">in</span> bytes</code></pre><h2 id="修剪（pruning）"><a href="#修剪（pruning）" class="headerlink" title="修剪（pruning）"></a>修剪（pruning）</h2><p>验证器（verifier）在对新分支进行分析时，会比较当前指令之前检测过的状态，如果当前（寄存器）状态属于之前检测过的状态，这个分支就被认为可信，被修剪。</p><h2 id="理解验证器的日志"><a href="#理解验证器的日志" class="headerlink" title="理解验证器的日志"></a>理解验证器的日志</h2><ul><li><p>不可达指令</p><pre><code class="hljs mipsasm">static struct <span class="hljs-keyword">bpf_insn </span>prog[] = &#123;   <span class="hljs-keyword">BPF_EXIT_INSN(),</span><span class="hljs-keyword"> </span>  <span class="hljs-keyword">BPF_EXIT_INSN(),</span><span class="hljs-keyword"> </span>&#125;;<span class="hljs-symbol"> Error:</span>   unreachable <span class="hljs-keyword">insn </span><span class="hljs-number">1</span></code></pre></li><li><p>读取未初始化的寄存器</p><pre><code class="hljs subunit">  BPF_MOV64_REG(BPF_REG_0, BPF_REG_2),  BPF_EXIT_INSN(),Error:  0: (bf) r0 = r2  R2 !read_ok</code></pre></li><li><p>结束程序前未初始化寄存器</p><pre><code class="hljs awk">  BPF_MOV64_REG(BPF_REG_2, BPF_REG_1),  BPF_EXIT_INSN(),Error:  <span class="hljs-number">0</span>: (bf) r2 = r1  <span class="hljs-number">1</span>: (<span class="hljs-number">95</span>) <span class="hljs-keyword">exit</span>  R0 !read_ok</code></pre></li><li><p>越界访问堆栈</p><pre><code class="hljs apache">  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> +<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">invalid</span> stack <span class="hljs-literal">off</span>=<span class="hljs-number">8</span> size=<span class="hljs-number">8</span></code></pre></li><li><p>未初始化堆栈（<code>map_lookup_elem</code>调用，R1为文件描述符，R2为key，读取了R2指向的未初始化堆栈）</p><pre><code class="hljs apache"><span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),<span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),<span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),<span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:<span class="hljs-attribute">0</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span><span class="hljs-attribute">1</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span><span class="hljs-attribute">2</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0</span><span class="hljs-attribute">3</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span><span class="hljs-attribute">invalid</span> indirect read from stack <span class="hljs-literal">off</span> -<span class="hljs-number">8</span>+<span class="hljs-number">0</span> size <span class="hljs-number">8</span></code></pre></li><li><p>无效的<code>map_fd</code>（R1中的0x0）</p><pre><code class="hljs apache"> <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">2</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">3</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0</span>  <span class="hljs-attribute">4</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span>  <span class="hljs-attribute">fd</span> <span class="hljs-number">0</span> is not pointing to valid bpf_map</code></pre></li><li><p><code>map_lookup_elem</code>的返回值未进行验证（保存在R0）</p><pre><code class="hljs apache"><span class="hljs-attribute">map</span> element:  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">2</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">3</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0</span>  <span class="hljs-attribute">4</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span>  <span class="hljs-attribute">5</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">R0</span> invalid mem access &#x27;map_value_or_null&#x27;</code></pre></li><li><p><code>BPF_ST_MEM</code>以错误的对齐方式进行访问</p><pre><code class="hljs apache"><span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),  <span class="hljs-attribute">BPF_JMP_IMM</span>(BPF_JEQ, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">2</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">3</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <span class="hljs-attribute">4</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span>  <span class="hljs-attribute">5</span>: (<span class="hljs-number">15</span>) if r<span class="hljs-number">0</span> == <span class="hljs-number">0</span>x<span class="hljs-number">0</span> goto pc+<span class="hljs-number">1</span>   <span class="hljs-attribute">R0</span>=map_ptr R<span class="hljs-number">10</span>=fp  <span class="hljs-attribute">6</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">4</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">misaligned</span> access <span class="hljs-literal">off</span> <span class="hljs-number">4</span> size <span class="hljs-number">8</span></code></pre></li><li><p><code>map_lookup_elem</code>结果R0为NULL，pc+2，执行指令8，会出现错误</p><pre><code class="hljs apache"> <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">10</span>, -<span class="hljs-number">8</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_LD_MAP_FD</span>(BPF_REG_<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_RAW_INSN</span>(BPF_JMP | BPF_CALL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BPF_FUNC_map_lookup_elem),  <span class="hljs-attribute">BPF_JMP_IMM</span>(BPF_JEQ, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>),  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),  <span class="hljs-attribute">BPF_ST_MEM</span>(BPF_DW, BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">2</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">3</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <span class="hljs-attribute">4</span>: (<span class="hljs-number">85</span>) call <span class="hljs-number">1</span>  <span class="hljs-attribute">5</span>: (<span class="hljs-number">15</span>) if r<span class="hljs-number">0</span> == <span class="hljs-number">0</span>x<span class="hljs-number">0</span> goto pc+<span class="hljs-number">2</span>   <span class="hljs-attribute">R0</span>=map_ptr R<span class="hljs-number">10</span>=fp  <span class="hljs-attribute">6</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>  <span class="hljs-attribute">7</span>: (<span class="hljs-number">95</span>) exit  <span class="hljs-attribute">from</span> <span class="hljs-number">5</span> to <span class="hljs-number">8</span>: R<span class="hljs-number">0</span>=imm<span class="hljs-number">0</span> R<span class="hljs-number">10</span>=fp  <span class="hljs-attribute">8</span>: (<span class="hljs-number">7</span>a) *(u<span class="hljs-number">64</span> *)(r<span class="hljs-number">0</span> +<span class="hljs-number">0</span>) = <span class="hljs-number">1</span>  <span class="hljs-attribute">R0</span> invalid mem access &#x27;imm&#x27;</code></pre></li><li><p><code>bpf_sk_lookup_tcp</code>三个参数<code>R1=ptr_to_ctx;R2=ptr_to_mem</code>，将R0置NULL前未检测、未释放引用</p><pre><code class="hljs apache">  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">2</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_STX_MEM</span>(BPF_W, BPF_REG_<span class="hljs-number">10</span>, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">4</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">5</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EMIT_CALL</span>(BPF_FUNC_sk_lookup_tcp),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">2</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = r<span class="hljs-number">2</span>  <span class="hljs-attribute">2</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">3</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">4</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">3</span> = <span class="hljs-number">4</span>  <span class="hljs-attribute">5</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">4</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">6</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">5</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">7</span>: (<span class="hljs-number">85</span>) call bpf_sk_lookup_tcp#<span class="hljs-number">65</span>  <span class="hljs-attribute">8</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">9</span>: (<span class="hljs-number">95</span>) exit  <span class="hljs-attribute">Unreleased</span> reference id=<span class="hljs-number">1</span>, alloc_insn=<span class="hljs-number">7</span></code></pre></li><li><p>R0未检测是否为NULL就返回了</p><pre><code class="hljs apache">  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">2</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_STX_MEM</span>(BPF_W, BPF_REG_<span class="hljs-number">10</span>, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_MOV64_REG</span>(BPF_REG_<span class="hljs-number">2</span>, BPF_REG_<span class="hljs-number">10</span>),  <span class="hljs-attribute">BPF_ALU64_IMM</span>(BPF_ADD, BPF_REG_<span class="hljs-number">2</span>, -<span class="hljs-number">8</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">4</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_MOV64_IMM</span>(BPF_REG_<span class="hljs-number">5</span>, <span class="hljs-number">0</span>),  <span class="hljs-attribute">BPF_EMIT_CALL</span>(BPF_FUNC_sk_lookup_tcp),  <span class="hljs-attribute">BPF_EXIT_INSN</span>(),<span class="hljs-attribute">Error</span>:  <span class="hljs-attribute">0</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">2</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">1</span>: (<span class="hljs-number">63</span>) *(u<span class="hljs-number">32</span> *)(r<span class="hljs-number">10</span> -<span class="hljs-number">8</span>) = r<span class="hljs-number">2</span>  <span class="hljs-attribute">2</span>: (bf) r<span class="hljs-number">2</span> = r<span class="hljs-number">10</span>  <span class="hljs-attribute">3</span>: (<span class="hljs-number">07</span>) r<span class="hljs-number">2</span> += -<span class="hljs-number">8</span>  <span class="hljs-attribute">4</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">3</span> = <span class="hljs-number">4</span>  <span class="hljs-attribute">5</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">4</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">6</span>: (b<span class="hljs-number">7</span>) r<span class="hljs-number">5</span> = <span class="hljs-number">0</span>  <span class="hljs-attribute">7</span>: (<span class="hljs-number">85</span>) call bpf_sk_lookup_tcp#<span class="hljs-number">65</span>  <span class="hljs-attribute">8</span>: (<span class="hljs-number">95</span>) exit  <span class="hljs-attribute">Unreleased</span> reference id=<span class="hljs-number">1</span>, alloc_insn=<span class="hljs-number">7</span></code></pre></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>内核附带测试模块，包含用于cBPF和eBPF的各种测试，在<code>lib/test_bpf.c</code>中 ，通过<code>Kconfig</code>启动：</p><pre><code class="hljs ini"><span class="hljs-attr">CONFIG_TEST_BPF</span>=m</code></pre><p>编译安装测试模块后，可以通过<code>insmod</code>与<code>modprobe</code>执行测试。结果在内核日志（dmesg）中可以找到。</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p><img src="/img/bpf-2021022401.jpg"></p><p><img src="/img/bpf-2021022402.jpg"></p><p><img src="/img/bpf-2021022403.jpg"></p><h2 id="参考（图片来源）"><a href="#参考（图片来源）" class="headerlink" title="参考（图片来源）"></a>参考（图片来源）</h2><p><a href="https://cloud.tencent.com/developer/inventory/600/article/1698426">https://cloud.tencent.com/developer/inventory/600/article/1698426</a></p><p><a href="https://damonyi.cc/2021/01/26/Linux-eBPF%E4%BB%8B%E7%BB%8D/">https://damonyi.cc/2021/01/26/Linux-eBPF%E4%BB%8B%E7%BB%8D/</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calico BGP功能介绍：实现</title>
    <link href="/2021/02/23/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/02/23/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>Calico作为一种常用的Kubernetes网络插件，使用BGP协议对各节点的容器网络进行路由交换。本文是《Calico BGP功能介绍》系列的第二篇，介绍Calico中BGP功能的实现。所使用的Calico版本为v3.17.3。</p><a id="more"></a><h2 id="Calico-BGP功能"><a href="#Calico-BGP功能" class="headerlink" title="Calico BGP功能"></a>Calico BGP功能</h2><h3 id="BGP-Peer"><a href="#BGP-Peer" class="headerlink" title="BGP Peer"></a>BGP Peer</h3><p>Calico中通过定义BGP Peer对象，来建立BGP连接。BGP Peer对象的主要参数如下：</p><table><thead><tr><th align="left">参数</th><th>描述</th></tr></thead><tbody><tr><td align="left">node</td><td>指定BGP Peer应用在哪个node上。如果指定此字段，则为node级别，否则为global级别。</td></tr><tr><td align="left">peerIP</td><td>指定远端的Peer地址，可以是IP加端口的形式，端口可选。支持IPV4和IPV6。</td></tr><tr><td align="left">asNumber</td><td>远端Peer的AS号。</td></tr><tr><td align="left">nodeSelector</td><td>用于通过标签来选择一组node，作为BGP Peer应用的节点，注意这里的node为Calico中的node，而非K8s中的node。如果指定了此字段，则node应该为空。</td></tr><tr><td align="left">peerSelector</td><td>用于通过标签来选择一组node（同样为Calico中的node），作为远端Peer的节点。如果指定了此字段，则peerIP和asNumber都应该为空。</td></tr><tr><td align="left">keepOriginalNextHop</td><td>对于EBGP，保持并转发原始的next hop，不将自身加入到Path中。</td></tr><tr><td align="left">password</td><td>BGP会话的身份验证。</td></tr></tbody></table><p>在过去的版本，Calico中包含了<code>BGP Peer</code>对象和<code>Global BGP Peer</code>对象，目前已统一为<code>BGP Peer</code>对象，根据是指定<code>node</code>参数还是<code>nodeSelector</code>参数来区分。</p><h3 id="BGP-Configuration"><a href="#BGP-Configuration" class="headerlink" title="BGP Configuration"></a>BGP Configuration</h3><p>除了BGP Peer外，Calico通过BGP Configuration对象来控制全局的BGP行为。主要参数包括：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>nodeToNodeMeshEnabled</td><td>开启Calico节点之间的node-to-node mesh。</td><td>true</td></tr><tr><td>asNumber</td><td>Calico node默认的节点AS。</td><td>64512</td></tr><tr><td>serviceClusterIPs</td><td>Calico需要对外BGP的service ClusterIP地址段。</td><td></td></tr><tr><td>serviceExternalIPs</td><td>Calico需要对外BGP的service ExternalIPs地址段。</td><td></td></tr><tr><td>communities</td><td>用于定义BGP community，由name和value组成，value支持标准community以及large community。</td><td></td></tr><tr><td>prefixAdvertisements</td><td>指定网段与community的隶属关系，可以通过communities中的name指定，也可以通过community value直接指定。</td><td></td></tr></tbody></table><p>默认情况下，Calico所有节点通过IBGP来交换各个节点的workload（容器）路由信息，由于从IBGP Peer中学习到的路由不会被再次转发，因此需要使用node-to-node mesh的方式两两互连。</p><p><code>serviceClusterIPs</code>和<code>serviceExternalIPs</code>字段的功能类似于MetalLB的BGP模式，可以将K8s Service的访问地址（ClusterIP和ExternalIP）BGP到集群外的设备（例如TOR）。结合ECMP，可以将外部访问K8s Service的流量负载到K8s节点上，由Kube-proxy转发到真正的容器后端。</p><p><code>communities</code>与<code>prefixAdvertisements</code>可以控制Calico BGP路由的community字段，支持<a href="http://www.rfc-editor.org/info/rfc1997">RFC 1997</a>中的<code>well-known communities</code>。使用样例如下：</p><pre><code class="hljs yaml"><span class="hljs-attr">communities:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">bgp-large-community</span>  <span class="hljs-attr">value:</span> <span class="hljs-number">63400</span><span class="hljs-string">:300:100</span><span class="hljs-attr">prefixAdvertisements:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">cidr:</span> <span class="hljs-number">172.218</span><span class="hljs-number">.4</span><span class="hljs-number">.0</span><span class="hljs-string">/26</span>  <span class="hljs-attr">communities:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">bgp-large-community</span>  <span class="hljs-bullet">-</span> <span class="hljs-number">63400</span><span class="hljs-string">:120</span></code></pre><h2 id="Calico-BGP-功能实现"><a href="#Calico-BGP-功能实现" class="headerlink" title="Calico BGP 功能实现"></a>Calico BGP 功能实现</h2><p>简单来说，Calico是通过confd组件来渲染bird的配置文件，动态配置bird，从而实现BGP功能。其中，为了使confd支持Calico后端存储，在原生的confd上，添加了类型为Calico的backend，主要逻辑是watch后端BGPPeer、BGPConfiguration、Node资源（由libcalico-go中的<code>bgpsyncer</code>实现），缓存到内存中，供confd渲染使用。</p><p><img src="/img/calico-bgp1.jpg"></p><p>可以看到，主要的配置文件分为6个，其中IPv4和IPv6各3个。以IPv4为例，IPv6类似，bird.cfg为bird的主要配置文件，包括几个主要部分：</p><p>1）全局的配置：包括route id、debug属性、listen bgp port，这一部分主要由node、bgp configuration中的字段产生。</p><p>2）固定的协议配置：包括kernel、device、direct；其功能在上一篇<a href="https://maao.cloud/2021/01/26/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9ABIRD%E7%AE%80%E4%BB%8B/">Calico BGP功能介绍：BIRD简介</a>中有详细介绍。</p><pre><code class="hljs nim"><span class="hljs-comment"># Configure synchronization between routing tables and kernel.</span>protocol kernel &#123;  learn;             <span class="hljs-comment"># Learn all alien routes from the kernel</span>  persist;           <span class="hljs-comment"># Don&#x27;t remove routes on bird shutdown</span>  scan time <span class="hljs-number">2</span>;       <span class="hljs-comment"># Scan kernel routing table every 2 seconds</span>  <span class="hljs-keyword">import</span> all;  <span class="hljs-keyword">export</span> filter calico_kernel_programming; <span class="hljs-comment"># Default is export none</span>  graceful restart;  <span class="hljs-comment"># Turn on graceful restart to reduce potential flaps in</span>                     <span class="hljs-comment"># routes when reloading BIRD configuration.  With a full</span>                     <span class="hljs-comment"># automatic mesh, there is no way to prevent BGP from</span>                     <span class="hljs-comment"># flapping since multiple nodes update their BGP</span>                     <span class="hljs-comment"># configuration at the same time, GR is not guaranteed to</span>                     <span class="hljs-comment"># work correctly in this scenario.</span>  merge paths on;    <span class="hljs-comment"># Allow export multipath routes (ECMP)</span>&#125;<span class="hljs-comment"># Watch interface up/down events.</span>protocol device &#123;&#123;&#123;- <span class="hljs-keyword">template</span> <span class="hljs-string">&quot;LOGGING&quot;</span>&#125;&#125;  scan time <span class="hljs-number">2</span>;    <span class="hljs-comment"># Scan interfaces every 2 seconds</span>&#125;protocol direct &#123;&#123;&#123;- <span class="hljs-keyword">template</span> <span class="hljs-string">&quot;LOGGING&quot;</span>&#125;&#125;  <span class="hljs-keyword">interface</span> -<span class="hljs-string">&quot;cali*&quot;</span>, -<span class="hljs-string">&quot;kube-ipvs*&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>; <span class="hljs-comment"># Exclude cali* and kube-ipvs* but</span>                                          <span class="hljs-comment"># include everything else.  In</span>                                          <span class="hljs-comment"># IPVS-mode, kube-proxy creates a</span>                                          <span class="hljs-comment"># kube-ipvs0 interface. We exclude</span>                                          <span class="hljs-comment"># kube-ipvs0 because this interface</span>                                          <span class="hljs-comment"># gets an address for every in use</span>                                          <span class="hljs-comment"># cluster IP. We use static routes</span>                                          <span class="hljs-comment"># for when we legitimately want to</span>                                          <span class="hljs-comment"># export cluster IPs.</span>&#125;</code></pre><p>kernel中export用到了filter <code>calico_kernel_programming</code>，其定义在bird_ipam.cfg.template中。主要分两部分：</p><p>一是获取<code>/calico/rejectcidrs</code>的值，对属于此cidr范围内的路由reject。<code>/calico/rejectcidrs</code>的值是由confd的<code>calico backend</code>写入，其值为BGP Configuration中设置的<code>serviceClusterIPs</code>和<code>serviceExternalIPs</code>。在开启了Calico的<a href="https://docs.projectcalico.org/networking/advertise-service-ips">advertise service</a>功能后（通过配置BGP Configuration的<code>serviceClusterIPs</code>和<code>serviceClusterIPs</code>），可以避免将其他节点发送过来的Service路由写入kernel路由表中。</p><p>二是对于属于Calico IPPool的路由，根据Calico IPPool设置的模式（VXLAN或IPIP），来判断是否需要写入kernel路由表。对于VXLAN模式，由felix负责数据包的路由，不再写入kernel中；对于IPIP，根据Calico IPPool的IPIP配置（Always、Cross-subnet）以及BGP协议的bgp_next_hop属性（判断是否跨网段），决定是生成IPIP的路由，还是非IPIP路由。这里使用到的bird参数<code>krt_tunnel</code>来传递IPIP设备，<code>krt_tunnel</code>并非原生bird所提供的参数，而是由Calico添加的，以实现bird支持IPIP协议。</p><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$network_key</span> <span class="hljs-attr">:</span>= printf <span class="hljs-string">&quot;/bgp/v1/host/%s/network_v4&quot;</span> (<span class="hljs-name">getenv</span> <span class="hljs-string">&quot;NODENAME&quot;</span>)&#125;&#125;</span><span class="xml">filter calico_kernel_programming &#123;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $reject_key <span class="hljs-attr">:</span>= <span class="hljs-string">&quot;/rejectcidrs&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if ls $reject_key&#125;&#125;</span><span class="xml">  # Don&#x27;t program static routes into kernel.</span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> range ls $reject_key&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $parts <span class="hljs-attr">:</span>= split . <span class="hljs-string">&quot;-&quot;</span>&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $cidr <span class="hljs-attr">:</span>= join $parts <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;</span><span class="xml">  if ( net ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$cidr</span>&#125;&#125;</span><span class="xml"> ) then &#123; reject; &#125;</span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if exists $network_key&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$network</span> <span class="hljs-attr">:</span>= getv $network_key&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">range</span> ls <span class="hljs-string">&quot;/v1/ipam/v4/pool&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data</span> <span class="hljs-attr">:</span>= json (<span class="hljs-name">getv</span> (<span class="hljs-name">printf</span> <span class="hljs-string">&quot;/v1/ipam/v4/pool/%s&quot;</span> .))&#125;&#125;</span><span class="xml">  if ( net ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.cidr</span>&#125;&#125;</span><span class="xml"> ) then &#123;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if $data.vxlan_mode&#125;&#125;</span><span class="xml">    # Don&#x27;t program VXLAN routes into the kernel - these are handled by Felix.</span><span class="xml">    reject;</span><span class="xml">  &#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> else if $data.ipip_mode&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> eq $data.ipip_mode <span class="hljs-string">&quot;cross-subnet&quot;</span>&#125;&#125;</span><span class="xml">    if defined(bgp_next_hop) &amp;&amp; ( bgp_next_hop ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$network</span>&#125;&#125;</span><span class="xml"> ) then</span><span class="xml">      krt_tunnel = &quot;&quot;;                     </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination in ipPool, mode is cross sub-net, route from-host on subnet, do not use IPIP */&#125;&#125;</span><span class="xml">    else</span><span class="xml">      krt_tunnel = &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.ipip</span>&#125;&#125;</span><span class="xml">&quot;;       </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination in ipPool, mode is cross sub-net, route from-host off subnet, set the tunnel (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> IPIP not enabled, value will be <span class="hljs-string">&quot;&quot;</span>) */&#125;&#125;</span><span class="xml">    accept;</span><span class="xml">  &#125; </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> else&#125;&#125;</span><span class="xml">    krt_tunnel = &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.ipip</span>&#125;&#125;</span><span class="xml">&quot;;         </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination in ipPool, mode not cross sub-net, set the tunnel (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> IPIP not enabled, value will be <span class="hljs-string">&quot;&quot;</span>) */&#125;&#125;</span><span class="xml">    accept;</span><span class="xml">  &#125; </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> else&#125;&#125;</span><span class="xml">    krt_tunnel = &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.ipip</span>&#125;&#125;</span><span class="xml">&quot;;         </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination in ipPool, mode field is not present, set the tunnel (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> IPIP not enabled, value will be <span class="hljs-string">&quot;&quot;</span>) */&#125;&#125;</span><span class="xml">    accept;</span><span class="xml">  &#125; </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">end</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-tag">&#123;&#123;/* <span class="hljs-name">End</span> <span class="hljs-name">of</span> <span class="hljs-name">&#x27;exists $network_key&#x27;</span> *<span class="hljs-name">/</span>&#125;&#125;</span><span class="xml">  accept;                                  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> /* Destination is not in any ipPool, accept  */&#125;&#125;</span><span class="xml">&#125;</span></code></pre><p>3）BGP协议部分。</p><p>BGP协议部分是最主要的部分，使用了bird的template，template中export方向使用filter <code>calico_export_to_bgp_peers</code>过滤，其定义在bird_ipam.cfg.template中，主要功能是：先调用bird.cfg.template中的<code>apply_communities()</code>方法（根据BGP Configuration中的<code>communities</code>和<code>prefixAdvertisements</code>字段），为发送的BGP路由添加community参数；调用bird_aggr.cfg.template中的<code>calico_aggr()</code>方法，确保宣告的BGP路由的目标地址段为完整的block；最后，判断路由的目标地址是否在<code>/calico/staticroutes</code>或Calico IPPool所指定的地址范围内，若在，则accept，其他的reject。</p><blockquote><p>Calico中block是容器IP资源池最小的分配单位，最初Calico会为每个节点分配一个block，当某个节点block使用完，则会再次为节点分配一个block</p></blockquote><pre><code class="hljs handlebars"><span class="xml">filter calico_export_to_bgp_peers &#123;</span><span class="xml">  # filter code terminates when it calls `accept;` or `reject;`, call apply_communities() before calico_aggr()</span><span class="xml">  apply_communities();</span><span class="xml">  calico_aggr();</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $static_key <span class="hljs-attr">:</span>= <span class="hljs-string">&quot;/staticroutes&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if ls $static_key&#125;&#125;</span><span class="xml">  # Export static routes.</span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> range ls $static_key&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $parts <span class="hljs-attr">:</span>= split . <span class="hljs-string">&quot;-&quot;</span>&#125;&#125;</span><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $cidr <span class="hljs-attr">:</span>= join $parts <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;</span><span class="xml">  if ( net ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$cidr</span>&#125;&#125;</span><span class="xml"> ) then &#123; accept; &#125;</span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">range</span> ls <span class="hljs-string">&quot;/v1/ipam/v4/pool&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data</span> <span class="hljs-attr">:</span>= json (<span class="hljs-name">getv</span> (<span class="hljs-name">printf</span> <span class="hljs-string">&quot;/v1/ipam/v4/pool/%s&quot;</span> .))&#125;&#125;</span><span class="xml">  if ( net ~ </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$data.cidr</span>&#125;&#125;</span><span class="xml"> ) then &#123;</span><span class="xml">    accept;</span><span class="xml">  &#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="xml">  reject;</span><span class="xml">&#125;</span></code></pre><p><code>/calico/staticroutes</code>中的值也是由confd的<code>calico backend</code>写入，其值主要包含两部分：BGP Configuration中设置的<code>serviceClusterIPs</code>和<code>serviceExternalIPs</code>；<code>externalTrafficPolicy=Local</code>的Service地址。因此filter <code>calico_export_to_bgp_peers</code>保证了Calico只对容器网络相关的路由进行BGP，对于手动配置或从其他EBGP学习到的非容器网络相关的路由，则不会进行BGP。</p><p>BGP协议部分主要分三部分：node-to-node mesh的配置、global peers的配置、node-specific peers的配置，都是使用上面的template完成。</p><p>其中node-to-node mesh配置部分，会判断两个node ip，当远端peer的node ip“较大”时，开启<code>passive</code>，也就是说，始终由“较大”IP的node发起BGP连接，保证mesh是单向的。</p><p>global peers配置和node-specific peers配置部分基本相同，会根据BGP Peer中的<code>keepOriginalNextHop</code>、<code>password</code>配置协议的<code>next hop keep</code>以及<code>password</code>属性，另外会根据本节点是否配置route reflector clusterID，决定是否开启<code>rr client</code>（用于Calico route reflector模式）。</p><p>4）static协议部分在bird_aggr.cfg.template中，主要是将本机的block和<code>/calico/staticroutes</code>中的值配置为Blackhole路由。这样一来，即可通过“bird路由表”，由BGP协议将本机的容器网络和Service网络的路由信息发送出去。而根据上面<code>/calico/staticroutes</code>的介绍，对于<code>externalTrafficPolicy=Cluster</code>的Service是以整个ServiceCIRD（BGP Configuration中设置的<code>serviceClusterIPs</code>和<code>serviceExternalIPs</code>）作为目标地址进行BGP的，对于<code>externalTrafficPolicy=Local</code>的Service，则会判断本节点上是否有相应的workloadEndpoint，如果有，则以单个地址（子网掩码/32或/128）作为目标地址进行BGP。以此，Calico实现了对Service externalTrafficPolicy属性的支持。</p><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $block_key <span class="hljs-attr">:</span>= printf <span class="hljs-string">&quot;/calico/ipam/v2/host/%s/ipv4/block&quot;</span> (<span class="hljs-name">getenv</span> <span class="hljs-string">&quot;NODENAME&quot;</span>)&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $static_key <span class="hljs-attr">:</span>= <span class="hljs-string">&quot;/calico/staticroutes&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> or (<span class="hljs-name">ls</span> $block_key) (<span class="hljs-name">ls</span> $static_key)&#125;&#125;</span><span class="xml">protocol static &#123;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if ls $block_key&#125;&#125;</span><span class="xml">   # IP blocks for this host.</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> range ls $block_key&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $parts <span class="hljs-attr">:</span>= split . <span class="hljs-string">&quot;-&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $cidr <span class="hljs-attr">:</span>= join $parts <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;</span><span class="xml">   route </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$cidr</span>&#125;&#125;</span><span class="xml"> blackhole;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> if ls $static_key&#125;&#125;</span><span class="xml">   # Static routes.</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> range ls $static_key&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $parts <span class="hljs-attr">:</span>= split . <span class="hljs-string">&quot;-&quot;</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> $cidr <span class="hljs-attr">:</span>= join $parts <span class="hljs-string">&quot;/&quot;</span>&#125;&#125;</span><span class="xml">   route </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$cidr</span>&#125;&#125;</span><span class="xml"> blackhole;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">-</span> end&#125;&#125;</span><span class="xml">&#125;</span><span class="hljs-template-tag">&#123;&#123;<span class="hljs-keyword">else</span>&#125;&#125;</span><span class="xml"># No IP blocks or static routes for this host.</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">end</span>&#125;&#125;</span></code></pre><p>这里有个问题，由于kernel中的export filter过滤了目标地址属于BGP Configuration的<code>serviceClusterIPs</code>和<code>serviceClusterIPs</code>的路由，实际上static协议中的<code>/calico/staticroutes</code>部分的Blackhole是无法配置到节点的路由表上的（<code>externalTrafficPolicy=Cluster</code>的Service地址也在这个范围内）。这会导致在使用Calico与TOR进行BGP的场景中，在开启了advertise service后，容器访问某个属于ServiceCIDR范围内，但并未分配给任何Service的地址时，数据包会根据默认路由发送到TOR，再由TOR发送回集群的某个节点，如此反复直至TTL消耗完。而如果尝试将ServiceCIDR对应的Blackhole路由写入系统的路由表中，可以解决这个问题，但又会导致宿主机对Service无法访问，流量直接被丢弃。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/projectcalico/confd/pull/322">https://github.com/projectcalico/confd/pull/322</a></p><p><a href="https://github.com/projectcalico/confd">https://github.com/projectcalico/confd</a></p><p><a href="https://github.com/projectcalico/calico/issues/3689">https://github.com/projectcalico/calico/issues/3689</a></p>]]></content>
    
    
    <categories>
      
      <category>calico</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Calico</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>廉价的K8s LB方案--MetalLB</title>
    <link href="/2021/02/09/%E5%BB%89%E4%BB%B7%E7%9A%84K8s-LB%E6%96%B9%E6%A1%88-MetalLB/"/>
    <url>/2021/02/09/%E5%BB%89%E4%BB%B7%E7%9A%84K8s-LB%E6%96%B9%E6%A1%88-MetalLB/</url>
    
    <content type="html"><![CDATA[<p>MetalLB为本地运行的Kubernetes集群提供了LoadBalance功能，使用户像在公有云环境一样，使用K8S的LoadBalancer Service。</p><a id="more"></a><p>在Kubernetes中部署MetalLB后，会有两个部分，一部分是负责监听K8S Service资源变化的Controller，以Deployment的方式部署在整个集群上，另一部分是各个节点上的代理组件Speaker，以DaemonSet方式部署，负责ARP Reply或是BGP的宣告。</p><p>MetalLB有两种模式，一种是二层网络模式，一种是BGP模式。</p><h2 id="二层网络模式"><a href="#二层网络模式" class="headerlink" title="二层网络模式"></a>二层网络模式</h2><p><img src="/img/metallb1.jpg"></p><p>二层网络模式，顾名思义，所有的流量都在一个二层网络中。此模式下MetalLB其实并未进行负载均衡，而是借助其他组件例如Kube-proxy，来实现负载均衡。具体的，如上图所示，MetalLB将Service External IP（由MetalLB的Controller根据预先设定好的IP段，配置在LoadBalance类型的Service上）配置在K8S集群节点的local网卡上（比如kube-ipvs0），当Client访问Service External IP时，由于在同一个二层，会广播ARP请求，MetalLB会使用某个节点进行ARP Reply（IPv6通过NDP协议），从而Client请求流量会发送到此节点，然后由节点上的Kube-proxy进行负载，转到真正的Pod地址。</p><p>需要说明的是：</p><p>1）Service External IP地址需要与Client在同一网段。</p><p>2）为了使其他节点不对local网卡上的Service External IP进行ARP Reply，节点需要设置<code>arp_ignore=1</code>以及<code>arp_announce=2</code>，或者是设置Kube-proxy的<code>--ipvs-strict-arp</code>参数。</p><p>3）MetalLB对于每个Service会选一个节点，始终由这个节点进行ARP Reply。节点的选择方式是：先过滤出Service后端Pod所在的节点，然后以Service Name、Service Namespace、NodeIP等计算hash值，排序hash值取第一个。</p><p>3）由于上面的选择方式，MetalLB对ExternalTrafficPolicy=Local的Service是支持的，但会导致只用到部分后端Pod实例。</p><p>4）Kube-proxy会同时进行DNAT与SNAT，回包并不是如LVS DR模式，而是原路返回。</p><p>5）Kube-proxy也可以使用其他组件代替，比如Cilium的Kube-proxy replace方案。</p><p>二层网络模式在生产环境中使用有限，原因有二：</p><p>1）扩展性有限。受ARP协议和NDP协议的限制，每个Service都只有一个真正的“入口”，因此这个节点很可能会成为网络瓶颈的所在。</p><p>2）故障转移依赖客户端。MetalLB使用<a href="https://github.com/hashicorp/memberlist">memberlist</a>做为分布式节点的管理，如果当前使用的节点出现故障时，MetalLB会在新的memberlist中（已删除故障节点）再次选择某个节点进行替换。接着MetalLB会给客户端发送一个“额外的二层包”，告知客户端OS需要更新他们的MAC缓存，而在客户端OS更新缓存前，流量仍会转发到故障节点。因此从某种程度来说，故障转移的时间，就依赖于客户端OS更新MAC缓存的速度。</p><p>3）选节点的hash并非一致性，添加节点有一定概率导致Service的节点发生变化。</p><h2 id="BGP模式"><a href="#BGP模式" class="headerlink" title="BGP模式"></a>BGP模式</h2><p><img src="/img/metallb2.jpg"></p><p>BGP模式不限于一个二层网络里，各个节点都会与交换机建立BGP Peer，宣告Service External IP的下一跳为自身，这样通过ECMP实现了一层负载。客户端请求通过交换机负载到后端某个节点后，再由Kube-proxy进行转发。</p><p>对于<code>externalTrafficPolicy=Local</code>的Service，只有本机存在服务Pod时，才会进行Service External IP的BGP路由宣告。</p><p><img src="/img/MetalLB3.jpg"></p><p>可以看到这种方式实际上是经过了两层的转发，当Service ExternalTrafficPolicy为Cluster时，每次转发的概率其实是均等的，但当Service ExternalTrafficPolicy为Local时，虽然转发到每个节点的概率是一致的，但每个节点上服务Pod数量不一致，导致每个Pod上的流量其实并不均等。</p><p>在这种模式中，我们希望对于客户端请求的转发遵循会话保持，否则会出现数据包的乱序或丢弃。一般在硬件上，通过对数据包的3元组（源地址、目标地址、协议）或是五元组（三元组加上源端口、目标端口）进行hash，来实现同一会话转发到相同的后端。但需要注意，这种hash一般不是一致性hash，这就导致当后端某个节点的失效后，会对其他连接也会参数影响，扩大了故障的“爆炸半径”。</p><p>官方给了一些缓解的办法，比如在MetalLB和Service后端之间，加入一层有状态的负载——ingress Controller。</p><p>另外 ，BGP模式下，MetalLB提供了部分参数，来实现对BGP协议的控制，比如BGP community、localpref等。</p><pre><code class="hljs routeros">apiVersion: v1kind: ConfigMapmetadata:  namespace: metallb-system  name: configdata:  config: |    peers:    - peer-address: 10.0.0.1      peer-asn: 64501      my-asn: 64500    address-pools:    - name: default      protocol: bgp      addresses:      - 198.51.100.0/24      bgp-advertisements:      - aggregation-length: 32        localpref: 100        communities:        - no-advertise      - aggregation-length: 24    bgp-communities:      no-advertise: 65535:65282</code></pre><h3 id="类比Calico对Service的BGP"><a href="#类比Calico对Service的BGP" class="headerlink" title="类比Calico对Service的BGP"></a>类比Calico对Service的BGP</h3><p>从Calico v3.4开始，Calico支持对K8S的Service地址进行BGP，其逻辑和MetalLB BGP逻辑基本相同。有几点区别：</p><p>1）默认的情况下，MetalLB是对单个IP进行BGP的，子网掩码是32，但对Calico配置的是一个CIDR，Calico对外BGP的是整个网络段的路由，只有在externalTrafficPolicy为Local时，才会对单个IP进行BGP。</p><p>2）Calico不仅会BGP Service External IP，还可以BGP Service ClusterIP，两者的转发过程是类似的，都是将流量负载到某个K8S节点后，进行SNAT与DNAT。</p><p>3）Calico不负责LoadBalancer Service IP的分配。</p><h2 id="IP地址共享"><a href="#IP地址共享" class="headerlink" title="IP地址共享"></a>IP地址共享</h2><p>默认情况下，MetalLB只会将一个IP地址分配到一个LoadBalancer Service上，用户可以通过<code>spec.loadBalancerIP</code>来指定自己想用的IP，如果用户指定了已被分配了的IP会，则会报错。但MetalLB也提供了方式去支持多个Service共享相同的IP，主要为了解决：K8S不支持对LoadBalancer Service中的Port指定多协议；有限的IP地址资源。</p><p>具体的方式是：创建两个Service，并加上<code>metallb.universe.tf/allow-shared-ip</code>为Key的<code>annotation</code>，表明Service能容忍使用共享的LoadBalancerIP；然后通过<code>spec.loadBalancerIP</code>给两个Service指定共享的IP。</p><p>IP地址共享也有限制：</p><p>1）两个Service的<code>metallb.universe.tf/allow-shared-ip</code>值是一样的。</p><p>2）两个Service的“端口”（带协议）不同，比如<code>tcp/53</code>和<code>udp/53</code>是属于不同的“端口”。</p><p>3）两个Service对应的后端Pod要一致，如果不一致，那么他们的externalTrafficPolicy需要都是Cluster，不然会无法进行正确的BGP。</p><p>目前K8S已经开始支持<a href="https://github.com/kubernetes/kubernetes/pull/94028">对LoadBalancer Service指定多协议</a>，因此除了MetalLB提供的IP地址共享的方式，也可以使用原生的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://metallb.universe.tf/">https://metallb.universe.tf/</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MetalLB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calico BGP功能介绍：BIRD简介</title>
    <link href="/2021/01/26/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9ABIRD%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/01/26/Calico-BGP%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9ABIRD%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>Calico作为一种常用的Kubernetes网络插件，使用BGP协议对各节点的容器网络进行路由交换。本文是《Calico BGP功能介绍》系列的第一篇，介绍Calico所使用的BGP软件路由器——BIRD。</p><a id="more"></a><blockquote><p>关于BGP协议，网上资料众多，在这里不再做介绍。另外，推荐《BGP in the datacenter》作为BGP应用的进阶阅读，另有<a href="https://cshihong.github.io/2020/04/18/BGP-in-the-datacenter-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%9A%84BGP-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84-Clos%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/">中文翻译版本</a></p></blockquote><h2 id="BIRD"><a href="#BIRD" class="headerlink" title="BIRD"></a>BIRD</h2><p>BIRD实际上是BIRD Internet Routing Daemon的缩写（禁止套娃），是一款可运行在Linux和其他类Unix系统上的路由软件，它实现了多种路由协议，比如BGP、OSPF、RIP等。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>BIRD会在内存中维护许多<strong>路由表</strong>，路由表根据不同的<strong>协议</strong>，通过与各种“其他事物”交换路由信息，来更新路由规则。这里说的“其他事物”可能是其他的路由表，也可能是外部的路由器，还可以是内核的某些API。</p><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>路由表（Routing tables）是BIRD的核心，一个路由表是内存中一组路由规则的集合，BIRD根据网络类型的不同会有多种路由表。默认情况下，BIRD有<code>master4</code>和<code>master6</code>两个默认的路由表，分别保存IPv4和IPv6路由规则。除此外，你也可以创建其他的路由表，比如在配置文件<code>bird.conf</code>中添加如下配置，创建一个IPv4的路由表<code>my_table</code>。</p><pre><code class="hljs text">ipv4 table my_table;</code></pre><p>要注意的是，BIRD的路由表仅仅是一个表，并没有转发的功能，真正的转发控制，是内核的FIB（Forwarding Information Base）。而BIRD的<code>kernel</code>协议，可以将BIRD路由表与FIB进行同步，后面会介绍。</p><p>路由规则中包含了各种<strong>路由属性</strong>（Route attributes），网络类型不同的路由表，其路由属性也不太一样，比如常见的IPv4和IPv6的路由表，会包括两个路由属性：</p><ul><li>路由目的地</li><li>路由下一跳</li></ul><p>而VPN路由表还会包含路由属性：路由标识符（Route distinguisher）。</p><p>BIRD的每种表都会将一个或一组路由属性作为<strong>主键</strong>，类似于SQL数据库。当多个来源都提供了相同主键的路由条目时，BIRD会根据一定的规则选择最优路由。例如IPv4和IPv6类型的路由表，将“路由目的地”作为主键。</p><h3 id="协议与通道"><a href="#协议与通道" class="headerlink" title="协议与通道"></a>协议与通道</h3><p>协议（Protocols）将路由表和“其他事物”连接起来。“其他事物”可以是一个Socket对象，连接了外部的路由器，例如BGP路由协议；也可以是修改FIB的内核API，例如<code>kernel</code>协议；也可以是空，比如静态路由<code>static</code>协议。一个协议可以实例化为多个对象，例如创建多个BGP协议的实例，以表示多个BGP邻居。</p><p>协议也会提供一些路由属性，根据协议的不同路由属性也不同，比如使用BGP协议时，会有<code>bgp_path</code>属性。</p><p>协议可能包含一些<strong>通道</strong>（Channels），通道是在协议和路由表之间，配置了路由规则在导入（import)）、导出（export）两个方向上的行为，导入导出是针对路由表来说的，路由规则经过通道后，或是被接收（Accept），或是被拒绝（Reject），或是被修改。不同的协议可拥有的通道也不一样，例如BGP协议可以同时拥有<code>IPv4</code>和<code>IPv6</code>通道，RIP只能拥有IPv4或IPv6一种协议，而BFD则没有通道。</p><p>下面是根据官网样例修改而来的配置，实例化了一个名为<code>peer_one</code>的BGP协议，并且设置了<code>ipv4</code>和<code>ipv6</code>两个通道，两个通道都未指明连接的路由表，则使用默认的<code>master4</code>与<code>master6</code>路由表。其中在<code>ipv4</code> 通道中，导入方向配置为全部接收，导出方向上只导出静态路由，同时还会对路由规则的BGP信息进行修改：修改bgp  community，修改bgp  path；在<code>ipv6</code>通道上，则直接使用默认配置。</p><pre><code class="hljs json">protocol bgp peer_one &#123;        local 198.51.100.14 as 65000;        # Use a private AS number        neighbor 198.51.100.130 as 64496;    # Our neighbor ...        ipv4 &#123;                export filter &#123;                      # We use non-trivial export rules                        if source = RTS_STATIC then &#123; # Export only static routes                                # Assign our community                                bgp_community.add((65000,64501));                                # Artificially increase path length                                # by advertising local AS number twice                                if bgp_path ~ [= 65000 =] then                                        bgp_path.prepend(65000);                                accept;                        &#125;                        reject;                &#125;;                import all;        &#125;;        ipv6;&#125;</code></pre><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>在BIRD中，可以定义<strong>模板</strong>（template），通过模板来创建一个协议的多个实例。模板在使用BGP协议时非常好用，因为BGP通常都会设置多个BGP Peer。例如下面配置，通过模板提取出共用的配置，然后利用模板创建多个BGP邻居。</p><pre><code class="hljs json">template bgp foo &#123;        local 198.51.100.14 as 65000;        ipv4 &#123;                table mytable4;                import filter &#123; ... &#125;;                export none;        &#125;;        ipv6 &#123;                table mytable6;                import filter &#123; ... &#125;;                export none;        &#125;;&#125;protocol bgp bgp1 from foo &#123;        neighbor 198.51.100.130 as 64496;&#125;protocol bgp bgp2 from foo &#123;        neighbor 198.51.100.131 as 64496;&#125;</code></pre><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p><strong>过滤器</strong>（Filters）在上面的用例中已经出现了多次，通过在通道中添加过滤器，可以灵活地控制路由规则的交换。在过滤器中，你可以像访问变量一样直接使用各种路由属性，来编写各种判断条件，以决定对路由规则是ACCEPT还是REJECT，或是直接对路由属性进行修改。</p><p>为了便于复用，还可以以函数的形式定义一个过滤器，使用时在相应的通道中直接调用。需要注意的是，编写过滤器需要使用BIRD提供的专门的编程语言，它提供了一些例如<code>if</code>、<code>switch</code>的简单控制结构，但不允许有循环出现。同时，除了<code>int</code>、<code>string</code>这些基础的数据结构外，它还提供了例如<code>bgppatch</code>、<code>bgpmask</code>等这种表示路由规则中某些信息的数据结构。例如下面定义了一个名为<code>not_too_far</code>的过滤器，丢弃掉<code>rip_metric</code>大于10的路由规则，可以通过<code>import filter not_too_far</code>直接调用此函数。</p><pre><code class="hljs C">filter not_too_far<span class="hljs-keyword">int</span> var;&#123;        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">defined</span><span class="hljs-params">( rip_metric )</span> then</span><span class="hljs-function">                var </span>= rip_metric;        <span class="hljs-keyword">else</span> &#123;                var = <span class="hljs-number">1</span>;                rip_metric = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> rip_metric &gt; <span class="hljs-number">10</span> then                reject <span class="hljs-string">&quot;RIP metric is too big&quot;</span>;        <span class="hljs-keyword">else</span>                accept <span class="hljs-string">&quot;ok&quot;</span>;&#125;</code></pre><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><p>这里只介绍Calico中使用到的几种协议，以及用到的协议属性。</p><h3 id="device"><a href="#device" class="headerlink" title="device"></a>device</h3><p>准确来说，<code>device</code>并不算是一个协议，它不产生任何路由，也不支持通道，而是被用来从内核中获取网卡设备的信息。每个<code>bird.conf</code>的配置文件中，都应定义一个<code>device</code>。</p><pre><code class="hljs json">protocol device &#123;        scan time 10;           # Scan the interfaces often        interface &quot;eth0&quot; &#123;                preferred 192.168.1.1;                preferred 2001:db8:1:10::1;        &#125;;&#125;</code></pre><p>上面配置定义了BIRD每10s扫描一遍<code>eth0</code>网卡，同时定义了首选的IP地址。</p><h3 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h3><p><code>kernel</code>也不算真正的协议，它负责同步路由表与内核。如果内核支持多个内核路由表，那么可以创建多个<code>kernel</code>实例，否则只需要创建一个<code>kernel</code>实例。<code>kernel</code>协议有两个限制：</p><ul><li>不能将多个<code>kernel</code>实例都连接到同一个路由表上</li><li>不能修改导出（export）路由规则的目标地址</li></ul><p>一些主要的参数包括：</p><ul><li><code>learn switch</code>，开启后路由表可以从内核中学习到非内核生成（其他方式添加）的路由。“内核生成的路由”指的是由于本机网络的配置而产生的路由，比如<code>eth0</code>在被分配<code>192.168.1.2/24</code>后，会自动产生一条目的地为<code>192.168.1.0/24</code>，下一跳为<code>eth0</code>的路由。需要注意的是，即使是开启<code>learn</code>，<code>kernel</code>也不会将这些路由从内核导入（import）路由表，这种路由的传递需要使用到<code>direct</code>协议。（<code>switch</code>表示<code>on</code>和<code>off</code>两种值，下面相同）</li><li><code>persist switch</code>，BIRD退出时，在内核保留同步的路由（即不会进行clean up操作）。</li><li><code>scan time number</code>，同步间隔，单位秒</li></ul><pre><code class="hljs json"># 同步master4、master6路由表与主FIB，并在退出后保持同步的路由protocol kernel &#123;    learn;    persist;&#125;</code></pre><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>如上面所述，<code>direct</code>用于将内核生成的路由规则从内核导入到BIRD路由表中，可用的参数包括：</p><ul><li><code>interface pattern [, ...]</code>，用于指定传递由哪些网卡生成的路由规则，默认是全部网卡</li><li><code>check link switch</code>，开启后会考虑link的状态，当link状态为up时，传递路由，否则，撤销传递的路由</li></ul><pre><code class="hljs json"># 同步除了eth0以外的其他网卡protocol direct &#123;  interface -&quot;eth0&quot;, &quot;*&quot;; &#125;</code></pre><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>每一个BGP协议的实例，代表了一个BGP Peer连接。需要注意的是，部分参数的默认值对IBGP与EBGP并不相同，例如<code>aigp</code>默认在IBGP中是开启的，默认在EBGP是关闭的。协议的主要参数包括：</p><ul><li><code>local [ip] [port number] [as number]</code>，可以用来指定BGP的源IP地址以及本地的AS。</li><li><code>multihop [number]</code>，表示多跳的BGP，后面的<code>number</code>可以用来设置<code>TTL</code>的值，IBGP默认开启；相反的，还有个参数为<code>direct</code>，表示与BGP邻居直连，EBGP默认开启。</li><li><code>source address ip</code>，用来指定本端使用的BGP源地址。</li><li><code>add paths switch|rx|tx</code>，开启时，会将 BGP 配置为向同一目标通告多个路径，否则 BGP 仅通告活动路径。</li><li><code>password string</code> ，使用设置的密码进行BGP的身份验证。</li><li><code>rr client</code>，开启RR模式（Route Reflector）。</li><li><code>rr cluster id IPv4 address</code>，设置RR的<code>cluster id</code>，以防止路由环路。默认情况下，会直接使用BGP的<code>router id</code>（一般是ipv4地址）作为<code>cluster id</code>，当有多个RR时，需要使用此参数设置相同的<code>cluster id</code>。</li><li><code>bfd switch|graceful</code>，使用BFD作为BGP协议心跳机制。</li><li><code>passive switch</code>，被动模式，不主动初始化连接，而是等待其他BGP邻居发起连接。</li></ul><p>以上是协议一层的配置参数，在BGP协议中，通道也会有额外的参数，例如：</p><ul><li><code>gateway direct|recursive</code>，用来控制如何计算路由的gw属性。当设置为<code>direct</code>时，如果路由中的<code>bgp_next_hop</code>是和本机中的某个地址同一子网（同一个二层），则gw直接为<code>bgp_next_hop</code>，否则为对端BGP Peer的IP地址；当设置为<code>recursive</code>时，会从IGP路由表中查询<code>bgp_next_hop</code>来作为gw。</li><li><code>next hop keep switch|ibgp|ebgp</code>，开启后，BGP不再将<code>next hop</code>属性修改为自身，而是直接通告原始的<code>next hop</code>，这个参数在多跳的EBGP场景或BGP路由反射中会使用到。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://bird.network.cz/?get_doc&v=20&f=bird.html#toc5">BIRD官方手册</a></p>]]></content>
    
    
    <categories>
      
      <category>calico</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Calico</tag>
      
      <tag>BGP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入kube-proxy ipvs模式的conn_reuse_mode问题</title>
    <link href="/2021/01/15/%E6%B7%B1%E5%85%A5kube-proxy%20ipvs%E6%A8%A1%E5%BC%8F%E7%9A%84conn_reuse_mode%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/15/%E6%B7%B1%E5%85%A5kube-proxy%20ipvs%E6%A8%A1%E5%BC%8F%E7%9A%84conn_reuse_mode%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在高并发、短连接的场景下，kube-proxy ipvs存在rs删除失败或是延迟高的问题，社区也有不少Issue反馈，比如<a href="https://github.com/kubernetes/kubernetes/issues/81775">kube-proxy ipvs conn_reuse_mode setting causes errors with high load from single client</a>。文本对这些问题进行了梳理，试图介绍产生这些问题的内部原因。由于能力有限，其中涉及内核部分，只能浅尝辄止。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="端口重用"><a href="#端口重用" class="headerlink" title="端口重用"></a>端口重用</h3><p>一切问题来源于端口重用。在TCP四次挥手中有个<code>TIME_WAIT</code>的状态，作为先发送<code>FIN</code>包的一端，在接收到对端发送的<code>FIN</code>包后进入<code>TIME_WAIT</code>，在经过<code>2MSL</code>后才会真正关闭连接。<code>TIME_WAIT</code>状态的存在，一来可以避免将之前连接的延迟报文，作为当前连接的报文处理；二是可以处理最后一个ACK丢失带来的问题。</p><p><img src="/img/2021-01-15-TCP.jpg"></p><p>而在短连接、高并发的场景下，会出现大量的<code>TIME-WAIT</code>连接，导致资源无法及时释放。Linux中内核参数<code>net.ipv4.tcp_tw_reuse</code>提供了一种减少<code>TIME-WAIT</code>连接的方式，可以将<code>TIME-WAIT</code>连接的端口分配给新的TCP连接，来复用端口。</p><pre><code class="hljs text">tcp_tw_reuse - BOOLEANAllow to reuse TIME-WAIT sockets for new connections when it issafe from protocol viewpoint. Default value is 0.It should not be changed without advice/request of technicalexperts.</code></pre><h3 id="ipvs如何处理端口重用？"><a href="#ipvs如何处理端口重用？" class="headerlink" title="ipvs如何处理端口重用？"></a>ipvs如何处理端口重用？</h3><p>ipvs对端口的复用策略主要由内核参数<code>net.ipv4.vs.conn_reuse_mode</code>决定</p><pre><code class="hljs text">conn_reuse_mode - INTEGER1 - defaultControls how ipvs will deal with connections that are detectedport reuse. It is a bitmap, with the values being:0: disable any special handling on port reuse. The newconnection will be delivered to the same real server that wasservicing the previous connection. This will effectivelydisable expire_nodest_conn.bit 1: enable rescheduling of new connections when it is safe.That is, whenever expire_nodest_conn and for TCP sockets, whenthe connection is in TIME_WAIT state (which is only possible ifyou use NAT mode).bit 2: it is bit 1 plus, for TCP connections, when connectionsare in FIN_WAIT state, as this is the last state seen by loadbalancer in Direct Routing mode. This bit helps on adding newreal servers to a very busy cluster.</code></pre><p>当<code>net.ipv4.vs.conn_reuse_mode=0</code>时，ipvs不会对新连接进行重新负载，而是复用之前的负载结果，将新连接转发到原来的rs上；当<code>net.ipv4.vs.conn_reuse_mode=1</code>时，ipvs则会对新连接进行重新调度。</p><p>相关的，还有一个内核参数<code>net.ipv4.vs.expire_nodest_conn</code>，用于控制连接的rs不可用时的处理。在开启时，如果后端rs不可用，会立即结束掉该连接，使客户端重新发起新的连接请求；否则将数据包<strong>silently drop</strong>，也就是DROP掉数据包但不结束连接，等待客户端的重试。</p><p>另外，关于<strong>destination 不可用</strong>的判断，是在ipvs执行删除<code>vs</code>（在<code>__ip_vs_del_service()</code>中实现）或删除<code>rs</code>（在<code>ip_vs_del_dest()</code>中实现）时，会调用<code>__ip_vs_unlink_dest()</code>方法，将相应的destination置为不可用。</p><pre><code class="hljs text">expire_nodest_conn - BOOLEAN        0 - disabled (default)        not 0 - enabled        The default value is 0, the load balancer will silently drop        packets when its destination server is not available. It may        be useful, when user-space monitoring program deletes the        destination server (because of server overload or wrong        detection) and add back the server later, and the connections        to the server can continue.        If this feature is enabled, the load balancer will expire the        connection immediately when a packet arrives and its        destination server is not available, then the client program        will be notified that the connection is closed. This is        equivalent to the feature some people requires to flush        connections when its destination is not available.</code></pre><p>  关于ipvs如何处理端口复用的连接，这块主要实现逻辑在<code>net/netfilter/ipvs/ip_vs_core.c</code>的<code>ip_vs_in()</code>方法中：</p><pre><code class="hljs C"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Check if the packet belongs to an existing connection entry</span><span class="hljs-comment"> */</span>cp = pp-&gt;conn_in_get(ipvs, af, skb, &amp;iph);  <span class="hljs-comment">//找是属于某个已有的connection</span>conn_reuse_mode = sysctl_conn_reuse_mode(ipvs);<span class="hljs-comment">//当conn_reuse_mode开启，同时出现端口复用（例如收到TCP的SYN包，并且也属于已有的connection），进行处理</span><span class="hljs-keyword">if</span> (conn_reuse_mode &amp;&amp; !iph.fragoffs &amp;&amp; is_new_conn(skb, &amp;iph) &amp;&amp; cp) &#123; <span class="hljs-keyword">bool</span> uses_ct = <span class="hljs-literal">false</span>, resched = <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果开启了expire_nodest_conn、目标rs的weight为0</span><span class="hljs-keyword">if</span> (unlikely(sysctl_expire_nodest_conn(ipvs)) &amp;&amp; cp-&gt;dest &amp;&amp;    unlikely(!atomic_read(&amp;cp-&gt;dest-&gt;weight))) &#123;resched = <span class="hljs-literal">true</span>;<span class="hljs-comment">//查询是否用到了conntrack</span>uses_ct = ip_vs_conn_uses_conntrack(cp, skb);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_new_conn_expected(cp, conn_reuse_mode)) &#123;<span class="hljs-comment">//连接是expected的情况，比如FTP</span>uses_ct = ip_vs_conn_uses_conntrack(cp, skb);<span class="hljs-keyword">if</span> (!atomic_read(&amp;cp-&gt;n_control)) &#123;resched = <span class="hljs-literal">true</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* Do not reschedule controlling connection</span><span class="hljs-comment"> * that uses conntrack while it is still</span><span class="hljs-comment"> * referenced by controlled connection(s).</span><span class="hljs-comment"> */</span>resched = !uses_ct;&#125;&#125;<span class="hljs-comment">//如果expire_nodest_conn未开启，并且也非期望连接，实际上直接跳出了</span><span class="hljs-keyword">if</span> (resched) &#123;<span class="hljs-keyword">if</span> (!atomic_read(&amp;cp-&gt;n_control))ip_vs_conn_expire_now(cp);__ip_vs_conn_put(cp);<span class="hljs-comment">//当开启了net.ipv4.vs.conntrack，SYN数据包会直接丢弃，等待客户端重新发送SYN</span><span class="hljs-keyword">if</span> (uses_ct)<span class="hljs-keyword">return</span> NF_DROP;<span class="hljs-comment">//未开启conntrack时，会进入下面ip_vs_try_to_schedule的流程</span>cp = <span class="hljs-literal">NULL</span>;&#125;&#125;<span class="hljs-keyword">if</span> (unlikely(!cp)) &#123;<span class="hljs-keyword">int</span> v;<span class="hljs-keyword">if</span> (!ip_vs_try_to_schedule(ipvs, af, skb, pd, &amp;v, &amp;cp, &amp;iph))<span class="hljs-keyword">return</span> v;&#125;IP_VS_DBG_PKT(<span class="hljs-number">11</span>, af, pp, skb, iph.off, <span class="hljs-string">&quot;Incoming packet&quot;</span>);<span class="hljs-comment">/* Check the server status */</span><span class="hljs-keyword">if</span> (cp-&gt;dest &amp;&amp; !(cp-&gt;dest-&gt;flags &amp; IP_VS_DEST_F_AVAILABLE)) &#123;<span class="hljs-comment">/* the destination server is not available */</span>__u32 flags = cp-&gt;flags;<span class="hljs-comment">/* when timer already started, silently drop the packet.*/</span><span class="hljs-keyword">if</span> (timer_pending(&amp;cp-&gt;timer))__ip_vs_conn_put(cp);<span class="hljs-keyword">else</span>ip_vs_conn_put(cp);<span class="hljs-keyword">if</span> (sysctl_expire_nodest_conn(ipvs) &amp;&amp;    !(flags &amp; IP_VS_CONN_F_ONE_PACKET)) &#123;<span class="hljs-comment">/* try to expire the connection immediately */</span>ip_vs_conn_expire_now(cp);&#125;<span class="hljs-keyword">return</span> NF_DROP;&#125;</code></pre><h3 id="kube-proxy-ipvs模式下的优雅删除"><a href="#kube-proxy-ipvs模式下的优雅删除" class="headerlink" title="kube-proxy ipvs模式下的优雅删除"></a>kube-proxy ipvs模式下的优雅删除</h3><p>Kubernetes提供了Pod优雅删除机制。当我们决定干掉一个Pod时，我们可以通过<code>PreStop Hook</code>来做一些服务下线前的处理，同时Kubernetes也有个<code>grace period</code>，超过这个时间但未完成删除的Pod会被强制删除。</p><p>而在Kubernetes 1.13之前，kube-proxy ipvs模式并不支持优雅删除，当Endpoint被删除时，kube-proxy会直接移除掉ipvs中对应的rs，这样会导致后续的数据包被丢掉。</p><p>在1.13版本后，Kubernetes添加了<a href="https://github.com/kubernetes/kubernetes/pull/66012">IPVS优雅删除</a>的逻辑，主要是两点：</p><ul><li>当Pod被删除时，kube-proxy会先将rs的<code>weight</code>置为0，以防止新连接的请求发送到此rs，由于不再直接删除rs，旧连接仍能与rs正常通信；</li><li>当rs的<code>ActiveConn</code>数量为0（后面版本已改为<code>ActiveConn+InactiveConn==0</code>)，即不再有连接转发到此rs时，此rs才会真正被移除。</li></ul><h2 id="kube-proxy-ipvs模式下的问题"><a href="#kube-proxy-ipvs模式下的问题" class="headerlink" title="kube-proxy ipvs模式下的问题"></a>kube-proxy ipvs模式下的问题</h2><p>看上去kube-proxy ipvs的删除是优雅了，但当优雅删除正巧碰到端口重用，那问题就来了。</p><p>首先，kube-proxy希望通过设置<code>weight</code>为0，来避免新连接转发到此rs。但当<code>net.ipv4.vs.conn_reuse_mode=0</code>时，对于端口复用的连接，ipvs不会主动进行新的调度（调用<code>ip_vs_try_to_schedule</code>方法）；同时，只是将<code>weight</code>置为0，也并不会触发由<code>expire_nodest_conn</code>控制的结束连接或DROP操作，就这样，新连接的数据包当做什么都没发生一样，发送给了正在删除的Pod。这样一来，只要不断的有端口复用的连接请求发来，rs就不会被kube-proxy删除，上面提到的优雅删除的两点均无法实现。</p><p>而当<code>net.ipv4.vs.conn_reuse_mode=1</code>时，根据<code>ip_vs_in()</code>的处理逻辑，当开启了<code>net.ipv4.vs.conntrack</code>时，会DROP掉第一个SYN包，导致SYN的重传，有1S延迟。而Kube-proxy在IPVS模式下，使用了iptables进行<code>MASQUERADE</code>，也正好开启了<code>net.ipv4.vs.conntrack</code>。</p><pre><code class="hljs text">conntrack - BOOLEAN0 - disabled (default)not 0 - enabledIf set, maintain connection tracking entries forconnections handled by IPVS.This should be enabled if connections handled by IPVS are to bealso handled by stateful firewall rules. That is, iptables rulesthat make use of connection tracking.  It is a performanceoptimisation to disable this setting otherwise.Connections handled by the IPVS FTP application modulewill have connection tracking entries regardless of this setting.Only available when IPVS is compiled with CONFIG_IP_VS_NFCT enabled.</code></pre><p>这样看来，目前的情况似乎是，如果你需要实现优雅删除中的“保持旧连接不变，调度新连接”能力，那就要付出1s的延迟代价；如果你要好的性能，那么就不能重新调度。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>从Kubernetes角度来说，Kube-proxy需要在保证性能的前提下，找到一种能让新连接重新调度的方式。但目前从内核代码中可以看到，需要将参数设置如下</p><pre><code class="hljs text">net.ipv4.vs.conntrack=0net.ipv4.vs.conn_reuse_mode=1net.ipv4.vs.expire_nodest_conn=1</code></pre><p>但Kube-proxy ipvs模式目前无法摆脱iptables来完成k8s service的转发。此外，Kube-proxy只有在<code>ActiveConn+InactiveConn==0</code>时才会删除rs，除此之外，在新的Endpoint和<code>GracefulTerminationList</code>（保存了<code>weight</code>为0，但暂未删除的rs）中的rs冲突时，才会立即删除rs。这种逻辑似乎并不合理。目前Pod已有优雅删除的逻辑，而kube-proxy应基于Pod的优雅删除，在网络层面做好rs的优雅删除，因此在kubelet完全删除Pod后，Kube-proxy是否也应该考虑同时删除相应的rs？</p><p>另外，从内核角度来说，ipvs需要提供一种方式，能在端口复用、同时使用conntrack的场景下，可以对新连接直接重新调度。</p><h2 id="即将到来"><a href="#即将到来" class="headerlink" title="即将到来"></a>即将到来</h2><p>这个问题在社区讨论一段时间后，目前出现的几个相关的解决如下：<br><strong>内核两个Patch</strong></p><ul><li><a href="http://patchwork.ozlabs.org/project/netfilter-devel/patch/20200701151719.4751-1-ja@ssi.bg/">ipvs: allow connection reuse for unconfirmed conntrack</a><br>修改了<code>ip_vs_conn_uses_conntrack()</code>方法的逻辑，当使用<code>unconfirmed conntrack</code>时，返回false，这种修改针对了TIME_WAIT的conntrack。</li><li><a href="http://patchwork.ozlabs.org/project/netfilter-devel/patch/20200708161638.13584-1-kim.andrewsy@gmail.com/"> ipvs: queue delayed work to expire no destination connections if expire_nodest_conn=1</a><br>提前了<code>expire  connection</code>的操作，在destination被删除后，便开始将<code>expire  connection</code>操作入队列。而不是等到数据包真正发过来时，才做<code>expire  connection</code>，以此来减少数据包的丢失。</li></ul><p><strong>Kubernetes</strong><br><a href="https://github.com/kubernetes/enhancements/pull/1607">Graceful Termination for External Traffic Policy Local</a><br><a href="https://github.com/kubernetes/kubernetes/pull/92968">Add Terminating Condition to EndpointSlice</a><br>正如前面所说的，Kube-proxy需要能够感知到Pod的优雅删除过程，来同步进行rs的删除。目前，已有一个相应的KEP在进行中，通过在<code>Endpoint.EndpointConditions</code>中添加<code>terminating</code>字段，来为kube-proxy提供感知方式。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kube-proxy</tag>
      
      <tag>IPVS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
